{"meta":{"title":"è”æçš„åšå®¢","subtitle":"","description":"è®°å½•ä¸€ä¸‹!","author":"è”æ","url":"https://leungto.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-06-18T15:09:15.000Z","updated":"2022-06-21T03:38:52.950Z","comments":true,"path":"categories/index.html","permalink":"https://leungto.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-18T15:09:33.000Z","updated":"2022-06-21T03:39:13.178Z","comments":true,"path":"tags/index.html","permalink":"https://leungto.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-06-21T15:09:41.000Z","updated":"2024-02-01T09:38:28.207Z","comments":true,"path":"about/index.html","permalink":"https://leungto.github.io/about/index.html","excerpt":"","text":"ç ”0 HNU -&gt; FDU DB4AI QQ:2744386030 æˆ‘ä»¬è¦åƒè·³èˆä¸€æ ·è®¤çœŸè¿‡å¥½ä½œä¸ºåˆ¹é‚£çš„â€œæ­¤æ—¶æ­¤åˆ»â€ï¼Œæ—¢ä¸çœ‹è¿‡å»ä¹Ÿä¸çœ‹æœªæ¥ï¼Œåªéœ€è¦è¿‡å¥½æ¯ä¸€ä¸ªå®Œç»“çš„åˆ¹é‚£ã€‚æ²¡å¿…è¦ä¸è°ç«äº‰ï¼Œä¹Ÿä¸éœ€è¦ç›®çš„åœ°ï¼Œåªè¦è·³ç€ï¼Œå°±ä¸€å®šä¼šåˆ°è¾¾æŸä¸€ä¸ªåœ°æ–¹ã€‚"}],"posts":[{"title":"NLPå…¥é—¨","slug":"NLPå…¥é—¨","date":"2024-04-05T03:00:35.000Z","updated":"2024-07-22T16:17:57.127Z","comments":true,"path":"2024/04/05/NLPå…¥é—¨/","link":"","permalink":"https://leungto.github.io/2024/04/05/NLP%E5%85%A5%E9%97%A8/","excerpt":"","text":"æ€»ç»“ Python&amp;Pytorch pythonåŸºç¡€æ•™ç¨‹ pythonè‡ªç„¶è¯­è¨€å®æˆ˜ pytorchæ·±åº¦å­¦ä¹ å®è·µ Deep Learning å´æ©è¾¾æ·±åº¦å­¦ä¹  å®è·µï¼šææ²/Bç«™è§†é¢‘ NLP CS224n ä¿¡æ¯ 1.æœºå™¨å­¦ä¹ ï¼Œçœ‹ã€Šæœºå™¨å­¦ä¹ å®æˆ˜ã€‹Peter Harringtonè‘—ï¼Œå¹¶å¤ç°ä¹¦ä¸­ä»£ç ã€‚ 2.æ·±åº¦å­¦ä¹ ç†è®ºï¼Œçœ‹æ–‹è—¤åº·æ¯…çš„ã€Šæ·±åº¦å­¦ä¹ å…¥é—¨â€”â€”åŸºäºpythonçš„ç†è®ºä¸å®ç°ã€‹ï¼Œå¹¶å¤ç°ä»£ç  3.PyTorchæ¡†æ¶ï¼Œçœ‹ã€ŠPythonæ·±åº¦å­¦ä¹ åŸºäºPytorchã€‹å´èŒ‚è´µè‘—ï¼Œå¹¶å¤ç°ä»£ç ã€‚ 4.æ·±åº¦å­¦ä¹ è¿›é˜¶è‡ªç„¶è¯­è¨€å¤„ç†ï¼Œçœ‹æ–‹è—¤åº·æ¯…çš„ã€Šæ·±åº¦å­¦ä¹ è¿›é˜¶è‡ªç„¶è¯­è¨€å¤„ç†ã€‹ï¼Œå¹¶å¤ç°ä»£ç ã€‚ 5.çœ‹é¡¶ä¼šé¡¶åˆŠè®ºæ–‡ï¼Œå¤ç°ä»£ç ã€‚å¦‚ï¼šCVPRï¼ŒNIPSï¼ŒAAAIï¼ŒICCVï¼ŒECCVç­‰ã€‚ NLPç®—æ³•å­¦ä¹ è·¯çº¿-è‡ªå·±æ•´ç†_nlpå…¥é—¨å­¦ä¹ è·¯çº¿æ•™ç¨‹åœ°å€-CSDNåšå®¢","categories":[],"tags":[{"name":"NL2SQL","slug":"NL2SQL","permalink":"https://leungto.github.io/tags/NL2SQL/"}]},{"title":"algorithm plus","slug":"algorithm-plus","date":"2023-08-15T11:56:19.000Z","updated":"2023-08-23T12:47:17.189Z","comments":true,"path":"2023/08/15/algorithm-plus/","link":"","permalink":"https://leungto.github.io/2023/08/15/algorithm-plus/","excerpt":"rt","text":"rt åŠ¨æ€è§„åˆ’æ•°å­—ä¸‰è§’å½¢æ¨¡å‹æ‘˜èŠ±ç”Ÿ å› ä¸ºåªèƒ½ä»ä¸Šé¢å’Œå·¦è¾¹è¿‡æ¥ï¼Œæ‰€ä»¥æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i][j]=(dp[i-1][j],dp[i][j-1])+a[i][j] 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=105;int n;int a[N][N],dp[N][N];int main()&#123; cin&gt;&gt;n; int r,c; while(n--) &#123; cin&gt;&gt;r&gt;&gt;c; for(int i=1;i&lt;=r;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=r;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125; cout&lt;&lt;dp[r][c]&lt;&lt;endl; &#125; return 0;&#125; æœ€ä½é€šä¿¡è´¹N*Nçš„æ­£æ–¹å½¢æ–¹æ ¼ï¼Œå·¦ä¸Šè§’è¿›å³ä¸‹è§’å‡ºï¼Œé¢˜ç›®æ¡ä»¶æ€»è·¯å¾„é•¿åº¦ä¸º2*N+1ï¼Œå³åªèƒ½å‘ä¸‹æˆ–è€…å‘å³èµ°ï¼Œé€’æ¨æ–¹ç¨‹ä¸ºdp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j] 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=105;int a[N][N];int dp[N][N];int n;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; memset(dp,0x3f,sizeof dp);//è¾¹ç•Œå¤„ç† //å¤„ç†dp[1][1] dp[0][1]=0; dp[1][0]=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125; cout&lt;&lt;dp[n][n]; return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"}]},{"title":"dive into deep learning","slug":"dive-into-deep-learning","date":"2023-07-22T07:33:18.000Z","updated":"2024-09-04T04:27:16.766Z","comments":true,"path":"2023/07/22/dive-into-deep-learning/","link":"","permalink":"https://leungto.github.io/2023/07/22/dive-into-deep-learning/","excerpt":"æ·±åº¦å­¦ä¹ ","text":"æ·±åº¦å­¦ä¹  pytorch ã€PyTorchæ·±åº¦å­¦ä¹ å¿«é€Ÿå…¥é—¨æ•™ç¨‹ï¼ˆç»å¯¹é€šä¿—æ˜“æ‡‚ï¼ï¼‰ã€å°åœŸå †ã€‘ã€‘ https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=f21aab4ae7e1148acd5e06c0dddddfd9 1.ç¯å¢ƒç®¡ç†å»ºç«‹ä¸åŒçš„pythonç‰ˆæœ¬ç¯å¢ƒï¼ˆanaconda promptï¼‰ 1conda create -n pytorch python=3.6 #åˆ›å»ºä¸€ä¸ªåä¸ºpytorchçš„ç¯å¢ƒ æ¿€æ´»/è¿›å…¥ç‰¹å®šç¯å¢ƒ 1conda activate pytorch ç¯å¢ƒä¸‹çš„å·¥å…·åŒ… 1pip list å®‰è£…pytorchå·¥å…·åŒ… åœ¨pytorchå®˜ç½‘æŒ‰ç…§ç¯å¢ƒå¤åˆ¶å‘½ä»¤åœ¨ç‰¹å®šç¯å¢ƒè¿›è¡Œä¸‹è½½ å®‰è£…å®Œä¹‹åæ£€æŸ¥pytorchå®‰è£…æƒ…å†µ 123pythonimport torchtorch.cuda.is_available() ä¸¤ä¸ªå·¥å…·ï¼špycharmå’Œjupyter pycharmåˆ›å»ºé¡¹ç›®è®°å¾—å‹¾é€‰å¯¹åº”çš„interpreter(å¦‚ï¼šD:\\Users\\lzh\\anaconda3\\envs\\pytorch) jupyteré€‰æ‹©ç¯å¢ƒï¼šåœ¨promptä¸‹å‘½ä»¤è¡Œå¼€å¯jupyterï¼š 12conda install nb_condajupyter notebook jupyter shift+enteræ‰§è¡Œå¹¶ç¼–è¾‘ä¸‹ä¸€è¡Œ 2.ä¸¤ä¸ªå‡½æ•° 1234dir(torch) #dir(package)dir(torch.cuda)dir(torch.cuda.is_available) #è¾“å‡ºæ˜¯åŒä¸‹åˆ’çº¿ï¼ŒåŒä¸‹åˆ’çº¿è¡¨ç¤ºä¸å¯ä¿®æ”¹ï¼Œæ­¤æ—¶ä¸èƒ½è¿›ä¸€æ­¥æ‰“å¼€äº†ï¼Œå°±æ˜¯å‡½æ•°äº†help(torch.cuda.is_available) 3.æ•°æ®çš„åŠ è½½ä¸¤ä¸ªç±»ï¼š Datasetï¼šæä¾›ä¸€ç§æ–¹å¼å»è·å–æ•°æ®åŠå…¶labelã€‚æå–æ•°æ®ï¼Œè¿›è¡Œç¼–å·ï¼Œæ•°æ®å¯¹åº”label å¦‚ä½•è·å–æ¯ä¸€ä¸ªæ•°æ®åŠå…¶label å‘Šè¯‰æˆ‘ä»¬æ€»å…±æœ‰å¤šå°‘çš„æ•°æ® Dataloaderï¼šä¸ºç½‘ç»œæä¾›ä¸åŒçš„æ•°æ®å½¢å¼ã€‚é€è¿›ç½‘ç»œä¹‹å‰è¿›è¡Œæ‰“åŒ…å’Œå‹ç¼© å¦‚æœæ–‡ä»¶å¤¹åç§°å°±æ˜¯labelï¼š 1234567891011121314151617181920212223242526from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset): def __init__(self,root_dir,label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(self.root_dir,self.label_dir) self.img_path = os.listdir(self.path) def __getitem__(self, idx): img_name = self.img_path[idx] img_item_path = os.path.join(self.root_dir,self.label_dir,img_name) img = Image.open(img_item_path) label = self.label_dir return img, label def __len__(self): return len(self.img_path)root_dir = &quot;hymenoptera_data/train&quot;ants_label_dir = &quot;ants&quot;bees_label_dir = &quot;bees&quot;ants_dataset = MyData(root_dir, ants_label_dir)bees_dataset = MyData(root_dir, bees_label_dir)train_dataset = ants_dataset + bees_dataset å¦‚æœåˆ†å¼€äº†imgå’Œlabelï¼š 123456789101112131415161718192021222324252627282930313233343536from torch.utils.data import Datasetimport osfrom PIL import Imageclass MyData(Dataset): def __init__(self,root_dir,image_dir,label_dir): self.root_dir = root_dir self.image_dir = image_dir self.label_dir = label_dir self.img_path = os.path.join(self.root_dir, self.image_dir) self.label_path = os.path.join(self.root_dir, self.label_dir) self.img_name = os.listdir(self.img_path) self.label_name = os.listdir(self.label_path) def __getitem__(self, idx): img_path = os.path.join(self.img_path,self.img_name[idx]) label_path = os.path.join(self.label_path, self.label_name[idx]) img = Image.open(img_path) f = open(label_path) label = f.readline() f.close() return img,label def __len__(self): return len(self.img_name)root_dir = &quot;new_data/train&quot;ants_image_dir = &quot;ants_image&quot;ants_label_dir = &quot;ants_label&quot;bees_image_dir = &quot;bees_image&quot;bees_label_dir = &quot;bees_label&quot;ants_dataset = MyData(root_dir,ants_image_dir,ants_label_dir)bees_dataset = MyData(root_dir,bees_image_dir,bees_label_dir)train_dataset = ants_dataset + bees_dataset 4.tensorboardçš„ä½¿ç”¨1ï¼‰SummaryWriterçš„ä½¿ç”¨æ–‡ä»¶åä¸èƒ½æ˜¯tensorboard.py 12345678from torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&quot;logs&quot;) #å­˜å‚¨tensorboardæ—¥å¿—åœ°æ–¹for i in range(100): writer.add_scalar(&quot;y=x&quot;, i, i) # name y xwriter.close() è¿è¡Œåä»£ç ç›¸åŒæ–‡ä»¶å¤¹ä¸‹ç”Ÿæˆlogsæ–‡ä»¶å¤¹ æ§åˆ¶å°ï¼š 1tensorboad --logdir=logs #logså¯æ›¿æ¢ä¸ºå…¶ä»–å­˜å‚¨æ—¥å¿—æ–‡ä»¶çš„æ–‡ä»¶å¤¹åç§° å¦‚æœæ”¹å˜å›¾ç‰‡çš„åç§°ï¼Œä¼šé‡æ–°ç”»ä¸€å¹…å›¾ï¼Œå¦‚æœä¸æ”¹å˜å›¾ç‰‡çš„åç§°ï¼Œä¼šåœ¨ä¸Šä¸€å¹…å›¾ä¸Šç”» è§£å†³æ–¹æ³•ï¼šåˆ æ‰åŸæœ‰logæ–‡ä»¶ 2ï¼‰add_imageçš„ä½¿ç”¨add_imageå°†å›¾ç‰‡åœ¨tensorboardä¸­å±•ç¤ºï¼š 1234567891011121314from torch.utils.tensorboard import SummaryWriterimport numpy as npfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;) #å­˜å‚¨tensorboardæ—¥å¿—åœ°æ–¹image_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img_PIL = Image.open(image_path)img_array = np.array(img_PIL)print(type(img_array))print(img_array.shape)writer.add_image(&quot;test&quot;,img_array,2,dataformats=&#x27;HWC&#x27;) # æ ‡é¢˜ å†…å®¹(é™å®šæ ¼å¼) ç¬¬å‡ å¹… æ ¼å¼writer.close() 5.transformçš„ä½¿ç”¨1ï¼‰æµç¨‹ 123456789101112131415from PIL import Imagefrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transforms# è·å–å›¾ç‰‡img_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img = Image.open(img_path)# tensorboardwriter = SummaryWriter(&quot;logs&quot;)# transformtensor_trans = transforms.ToTensor()tensor_img = tensor_trans(img)# add_imagewriter.add_image(&quot;img&quot;,tensor_img)writer.close() 2ï¼‰å¸¸è§çš„Transforms å†…ç½®call ï¼ˆctrl+p æç¤ºå‚æ•°ï¼‰ 12345678910class Person: def __call__(self, name): print(&quot;__call__ &quot;+name) def hello(self, name): print(&quot;hello &quot;+name)person = Person()person(&quot;zhangsan&quot;)person.hello(&quot;zhangsan&quot;) transforms.Normalize transforms.Resize transforms.compose:ç»„åˆå¤šä¸ªæ“ä½œ transforms.RandomCrop 1234567891011121314151617181920212223242526272829303132333435363738394041424344from PIL import Imagefrom torchvision import transformsfrom torch.utils.tensorboard import SummaryWriter# æ‰“å¼€å›¾ç‰‡img_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img = Image.open(img_path)print(img)# å»ºç«‹tensorboardwriter = SummaryWriter(&quot;logs&quot;)# 1. totensortrans_totensor = transforms.ToTensor()img_tensor = trans_totensor(img)# æ·»åŠ åŸå§‹å›¾ç‰‡writer.add_image(&quot;img&quot;, img_tensor, 0)# è·å–normalizeåçš„å›¾ç‰‡# 2. normalizetrans_nore = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])img_nore = trans_nore(img_tensor)# æ·»åŠ è½¬æ¢åçš„å›¾ç‰‡writer.add_image(&quot;img&quot;, img_nore, 1)# 3. Resizeprint(img.size)trans_resize = transforms.Resize((512,512))img_resize = trans_resize(img)img_resize = trans_totensor(img_resize)writer.add_image(&quot;Resize&quot;, img_resize, 0)print(img_resize)# 4. composetrans_resize_2 = transforms.Resize(512)trans_compose = transforms.Compose([trans_totensor, trans_resize_2])img_resize_2 = trans_compose(img)writer.add_image(&quot;Resize&quot;, img_resize_2, 1)# 5. RandomCroptrans_random = transforms.RandomCrop((500, 500))trans_compose_2 = transforms.Compose([trans_random, trans_totensor])for i in range(10): img_crop = trans_compose_2(img) writer.add_image(&quot;RandomCrop&quot;, img_crop, i)writer.close() å…³æ³¨è¾“å…¥è¾“å‡º æŸ¥é˜…å®˜æ–¹æ–‡æ¡£ å…³æ³¨æ–¹æ³•å‚æ•° 6.æ•°æ®é›†çš„ä½¿ç”¨123456789101112131415161718import torchvisionfrom torchvision import transformsfrom torch.utils.tensorboard import SummaryWriter# æ•°æ®é›†çš„å˜æ¢dataset_transform = transforms.Compose([ transforms.ToTensor()])# ä¸‹è½½æ•°æ®é›†train_set = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=True, transform=dataset_transform, download=True)test_set = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=dataset_transform, download=False)# åœ¨tensorboardä¸Šå±•ç¤ºwriter = SummaryWriter(&quot;p10&quot;)for i in range(10): img, target = test_set[i] writer.add_image(&quot;test_set&quot;,img,i)writer.close() å¦‚æœä¸‹è½½ä¸æˆåŠŸï¼Œé€šè¿‡è¿…é›·ç­‰å…¶ä»–æ–¹å¼ä¸‹è½½ï¼Œå»ºç«‹datasetæ–‡ä»¶å¤¹å¹¶å°†å‹ç¼©æ–‡ä»¶ç›´æ¥æ”¾åˆ°datasetæ–‡ä»¶å¤¹ä¸‹ï¼Œè¿è¡Œä»£ç ä¼šè‡ªåŠ¨è§£å‹ 7.Dataloaderçš„ä½¿ç”¨dataloaderä»datasetä¸­å–æ•°æ®æ‰“åŒ…ï¼Œä»¥ä¾¿é€å…¥ç¥ç»ç½‘ç»œ torch.utils.data.DataLoader() batch_size è¡¨ç¤ºæ¯æ¬¡å¤šå°‘ä¸ªbatch_sizeæ‰“æˆä¸€åŒ… shuffle è¡¨ç¤ºæ˜¯å¦æ‰“ä¹±é¡ºåºï¼ˆæ¯æ¬¡for data in loaderæ—¶æ˜¯å¦æ‰“ä¹±é¡ºåºï¼Œè€Œä¸æ˜¯è¯´æ‰“åŒ…æ˜¯å¦éšæœºå–ï¼Œé»˜è®¤å°±æ˜¯éšæœºå–çš„ï¼‰ drop_last å½“data/batch_sizeé™¤ä¸å°½è¦ä¸è¦èˆå»å‰©ä¸‹çš„data numofworks è®¾ç½®ä¸º0è¡¨ç¤ºç”¨ä¸»è¿›ç¨‹åŠ è½½ï¼ŒWindowsä¸‹è®¾ç½®ä¸ºå…¶ä»–å€¼å¯èƒ½å‡ºé”™ 12345678910111213141516171819202122232425import torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWritertest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)# ç¬¬ä¸€å¼ å›¾ç‰‡å’Œtargetimg, target =test_data[0]print(img.shape) #torch.Size([3, 32, 32])print(target) #3# æµ‹è¯•batchsizeã€drop_lastã€shufflewriter = SummaryWriter(&quot;dataloader&quot;)# å¯ä»¥å‘ç°ä¸¤è½®ç»“æœä¸ä¸€æ ·ï¼Œå› ä¸ºshuffleçš„åŸå› for epoch in range(2): step = 0 for data in test_loader: imgs , targets = data writer.add_images(&quot;epoch: &#123;&#125;&quot;.format(epoch), imgs, step) step = step + 1writer.close() 8. torch.nnnn.moduleï¼šBase class for all neural network modules. æ‰€æœ‰ç¥ç»ç½‘ç»œæ¨¡å‹éƒ½è¦ç»§æ‰¿nn.module ç¥ç»ç½‘ç»œè¿è¡Œäºforwardå‡½æ•°ä¹‹ä¸­ 123456789101112131415import torchfrom torch import nnclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() def forward(self, input): output = input + 1 return outputtudui =Tudui()x = torch.tensor(1.0)output = tudui(x)print(output) pycharmçš„æ–­ç‚¹è°ƒè¯• 9.å·ç§¯æ“ä½œ torch.nn.functional.conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) strideï¼šå·ç§¯æ ¸ç§»åŠ¨çš„æ­¥é•¿ paddingï¼šè¾“å…¥å›¾åƒæ˜¯å¦å¡«å…… weightï¼šå·ç§¯æ ¸ 123456789101112131415161718192021222324252627import torchimport torch.nn.functional as F# è¾“å…¥å›¾åƒinput = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]])# å·ç§¯æ ¸kernel = torch.tensor([[1, 2, 1], [0, 1, 0], [2, 1, 0]])input = torch.reshape(input, (1, 1, 5, 5))kernel = torch.reshape(kernel, (1, 1, 3, 3))print(input.shape)print(kernel.shape)# å·ç§¯æ“ä½œoutput = F.conv2d(input, kernel, stride=1)print(output)output2 = F.conv2d(input, kernel, stride=2)print(output2)output3 = F.conv2d(input, kernel, stride=1, padding=1)print(output3) 10.ç¥ç»ç½‘ç»œå·ç§¯å±‚ torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=â€™zerosâ€™, device=None, dtype=None) in_channelsï¼šè¾“å…¥é€šé“æ•° out_channelsï¼šå·ç§¯å±‚å†…éƒ¨å¯é€šè¿‡å¢åŠ å·ç§¯æ ¸æ•°é‡æ¥å¢åŠ é€šé“æ•° kernel_sizeï¼šåªéœ€è¦è®¾ç½®kernel_sizeï¼Œå‚æ•°è®­ç»ƒä¸­è°ƒæ•´ 1234567891011121314151617181920212223242526272829303132333435import torchimport torchvisionfrom torch import nnfrom torch.nn import Conv2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64)# å»ºç«‹ç¥ç»ç½‘ç»œæ¨¡å‹class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() # åˆå§‹åŒ–nn.module self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) def forward(self,x): x = self.conv1(x) return xtudui = Tudui()writer = SummaryWriter(&quot;logs&quot;)step = 0# æ£€æµ‹æ¨¡å‹for data in dataloader: imgs, targets = data output = tudui(imgs) # print(imgs.shape) # print(output.shape) writer.add_images(&quot;input&quot;, imgs, step) # ä¸ºäº†èƒ½å¤Ÿç”¨tensorboardå±•ç¤ºè¿›è¡Œreshape,ä½†ä»…æ­¤è€Œå·² output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() æ± åŒ–å±‚ æ± åŒ–çš„ä½œç”¨æ˜¯å‡å°‘å‚æ•°é‡ï¼Œä¸‹é‡‡æ · æ± åŒ–å±‚çš„strideé»˜è®¤æ˜¯æ± åŒ–æ ¸çš„size ceil_modelä¸ºtrueè¡¨ç¤ºå½“è¾“å…¥å›¾ç‰‡ä¸è¶³æ± åŒ–æ ¸æ—¶ä»ç„¶è¿›è¡Œæ± åŒ–ï¼Œfalseè¡¨ç¤ºä¸è¿›è¡Œ 12345678910111213141516171819202122232425262728from torch import nnimport torchimport torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriter# æ„å»ºç¥ç»ç½‘ç»œclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.maxpool1 = nn.MaxPool2d(kernel_size=3,ceil_mode=True) def forward(self, input): output = self.maxpool1(input) return output# æ•°æ®é›†dataset = torchvision.datasets.CIFAR10(&quot;dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataloader = DataLoader(dataset, batch_size=64)# è¿è¡Œå¹¶å±•ç¤ºwriter = SummaryWriter(&quot;maxpool&quot;)tudui = Tudui()step = 0for data in dataloader: imgs, targets = data writer.add_images(&quot;imgs&quot;, imgs, step) output = tudui(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() éçº¿æ€§æ¿€æ´»å¼•å…¥éçº¿æ€§ç‰¹å¾ã€‚reluã€sigmoid å‚æ•° inplaceï¼šä¸€èˆ¬inplaceä¸ºfalseä¸è¦†ç›– 12345678910111213141516171819202122232425262728import torchfrom torch import nnimport torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.relu = nn.ReLU(inplace=False) def forward(self,input): output = self.relu(input) return outputdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset,batch_size=64)tudui = Tudui()writer = SummaryWriter(&quot;relu&quot;)step = 0for data in dataloader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, step) output = tudui(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() çº¿æ€§å±‚å’Œå…¶ä»–å±‚123456789101112131415161718192021import torchfrom torch import nnimport torchvisionfrom torch.utils.data import DataLoaderclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.linear = nn.Linear(196608,10) def forward(self, input): output = self.linear(input) return outputdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64, drop_last=True)tudui = Tudui()for data in dataloader: imgs, targets = data output = torch.flatten(imgs) output = tudui(output) print(output.shape) sequentialçš„ä½¿ç”¨ 123456789101112131415161718192021222324252627282930313233import torchfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xtudui = Tudui()print(tudui)input = torch.ones((64, 3, 32, 32))output = tudui(input)print(output.shape)writer = SummaryWriter(&quot;seq&quot;)writer.add_graph(tudui, input)writer.close() æŸå¤±å‡½æ•°ä¸åå‘ä¼ æ’­lossè®¡ç®—outputå’Œtargetä¹‹é—´çš„å·®è·ï¼Œlossè¶Šå°è¶Šå¥½ï¼Œlossä½œä¸ºåå‘ä¼ æ’­çš„ä¾æ® 12345678910111213141516171819202122232425262728293031323334353637383940import torchimport torchvisionfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64)# æŸå¤±å‡½æ•°loss = nn.CrossEntropyLoss()tudui = Tudui()for data in dataloader: imgs, targets = data output = tudui(imgs) result_loss = loss(output, targets) print(result_loss) input() ä¼˜åŒ–å™¨lrï¼šå­¦ä¹ é€Ÿç‡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import torchimport torchvisionfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return x# æ•°æ®é›†dataset= torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(), download=True)dataloader = DataLoader(dataset, batch_size=64)# lossã€æ¨¡å‹ã€ä¼˜åŒ–å™¨loss = nn.CrossEntropyLoss()tudui = Tudui()optim = torch.optim.SGD(tudui.parameters(), lr=0.01)# æ¨¡å‹è®­ç»ƒfor epoch in range(20): running_loss = 0.0 for data in dataloader: imgs, targets = data output = tudui(imgs) result_loss = loss(output, targets) optim.zero_grad() # å°†æ¢¯åº¦æ¸…é›¶ result_loss.backward() # è®¡ç®—æ–°çš„æ¢¯åº¦ optim.step() # æ ¹æ®æ¢¯åº¦æ›´æ–°å‚æ•° running_loss = running_loss + result_loss print(running_loss) ç°æœ‰æ¨¡å‹çš„ä¿®æ”¹ä¸ä½¿ç”¨123456789101112131415161718192021import torchvision# train_data = torchvision.datasets.ImageNet(&quot;../data_image_net&quot;, split=&#x27;train&#x27;, download=True,# transform=torchvision.transforms.ToTensor())from torch import nnvgg16_false = torchvision.models.vgg16(pretrained=False)vgg16_true = torchvision.models.vgg16(pretrained=True)print(vgg16_true)train_data = torchvision.datasets.CIFAR10(&#x27;../data&#x27;, train=True, transform=torchvision.transforms.ToTensor(), download=True)# åœ¨ç°æœ‰æ¨¡å‹åæ·»åŠ ä¸€å±‚ç½‘ç»œvgg16_true.classifier.add_module(&#x27;add_linear&#x27;, nn.Linear(1000, 10))print(vgg16_true)print(vgg16_false)# ä¿®æ”¹ç°æœ‰æ¨¡å‹æŸä¸€å±‚çš„å‚æ•°å€¼vgg16_false.classifier[6] = nn.Linear(4096, 10)print(vgg16_false) 11.å®Œæ•´è®­ç»ƒå¥—è·¯CPUï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoader# å‡†å¤‡æ•°æ®é›†train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# æ•°æ®é›†é•¿åº¦train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;è®­ç»ƒæ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(train_data_size))print(&quot;æµ‹è¯•æ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(test_data_size))# åˆ©ç”¨DataLoaderæ¥åŠ è½½æ•°æ®é›†train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# åˆ›å»ºç½‘ç»œæ¨¡å‹tudui = Tudui()# æŸå¤±å‡½æ•°loss_fn = nn.CrossEntropyLoss()# ä¼˜åŒ–å™¨learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# è®­ç»ƒç½‘ç»œçš„ä¸€äº›å‚æ•°# è®°å½•è®­ç»ƒæ¬¡æ•°total_train_step = 0# è®°å½•æµ‹è¯•æ¬¡æ•°total_test_step = 0# è®­ç»ƒçš„è½®æ•°epoch = 10# æ·»åŠ tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------ç¬¬&#123;&#125;è½®è®­ç»ƒå¼€å§‹--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data output = tudui(imgs) loss = loss_fn(output, targets) # è®¡ç®—loss optimizer.zero_grad() # æ¢¯åº¦æ¸…é›¶ loss.backward() # è®¡ç®—æ¢¯åº¦ optimizer.step() # è°ƒæ•´å‚æ•° total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;è®­ç»ƒæ¬¡æ•°: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # æµ‹è¯•æ­¥éª¤ tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„æ­£ç¡®ç‡: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;æ¨¡å‹å·²ä¿å­˜&quot;)writer.close() 12. åˆ©ç”¨GPUè®­ç»ƒæ–¹æ³•ä¸€ï¼šè°ƒç”¨ ç½‘ç»œæ¨¡å‹ã€æ•°æ®ï¼ˆè¾“å…¥ã€æ ‡æ³¨ï¼‰ã€æŸå¤±å‡½æ•°çš„ cudaæ–¹æ³• 12if torch.cuda.is_available(): # åˆ¤æ–­cudaæ˜¯å¦å¯ç”¨ xxx GPUç‰ˆï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoader# å‡†å¤‡æ•°æ®é›†train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# æ•°æ®é›†é•¿åº¦train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;è®­ç»ƒæ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(train_data_size))print(&quot;æµ‹è¯•æ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(test_data_size))# åˆ©ç”¨DataLoaderæ¥åŠ è½½æ•°æ®é›†train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# åˆ›å»ºç½‘ç»œæ¨¡å‹tudui = Tudui()if torch.cuda.is_available(): tudui = tudui.cuda() print(&quot;yes&quot;)# æŸå¤±å‡½æ•°loss_fn = nn.CrossEntropyLoss()if torch.cuda.is_available(): loss_fn = loss_fn.cuda()# ä¼˜åŒ–å™¨learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# è®­ç»ƒç½‘ç»œçš„ä¸€äº›å‚æ•°# è®°å½•è®­ç»ƒæ¬¡æ•°total_train_step = 0# è®°å½•æµ‹è¯•æ¬¡æ•°total_test_step = 0# è®­ç»ƒçš„è½®æ•°epoch = 10# æ·»åŠ tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------ç¬¬&#123;&#125;è½®è®­ç»ƒå¼€å§‹--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data if torch.cuda.is_available(): targets = targets.cuda() imgs = imgs.cuda() output = tudui(imgs) loss = loss_fn(output, targets) # è®¡ç®—loss optimizer.zero_grad() # æ¢¯åº¦æ¸…é›¶ loss.backward() # è®¡ç®—æ¢¯åº¦ optimizer.step() # è°ƒæ•´å‚æ•° total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;è®­ç»ƒæ¬¡æ•°: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # æµ‹è¯•æ­¥éª¤ tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data if torch.cuda.is_available(): targets = targets.cuda() imgs = imgs.cuda() outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„æ­£ç¡®ç‡: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;æ¨¡å‹å·²ä¿å­˜&quot;)writer.close() æ–¹æ³•äºŒï¼š é¦–å…ˆåˆ›å»ºdeviceï¼Œç„¶åè°ƒç”¨ ç½‘ç»œæ¨¡å‹ã€æ•°æ®ï¼ˆè¾“å…¥ã€æ ‡æ³¨ï¼‰ã€æŸå¤±å‡½æ•° çš„toæ–¹æ³• 123torch.device(&quot;cuda&quot;)torch.device(&quot;cpu&quot;)device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) GPUç‰ˆï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoaderdevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)# å‡†å¤‡æ•°æ®é›†train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# æ•°æ®é›†é•¿åº¦train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;è®­ç»ƒæ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(train_data_size))print(&quot;æµ‹è¯•æ•°æ®é›†çš„é•¿åº¦ä¸º:&#123;&#125;&quot;.format(test_data_size))# åˆ©ç”¨DataLoaderæ¥åŠ è½½æ•°æ®é›†train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# åˆ›å»ºç½‘ç»œæ¨¡å‹tudui = Tudui()tudui = tudui.to(device)# æŸå¤±å‡½æ•°loss_fn = nn.CrossEntropyLoss()loss_fn = loss_fn.to(device)# ä¼˜åŒ–å™¨learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# è®­ç»ƒç½‘ç»œçš„ä¸€äº›å‚æ•°# è®°å½•è®­ç»ƒæ¬¡æ•°total_train_step = 0# è®°å½•æµ‹è¯•æ¬¡æ•°total_test_step = 0# è®­ç»ƒçš„è½®æ•°epoch = 10# æ·»åŠ tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------ç¬¬&#123;&#125;è½®è®­ç»ƒå¼€å§‹--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data targets = targets.to(device) imgs = imgs.to(device) output = tudui(imgs) loss = loss_fn(output, targets) # è®¡ç®—loss optimizer.zero_grad() # æ¢¯åº¦æ¸…é›¶ loss.backward() # è®¡ç®—æ¢¯åº¦ optimizer.step() # è°ƒæ•´å‚æ•° total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;è®­ç»ƒæ¬¡æ•°: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # æµ‹è¯•æ­¥éª¤ tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data targets = targets.to(device) imgs = imgs.to(device) outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;æ•´ä½“æµ‹è¯•é›†ä¸Šçš„æ­£ç¡®ç‡: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;æ¨¡å‹å·²ä¿å­˜&quot;)writer.close() 13.æ¨¡å‹éªŒè¯123456tudui = torch.load(&quot;tudui_9.pth&quot;, map_location=torch.device(&#x27;cpu&#x27;)) # å¦‚æœä½¿ç”¨GPUè®­ç»ƒçš„æ¨¡å‹ï¼Œä½¿ç”¨map_locationæ˜ å°„åˆ°cpuä¸Š...# æµ‹è¯•ä¹‹å‰ï¼študui.eval()with torch.no_grad(): test.py 1234567891011121314151617181920212223242526import torchimport torchvisionfrom PIL import Imagefrom torch import nnfrom model import *image_path = &quot;dataset/dog.jpg&quot;image = Image.open(image_path)print(image)image = image.convert(&#x27;RGB&#x27;)transform = torchvision.transforms.Compose([torchvision.transforms.Resize((32,32)), torchvision.transforms.ToTensor()])image = transform(image)print(image)tudui = torch.load(&quot;tudui_9.pth&quot;, map_location=torch.device(&#x27;cpu&#x27;))print(tudui)image = torch.reshape(image, (1, 3, 32, 32))tudui.eval()with torch.no_grad(): output = tudui(image)print(output)print(output.argmax(1)) pytorchå…¥é—¨éƒ¨åˆ† å®Œç»“æ’’èŠ±ğŸ˜Š","categories":[],"tags":[{"name":"DL","slug":"DL","permalink":"https://leungto.github.io/tags/DL/"}]},{"title":"å›æº¯æ³•é¢˜è§£","slug":"å›æº¯æ³•é¢˜è§£","date":"2023-01-02T09:36:20.000Z","updated":"2023-01-08T12:52:52.385Z","comments":true,"path":"2023/01/02/å›æº¯æ³•é¢˜è§£/","link":"","permalink":"https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/","excerpt":"ã€Šç®—æ³•è®¾è®¡ä¸åˆ†æã€‹ä¸€ä¹¦ä¸­å›æº¯æ³•ä¹ é¢˜æ±‚è§£","text":"ã€Šç®—æ³•è®¾è®¡ä¸åˆ†æã€‹ä¸€ä¹¦ä¸­å›æº¯æ³•ä¹ é¢˜æ±‚è§£ ä¹¦å†™ç»“æ„ï¼šè§£ç©ºé—´å’Œè§£ç»“æ„ï¼Œå‰ªæç­–ç•¥ï¼Œç¤ºä¾‹ï¼Œä»£ç ï¼Œæ—¶é—´å¤æ‚åº¦åˆ†æ 5-1å­é›†å’Œé—®é¢˜ 1. è§£ç©ºé—´å’Œè§£ç»“æ„ç±»ä¼¼äº0-1èƒŒåŒ…é—®é¢˜ï¼Œå¯¹äºSå¤§å°ä¸ºnçš„å­é›†å’Œé—®é¢˜ï¼Œè§£ç©ºé—´æ˜¯ç”±é•¿åº¦ä¸ºnçš„0-1å‘é‡ç»„æˆï¼Œè§£çš„ç»“æ„ä¸ºå­é›†æ ‘ï¼Œå¦‚å¯¹äºä¸Šè¿°ç¤ºä¾‹çš„è§£ï¼Œè§£ç©ºé—´å³ä¸º(1,1,1,0,0,0) 2. å‰ªæç­–ç•¥æ³¨æ„åˆ°é¢˜ç›®è¯´Sæ˜¯æ­£æ•´æ•°çš„é›†åˆï¼Œcæ˜¯æ­£æ•´æ•°ï¼Œæ•…æ·±æœçš„è¿‡ç¨‹ä¸€å®šä½¿å¾—å­é›†å’Œå¢åŠ æˆ–ä¸å˜ã€‚ è€ƒè™‘åœ¨æŸèŠ‚ç‚¹å¤„å‘ä¸‹æœç´¢çš„è¿‡ç¨‹ï¼Œè®¾å½“å‰å±‚æ•°ä¸ºkï¼ˆå³å½“å‰è€ƒè™‘æ˜¯å¦åŠ å…¥æ•°S[k]åˆ°å­é›†ä¸­ï¼‰ çº¦æŸå‡½æ•°ï¼šç»´æŠ¤å˜é‡cwè¡¨ç¤ºå½“å‰å­é›†å’Œï¼Œè‹¥cw+S[k]&gt;cï¼Œåˆ™å‰ªå»å·¦å­æ ‘ é™ç•Œå‡½æ•°ï¼šè®¡ç®—å˜é‡rwè¡¨ç¤ºå‰©ä½™çš„æ•´æ•°ä¹‹å’Œ(S[k+1:n-1]ä¹‹å’Œ)ï¼Œè‹¥cw+rw&lt;cï¼Œå³å°†ä¹‹åæ‰€æœ‰æ•´æ•°åŠ å…¥å­é›†ä¹Ÿæ— æ³•å¾—åˆ°è§£ï¼Œæ•…å‡å»å³å­æ ‘ å¯¹äºæœ¬é¢˜è€Œè¨€ï¼Œå¦‚æœåªè¦ä¸€ä¸ªå¯è¡Œè§£çš„è¯ï¼Œå¯ä»¥åœ¨æœç´¢æ¯ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ï¼Œåœ¨è€ƒè™‘å®Œæ˜¯å¦åŠ å…¥æ•°S[k]ä¹‹åï¼Œåˆ¤æ–­S[k]æ˜¯å¦ç­‰äºcï¼Œè‹¥ç­‰äºï¼Œåˆ™æ— éœ€å†æœç´¢äº† 3. ç¤ºä¾‹å¤ªå¤šäº†ä¸å¤ªå¥½ç”»ï¼Œå‡å°‘ç‚¹æ•°æ®é‡ï¼š 123 102 2 6 4. ä»£ç è¿™é‡Œå°±æ²¡å¼„æ–‡ä»¶è¯»å†™äº†ï¼ˆå¯ä»¥ç›´æ¥ç²˜è´´ä¸‹é¢çš„è¾“å…¥æµ‹è¯•å•¦ï¼‰ è¾“å…¥1ï¼š 125 102 2 6 5 4 è¾“å…¥2ï¼š 125 102 11 12 5 4 å¾—åˆ°ä¸€ä¸ªè§£ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;const int N=100010;int S[N],res[N];int n,c;int num=0;//è§£çš„æ•°é‡void dispsolution(int res[])&#123; cout&lt;&lt;&quot;ç¬¬&quot;&lt;&lt;num++&lt;&lt;&quot;ä¸ªè§£&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void dfs(int cw,int rw,int res[],int level)&#123; if(level&gt;n)//åˆ°è¾¾å¶èŠ‚ç‚¹äº† &#123; if(cw==c)//æ‰¾åˆ°å¯è¡Œè§£ &#123; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; exit(0);//ç›´æ¥ç»“æŸç¨‹åº(ä¼šä¸ä¼šæœ‰ç‚¹æš´åŠ›) &#125; &#125;else&#123; if(cw+S[level]&lt;=c)//è€ƒè™‘æ˜¯å¦è¿›å…¥å·¦å­æ ‘ &#123; res[level]=1; dfs(cw+S[level],rw-S[level],res,level+1); &#125; rw=rw-S[level];//è®¡ç®—å‰©ä½™æ•´æ•°ä¹‹å’Œ(å‰©ä½™æ•´æ•°ä¸åŒ…æ‹¬å½“å‰æ•´æ•°) //è¿™é‡Œå’Œåšå®¢ä¸å¤ªä¸€æ ·(ä»–rwç®—çš„æ˜¯åŒ…æ‹¬å½“å‰çš„æ•´æ•°çš„) if(cw+rw&gt;=c)//è€ƒè™‘æ˜¯å¦è¿›å…¥å³å­æ ‘ &#123; res[level]=0; dfs(cw,rw,res,level+1); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; int rw=0;//ä¸ºäº†æ–¹ä¾¿è®¡ç®—rw,é¦–å…ˆè®¡ç®—æ‰€æœ‰æ•´æ•°çš„å’Œ for(int i=1;i&lt;=n;i++)//ä¸ºäº†æ–¹ä¾¿,ä»ä¸‹æ ‡1å¼€å§‹ &#123; cin&gt;&gt;S[i]; rw=rw+S[i]; &#125; dfs(0,rw,res,1);//cw=1,reså­˜å‚¨è§£,ä»ç¬¬ä¸€å±‚å¼€å§‹ if(num==0) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; å¾—åˆ°æ‰€æœ‰è§£ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;const int N=100010;int S[N],res[N];int n,c;int num=0;//è§£çš„æ•°é‡void dispsolution(int res[])&#123; cout&lt;&lt;&quot;ç¬¬&quot;&lt;&lt;num++&lt;&lt;&quot;ä¸ªè§£&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void dfs(int cw,int rw,int res[],int level)&#123; if(level&gt;n)//åˆ°è¾¾å¶èŠ‚ç‚¹äº† &#123; if(cw==c) dispsolution(res);//æ‰¾åˆ°å¯è¡Œè§£ &#125;else&#123; if(cw+S[level]&lt;=c)//è€ƒè™‘æ˜¯å¦è¿›å…¥å·¦å­æ ‘ &#123; res[level]=1; dfs(cw+S[level],rw-S[level],res,level+1); &#125; rw=rw-S[level];//è®¡ç®—å‰©ä½™æ•´æ•°ä¹‹å’Œ(å‰©ä½™æ•´æ•°ä¸åŒ…æ‹¬å½“å‰æ•´æ•°) //è¿™é‡Œå’Œåšå®¢ä¸å¤ªä¸€æ ·(ä»–rwç®—çš„æ˜¯åŒ…æ‹¬å½“å‰çš„æ•´æ•°çš„) if(cw+rw&gt;=c)//è€ƒè™‘æ˜¯å¦è¿›å…¥å³å­æ ‘ &#123; res[level]=0; dfs(cw,rw,res,level+1); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; int rw=0;//ä¸ºäº†æ–¹ä¾¿è®¡ç®—rw,é¦–å…ˆè®¡ç®—æ‰€æœ‰æ•´æ•°çš„å’Œ for(int i=1;i&lt;=n;i++)//ä¸ºäº†æ–¹ä¾¿,ä»ä¸‹æ ‡1å¼€å§‹ &#123; cin&gt;&gt;S[i]; rw=rw+S[i]; &#125; dfs(0,rw,res,1);//cw=1,reså­˜å‚¨è§£,ä»ç¬¬ä¸€å±‚å¼€å§‹ if(num==0) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦åˆ†æè€ƒè™‘æœ€åæƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½è¿›è¡Œæœç´¢ï¼Œå¤„ç†æ¯ä¸ªèŠ‚ç‚¹æ‰€éœ€çš„æ—¶é—´å‡ä¸º$O(1)$ï¼Œä¸€å…±æœ‰1+2+4+8+â€¦+2^n^ =$O(2^{n+1})$ä¸ªèŠ‚ç‚¹ï¼Œæ•…æ—¶é—´å¤æ‚åº¦ä¸º$O(2^{n+1})$ å‚è€ƒï¼šhttps://blog.csdn.net/gl620321/article/details/108801724 5-2 æœ€å°é•¿åº¦ç”µè·¯æ¿æ’åˆ—é—®é¢˜ 1. è§£ç©ºé—´å’Œè§£ç»“æ„ç±»ä¼¼äºæ—…è¡Œå•†é—®é¢˜ï¼Œå¯¹äºnä¸ªç”µè·¯æ¿çš„æœ€å°ç”µè·¯æ¿æ’åˆ—é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºnä¸ªæ•°çš„å…¨æ’åˆ—ï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥ç»´æŠ¤å˜é‡bestdè¡¨ç¤ºå½“å‰çš„æœ€å°é•¿åº¦ï¼Œå‡è®¾æ­¤æ—¶é€‰æ‹©ç¬¬iä¸ªä½ç½®ä¸Šçš„ç”µè·¯æ¿ï¼Œè€ƒè™‘é€‰æ‹©ç¬¬jä¸ªç”µè·¯æ¿(j&gt;=iï¼Œå› ä¸ºiå‰é¢çš„å·²ç»é€‰æ‹©å¥½äº†)ä½œä¸ºè¯¥ä½ç½®ä¸Šçš„æ’åˆ—ï¼Œæ­¤æ—¶åˆ©ç”¨å·²ç»é€‰æ‹©å¥½çš„ç¬¬1~ç¬¬iä¸ªä½ç½®ä¸Šçš„ç”µè·¯æ¿ï¼ˆç¬¬iä¸ªä½ç½®åˆšåˆšé€‰æ‹©å¥½çš„ï¼‰æ¥è®¡ç®—è¿æ¥å—çš„æœ€å¤§é•¿åº¦ï¼Œè‹¥è¯¥é•¿åº¦å°äºå½“å‰æœ€ä¼˜è§£ï¼Œåˆ™ç»§ç»­è¿›è¡Œä¸‹é¢ä½ç½®çš„é€‰æ‹©ï¼Œå¦åˆ™ç¬¬iä¸ªä½ç½®ä¸Šä¸èƒ½é€‰æ‹©ç¬¬jä¸ªç”µè·¯æ¿ï¼Œå‰ªå»è¯¥å­æ ‘ 3. ç¤ºä¾‹ç¤ºä¾‹æ•°æ®é‡å¤ªå¤§ï¼Œå‡å°‘ç‚¹ 123454 41 1 1 11 1 0 10 0 0 10 1 1 0 4ä¸ªç”µè·¯æ¿ï¼ŒL1={1,2},L2={1,2,4},L3={1,4},L4={1,2,3} ç±»ä¼¼äºä¸‹é¢çš„ç”»æ³•ï¼ˆæ’åˆ—æ ‘å¤ªå¤šäº†ï¼Œåªç”»äº†ä¸€ä¸ªå­æ ‘ï¼‰ï¼š æœ€åçš„ç»“æœï¼š 4. ä»£ç è¾“å…¥æ–‡ä»¶ input.txt: 1234567898 51 1 1 1 10 1 0 1 00 1 1 1 01 0 1 1 01 0 1 0 01 1 0 1 00 0 0 0 10 1 0 0 1 è¾“å…¥å«ä¹‰ L1={1,4,5,6},L2={1,2,3,6,8},L3={1,3,4,5},L4={1,2,3,4,6},L5={1,7,8} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include&lt;fstream&gt;#include &lt;vector&gt;using namespace std;int n, m;int bestx[10];// è¿™æ˜¯æœ€ç»ˆçš„æœ€ä¼˜è§£æ’åˆ—é¡ºåºint B[10][10];//ç”µè·¯æ¿åœ¨è¿æ¥å—ä¸­çš„æ’åˆ—ï¼Œæ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„int x[10], low[10], high[10];// åˆ†åˆ«æ˜¯å½“å‰çš„æ’åˆ—ã€æœ€å·¦è¾¹ç”µè·¯æ¿ã€æœ€å³è¾¹ç”µè·¯æ¿int bestd=0;// æœ€ä¼˜è§£int len(int ii) &#123;// è®¡ç®—å½“å‰iiæ’åˆ—æœ€å°é•¿åº¦ for (int i = 1; i &lt;= m; i++) &#123; high[i] = 0; low[i] = n + 1;// å…ˆåˆå§‹åŒ–æœ€å·¦è¾¹å’Œæœ€å³è¾¹çš„å€¼ï¼Œ &#125; for (int i = 1; i &lt;= ii; i++)// å¯¹äºç¬¬iè¡Œ for (int k = 1; k &lt;= m; k++)// kåˆ— if (B[x[i]][k] &gt; 0) &#123;// å¦‚æœç¬¬iä¸ªç”µè·¯æ¿åœ¨ç¬¬kä¸ªè¿æ¥å—ä¸­ï¼Œ if (i &lt; low[k])//low[k]ä»£è¡¨ç¬¬Kä¸ªè¿æ¥å—çš„æœ€å·¦è¾¹çš„å€¼ï¼Œå¦‚æœiæ¯”å®ƒå°ï¼Œåˆ™æ›´æ–°å·¦å€¼ low[k] = i; if (i &gt; high[k]) high[k] = i;//å¦‚æœæ¯”åˆå§‹çš„å³å€¼å¤§ï¼Œåˆ™æ›´æ–°å³å€¼ &#125; int tmp = 0; for (int k = 1; k &lt;= m; k++) if (low[k] &lt;= n &amp;&amp; high[k] &gt; 0 &amp;&amp; tmp &lt; high[k] - low[k]) //è‹¥è¿æ¥å—çš„é•¿åº¦æ— æ³•å¾—åˆ°ï¼ˆå‰é¢ä¸¤ä¸ªboolè¡¨è¾¾å¼ä¸æ»¡è¶³ï¼Œä¸è®¡ç®—è¯¥è¿æ¥å—çš„é•¿åº¦ï¼‰ tmp = high[k] - low[k];//è®¡ç®—æ¯ä¸ªè¿æ¥å—çš„ä¸¾ä¾‹ return tmp;&#125;void swap(int* x, int i, int j) &#123;// äº¤æ¢iå’Œjä½ç½®çš„å€¼ int tmp; tmp = x[i]; x[i] = x[j]; x[j] = tmp;&#125;void backtrack(int i) &#123; if (i == n) &#123;// å¦‚æœåˆ°è¾¾æœ«å°¾ int tmp = len(i);// è®¡ç®—å½“å‰æ’åˆ—æœ€å°é•¿åº¦ if (tmp &lt; bestd) &#123; bestd = tmp; for (int j = 1; j &lt;= n; j++) bestx[j] = x[j]; &#125; // å¦‚æœæ¯”æœ€ä¼˜è§£è¿˜è¦å¥½ï¼Œåˆ™æ›´æ–°bestx[]æ’åˆ—ï¼› &#125; else &#123;// è‹¥ä¸æ˜¯æœ«å°¾ï¼› for (int j = i; j &lt;= n; j++) &#123; swap(x, i, j); int ld = len(i); if (ld &lt; bestd) backtrack(i + 1);// åˆ™ç»§ç»­è¿›å…¥ä¸‹ä¸€ä¸ªæ•°ï¼Œ swap(x, i, j); &#125; &#125;&#125;int arrangeBoards() &#123; bestd = n + 1;// å…ˆå‡è®¾ä¸€ä¸ªå¾ˆå¤§çš„å€¼ for (int i = 1; i &lt;= n; i++) x[i] = i;// è¿™é‡Œæ˜¯æœ€å¼€å§‹çš„æ’åºï¼› backtrack(1); return bestd;&#125;int main(void) &#123; ifstream ifs(&quot;input.txt&quot;);//æ–‡ä»¶è¾“å…¥æµ ifs&gt;&gt;n; ifs&gt;&gt;m; vector&lt;int&gt; temp(m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; ifs&gt;&gt;B[i][j] ;// è¾“å…¥çš„ç”µè·¯æ¿çš„äºŒç»´æ•°ç»„æ’åˆ— &#125; &#125; int minLen = arrangeBoards(); cout&lt;&lt;minLen&lt;&lt;endl; for (int i = 1; i &lt;= n; i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; ifs.close(); return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦åˆ†æå¯¹äºæœ€åæƒ…å†µï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½éœ€è¦è®¡ç®—ä¸€æ¬¡lenï¼Œå³åºå·è¿è¡Œlenå‡½æ•°ï¼Œè€Œç¬¬iå±‚èŠ‚ç‚¹è¿è¡Œlenå‡½æ•°æ—¶é—´å¤æ‚åº¦ä¸º$O(im)$ï¼Œæ•…æœ€åæƒ…å†µä¸‹æ‰€éœ€æ—¶é—´ä¸º$T=O(m)(n-1)+O(2m)(n-1)(n-2)+â€¦+O(nm)(n-1)!$ï¼Œæ•…æœ€åæƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ä¸º$O(mn!)$ 5-3 æœ€å°é‡é‡æœºå™¨è®¾è®¡é—®é¢˜ é¢˜ç›®ä¸¤ä¸ªè¦æ±‚ï¼Œæ€»ä»·æ ¼ä¸è¶…è¿‡dï¼Œå¹¶ä¸”éƒ¨ä»¶é‡é‡ä¹‹å’Œè¦æœ€å° 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªéƒ¨ä»¶ï¼Œmä¸ªä¾›åº”å•†çš„æœ€å°é‡é‡æœºå™¨è®¾è®¡é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºé•¿åº¦ä¸ºnçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹ä¸º1~mçš„æ•´æ•°ï¼Œå¯¹åº”çš„è§£ç»“æ„ä¸ºæ’åˆ—æ ‘ï¼ˆä¹Ÿä¸æ˜¯é‚£ç§TSPçš„æ’åˆ—æ ‘ï¼Œä¸è¿‡ä¹Ÿæ˜¯æ’åˆ—å•¦ï¼Œå§‘ä¸”ç§°ä¹‹ä¸ºæ’åˆ—æ ‘ï¼‰ 2. å‰ªæç­–ç•¥è€ƒè™‘ç¬¬iä¸ªéƒ¨ä»¶ä¾›åº”å•†çš„é€‰æ‹© çº¦æŸå‡½æ•°ï¼šç»´æŠ¤å˜é‡cpè¡¨ç¤ºå½“å‰å·²ç»è´­å¾—çš„éƒ¨ä»¶çš„ä»·æ ¼ä¹‹å’Œï¼Œå‡è®¾è€ƒè™‘é€‰æ‹©ç¬¬jä¸ªä¾›åº”å•†ï¼Œè‹¥cp+c[i][j]&gt;dï¼Œåˆ™å‰ªå»ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ï¼Œæ— éœ€å†è¿›è¡Œæœç´¢ é™ç•Œå‡½æ•°ï¼šç»´æŠ¤å˜é‡cwè¡¨ç¤ºå½“å‰å·²ç»è´­å¾—çš„éƒ¨ä»¶çš„é‡é‡ä¹‹å’Œï¼Œå˜é‡bestwè¡¨ç¤ºå½“å‰æœ€ä¼˜è§£çš„é‡é‡ä¹‹å’Œï¼Œå‡è®¾è€ƒè™‘é€‰æ‹©ç¬¬jä¸ªä¾›åº”å•†ï¼Œè‹¥cw+w[i][j]&gt;=bestwï¼Œåˆ™å‰ªå»è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ï¼Œæ— éœ€è¿›è¡Œæœç´¢ 3. ç¤ºä¾‹å¯¹äºé¢˜ä¸­ç¤ºä¾‹ç”»æ ‘ï¼š 4. ä»£ç è¾“å…¥ï¼š 12345673 3 41 2 33 2 12 2 21 2 33 2 12 2 2 æ²¡å®ç°æ–‡ä»¶è¯»å†™äº†~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,d;//nä¸ªéƒ¨ä»¶ï¼Œmä¸ªä¾›åº”å•†ï¼Œæ€»ä»·æ ¼ä¸è¶…è¿‡dint c[999][999];//c[i][j]ä¸ºä»ä¾›åº”å•†jè´­ä¹°éƒ¨ä»¶iæ‰€èŠ±è´¹çš„ä»·æ ¼ï¼›int w[999][999];//w[i][j]ä¸º......é‡é‡int cw=0,cp=0;//å½“å‰éƒ¨ä»¶çš„é‡é‡ ä»·æ ¼int bestw=999,bestp=999;//æœ€ä¼˜æ–¹æ¡ˆçš„é‡é‡ï¼Œä»·æ ¼int x[999];//å½“å‰éƒ¨ä»¶iä»ä¾›åº”å•†jè´­ä¹°int bestx[999];//æœ€ä¼˜æ–¹æ¡ˆéƒ¨ä»¶iä»å“ªä¸ªä¾›åº”å•†ä¹°void backtrack(int i)&#123; if(i&gt;=n)&#123;//åˆ°è¾¾æœ€åä¸€å±‚ if(cp&lt;=d&amp;&amp;cw&lt;bestw)&#123;//å¦‚æœä»·æ ¼æ²¡è¶…è¿‡dï¼Œå¹¶ä¸”é‡é‡å°äºä¹‹å‰æ–¹æ¡ˆçš„bestw bestw=cw;//é‡é‡æ›´æ–° bestp=cp;//ä»·æ ¼æ›´æ–° for(int k=0;k&lt;n;k++)&#123; bestx[k]=x[k];//éƒ¨ä»¶çš„ä¾›åº”å•†è¿›è¡Œæ›´æ–° &#125; &#125; &#125; else&#123; //æ‰€æœ‰çš„æ–¹å¼éƒ½å°è¯•äº†ä¸€éï¼Œæ¯”è¾ƒæ‰¾åˆ°æœ€ä¼˜çš„é‡é‡ for(int j=0;j&lt;m;j++)&#123; x[i]=j;//å½“å‰éƒ¨ä»¶içš„ä¾›åº”å•†ä¸ºj cw=cw+w[i][j]; cp=cp+c[i][j]; if(cw&lt;bestw&amp;&amp;cp&lt;=d)//å¦‚æœè¿™æ¬¡çš„é€‰æ‹©è¦æ¯”ä¹‹å‰æ–¹æ¡ˆçš„æ›´ä¼˜ backtrack(i+1); //å›æº¯ cw-=w[i][j]; cp-=c[i][j]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;//nä¸ªéƒ¨ä»¶ï¼Œmä¸ªä¾›åº”å•†ï¼Œæ€»ä»·æ ¼ä¸è¶…è¿‡d int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;c[i][j];//c[i][j]ä¸ºä»ä¾›åº”å•†jè´­ä¹°éƒ¨ä»¶iæ‰€èŠ±è´¹çš„ä»·æ ¼ï¼› &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;w[i][j];//w[i][j]ä¸º......é‡é‡ &#125; &#125; backtrack(0);//ç¬¬iä¸ªéƒ¨ä»¶ cout&lt;&lt;bestw&lt;&lt;endl;//æœ€ä¼˜æ–¹æ¡ˆçš„é‡é‡ for(int k=0;k&lt;n;k++) cout&lt;&lt;bestx[k]+1&lt;&lt;&quot; &quot;; //å› ä¸ºjä»0å¼€å§‹ï¼Œæ‰€ä»¥è¾“å‡ºçš„æ—¶å€™åŠ ä¸€ä¸ª1ï¼›&#125; 5. æ—¶é—´å¤æ‚åº¦åˆ†æè€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºæ¯ä¸ªéå¶å­èŠ‚ç‚¹ï¼Œæœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(m)$ï¼Œå¯¹äºæ¯ä¸ªå¶å­èŠ‚ç‚¹ï¼Œæœç´¢æ‰€éœ€çš„æ—¶é—´ä¸º$O(1)$ï¼Œæ•…æœ€åæƒ…å†µä¸‹æ‰€éœ€æ—¶é—´ä¸º$T=m*(m+m^2+â€¦+m^{n-1})+m^n=O(m^n)$ 5-4 è¿åŠ¨å‘˜æœ€ä½³é…å¯¹é—®é¢˜ è¾“å…¥ï¼š 1234567310 2 32 3 43 4 52 2 23 5 34 5 1 è¾“å‡ºï¼š 152 1. è§£ç©ºé—´å’Œè§£ç»“æ„å°†é—®é¢˜è½¬æ¢ä¸ºç”·è¿åŠ¨å‘˜é€‰å¥³è¿åŠ¨å‘˜çš„é—®é¢˜ï¼Œæ•…nä¸ªç”·ã€å¥³è¿åŠ¨å‘˜çš„è¿åŠ¨å‘˜æœ€ä½³åŒ¹é…é—®é¢˜çš„è§£ç©ºé—´ä¸ºnä¸ªæ•°çš„å…¨æ’åˆ—ï¼Œå¯¹åº”çš„è§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥è€ƒè™‘å¯¹ç¬¬iä¸ªç”·è¿åŠ¨å‘˜åŒ¹é…å¥³è¿åŠ¨å‘˜çš„æƒ…å†µï¼Œå…¶ä¸­å˜é‡Maxå­˜å‚¨å½“å‰æœ€ä¼˜è§£çš„ç«èµ›ä¼˜åŠ¿ï¼Œå˜é‡sumå­˜å‚¨ç¬¬1~i-1ä¸ªå·²ç»åŒ¹é…å®Œæˆçš„ç”·è¿åŠ¨å‘˜çš„ç«èµ›ä¼˜åŠ¿ï¼Œè®¡ç®—ç¬¬i~nä¸ªç”·è¿åŠ¨å‘˜çš„æœ€å¤§å¯èƒ½çš„ç«èµ›ä¼˜åŠ¿ctnï¼Œè‹¥cnt+sum&lt;Maxï¼Œåˆ™å‰ªå»è¯¥èŠ‚ç‚¹åŠå…¶å­æ ‘ å…¶ä¸­ç¬¬jä¸ªç”·è¿åŠ¨å‘˜çš„æœ€å¤§å¯èƒ½çš„ç«èµ›ä¼˜åŠ¿ä¸ºè¯¥ç”·è¿åŠ¨å‘˜ä¸æ‰€æœ‰å¥³è¿åŠ¨å‘˜è¿›è¡ŒåŒ¹é…æ‰€å¾—ç«èµ›ä¼˜åŠ¿ä¸­æœ€å¤§è€…ï¼Œå­˜å‚¨åˆ°maxsumæ•°ç»„ä¸­ 3.ç¤ºä¾‹ 4.ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int n;int boy[21][21],girl[21][21]; //åˆ†åˆ«ç”¨äºå­˜æ”¾ç”·ã€å¥³è¿åŠ¨å‘˜çš„ç«èµ›ä¼˜åŠ¿int Max=INT_MIN; //Maxä»£è¡¨ç”·å¥³åŒæ–¹ç«èµ›ä¼˜åŠ¿çš„æ€»å’Œçš„æœ€å¤§å€¼int sum=0; //sumä¸ºä¸´æ—¶æ±‚å’Œint data[21][21]; //data[i][]ç”¨äºå­˜æ”¾ç”·è¿åŠ¨å‘˜ i é…å¯¹åçš„åŒæ–¹ç«èµ›ä¼˜åŠ¿int maxSum[21]; //è®°å½•æ¯ä¸ªç”·ç”ŸåŒ¹é…åå¯è¾¾åˆ°çš„æœ€å¤§åŒæ–¹ç«èµ›ä¼˜åŠ¿int book[21]; //ç”¨äºæ ‡è®°å¥³è¿åŠ¨å‘˜æ˜¯å¦å·²åŒ¹é…ï¼šbook[0]æœªåŒ¹é…ï¼›book[1]åŒ¹é…void dfs(int t)&#123; if(t&gt;=n) //tåˆ°è¾¾nä¹‹åï¼Œä»£è¡¨å…¨éƒ¨æ ‡è®°è®¿é—®äº†,å¾—åˆ°äº†æœ€å¤§å€¼ &#123; Max=max(Max,sum); return ; &#125; int ctn=0; //å‰ªæå‡½æ•°:ä¹‹å‰tä¸ªå·²åŒ¹é…å¥½çš„ç”·å¥³è¿åŠ¨å‘˜çš„sumä¸ä¹‹åçš„ t-&gt;n-1 ä¸ªç”·åŒ¹é…å¥³çš„æœ€å¤§å€¼åŠ èµ·æ¥ä¸å·²ç»å¾—åˆ°çš„Maxæ¯”è¾ƒï¼Œè‹¥å‰è€…&lt;=Maxï¼Œå‰ªæ for(int i=t;i&lt;n;i++) //æ±‚tåŠtä¹‹åç”·ç”ŸåŒ¹é…å¥³ç”Ÿçš„æœ€å¤§å€¼çš„å’Œ ctn+=maxSum[i];//è‹¥ä»ç¬¬tç»„-&gt;ç¬¬nç»„ï¼Œå½“å‰æœç´¢sumåŠ ä¸Šå‡è®¾åŒ¹é…åçš„æœ€å¤§å€¼cxnï¼Œä»ç„¶å°äºMax ï¼Œå°±éœ€è¦å‰ªæäº†ï¼Œåˆ™Maxä¸ºå·²ç»æ±‚å¾—çš„æœ€å¤§å€¼ if(sum+ctn&lt;Max) return ; for(int i=0;i&lt;n;i++) //è‹¥cxn&gt;=Maxï¼Œè¦æ¢ç´¢å­æ ‘ã€‚ä»ç¬¬tä¸ªç”·ç”Ÿå¼€å§‹åŒ¹é…ï¼Œæ‰¾æœªåŒ¹é…çš„å¥³ç”Ÿ &#123; if(!book[i]) //ç¬¬ i ä¸ªå¥³ç”ŸæœªåŒ¹é… &#123; book[i]=1; //ç¬¬ t ä¸ªç”·ç”ŸåŒ¹é…å¥³ç”Ÿi sum+=data[t][i]; //åŠ ä¸Šç”·ç”Ÿtä¸å¥³ç”Ÿiçš„ç”·å¥³åŒæ–¹ç«èµ›ä¼˜åŠ¿ dfs(t+1); //ä¸ºç¬¬i+1ä¸ªç”·ç”ŸåŒ¹é… book[i]=0; //è‹¥ç¬¬ t ä¸ªç”·ç”ŸåŒ¹é…å¥³ç”Ÿiå¾—åˆ°çš„sumä¸å¤§äºMaxï¼Œåˆ™å›æº¯ sum-=data[t][i]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) //è¾“å…¥ç”·è¿åŠ¨å‘˜çš„ç«èµ›ä¼˜åŠ¿ &#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;boy[i][j]; &#125; for(int i=0;i&lt;n;i++) //è¾“å…¥å¥³è¿åŠ¨å‘˜çš„ç«èµ›ä¼˜åŠ¿ &#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;girl[i][j]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; //å¯¹æ¯ä¸ªç”·ç”Ÿéƒ½æ±‚ç”·å¥³åŒæ–¹ç«èµ›ä¼˜åŠ¿ï¼Œåˆ™èƒ½å¾—åˆ°i*jç§ç»“æœï¼ˆæ¶µç›–äº†P[i][j]*Q[j][i]ä¸Q[i][j]*P[j][i]ï¼‰ data[i][j]=boy[i][j]*girl[j][i]; maxSum[i]=max(maxSum[i],data[i][j]); //è®°å½•æ¯ä¸ªç”·ç”ŸåŒ¹é…åå¯è¾¾åˆ°çš„æœ€å¤§åŒæ–¹ç«èµ›ä¼˜åŠ¿ï¼Œç”¨äºåé¢çš„å‰ªæ &#125; &#125; dfs(0); cout&lt;&lt;Max&lt;&lt;endl; return 0;&#125; 5.æ—¶é—´å¤æ‚åº¦åˆ†æè€ƒè™‘æœ€åæƒ…å†µï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½éœ€è¦æœç´¢ï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå…¶éœ€è¦æ—¶é—´ä¸º$O(n)$ï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æ‰€éœ€æ—¶é—´ä¸º$O(1)$ï¼Œæ•…æ‰€éœ€æ—¶é—´ä¸º$T=n(n+n(n-1)+â€¦+n!)+n!=O(n*n!)$ 5-5 æ— åˆ†éš”ç¬¦å­—å…¸é—®é¢˜ 1. è§£ç©ºé—´å’Œè§£ç»“æ„ç”±Sä¸º$L_k$å­é›†å¯çŸ¥nä¸ªç¬¦å·ï¼Œé•¿åº¦ä¸ºkçš„æ— åˆ†éš”ç¬¦å­—å…¸é—®é¢˜çš„è§£ç©ºé—´ä¸ºé•¿åº¦ä¸º$n^k$çš„å‘é‡ï¼Œå…¶ä¸­å‘é‡æ¯ä¸€é¡¹ä¸º0æˆ–1ï¼Œè¡¨ç¤º$L_k$ä¸­æŸä¸€é¡¹æ˜¯å¦åœ¨Sä¸­ï¼Œè§£ç»“æ„ä¸ºå­é›†æ ‘ 2. å‰ªæç­–ç•¥é¦–å…ˆå°†$L_k$ä¸­æ‰€æœ‰å­—å­—ç¬¦ä¸²æ”¾å…¥æ•°ç»„Lä¸­ï¼Œè€ƒè™‘æ˜¯å¦æ”¾å…¥ä¸‹æ ‡ä¸ºiçš„å­—ç¬¦ä¸²ï¼š çº¦æŸå‡½æ•°ï¼šè‹¥è¯¥å­—ç¬¦ä¸²ä¸å½“å‰Sé›†åˆä¸­çš„ä»»æ„å­—ç¬¦ä¸²æŒ‰ç…§é¢˜ç›®æ‰€ç»™æ–¹å¼è¿›è¡Œæ‹¼æ¥ï¼Œç»“æœå‡ä¸åœ¨Sé›†åˆä¸­ï¼Œä¸”ä¸ä¸ºè¯¥å­—ç¬¦ä¸²æœ¬èº«ï¼Œåˆ™è€ƒè™‘å°†å…¶æ”¾å…¥ï¼Œæœç´¢å…¶å·¦å­æ ‘ï¼Œå¦åˆ™å‰ªå»è¯¥èŠ‚ç‚¹çš„å·¦å­æ ‘ é™ç•Œå‡½æ•°ï¼šè€ƒè™‘ä¸æ”¾å…¥è¯¥å­—ç¬¦ä¸²ï¼Œè‹¥å°†i+1~$n^k$çš„å­—ç¬¦ä¸²å‡æ”¾å…¥ï¼Œè‹¥n^k^-i+S.size&lt;bestï¼Œåˆ™æ— éœ€æœç´¢å…¶å³å­æ ‘ï¼Œå‰ªå»è¯¥èŠ‚ç‚¹çš„å³å­æ ‘ 3. ç¤ºä¾‹å‡è®¾$\\sum=(a,b),L_k=\\{aa,ab,ba,bb\\}$,åˆ™$L_k$çš„ä¸€ä¸ªæœ€å¤§æ— åˆ†éš”ç¬¦å­—å…¸ä¸º$\\{aa,bb\\}$ 4. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int *ak;int lk;int n, k;int best = 0; //æœ€å¤§æ— åˆ†éš”ç¬¦å­—å…¸å…ƒç´ ä¸ªæ•°vector&lt;int&gt; L; //å°†æ‰€æœ‰çš„é•¿åº¦ä¸ºkçš„æ•°å­—å­—ç¬¦ä¸²å­˜åˆ°é›†åˆLä¸­set&lt;int&gt; S; //å½“å‰å­—å…¸ä¸­çš„å­—ç¬¦ä¸²å­˜å‚¨åœ¨é›†åˆsä¸­//å°†ä¸‹æ ‡ä¸ºL[]ä¸­ä¸‹æ ‡ä¸ºiçš„å­—ç¬¦ä¸²å­˜å…¥é›†åˆsvoid insert(int i)&#123; S.insert(L[i]);&#125;//å°†ä¸‹æ ‡ä¸ºL[]ä¸­ä¸‹æ ‡ä¸ºiçš„å­—ç¬¦ä¸²å­˜å…¥é›†åˆsvoid erase(int i)&#123; S.erase(L[i]);&#125;//å°†ak[]ä¸­èµ·ç‚¹ä¸ºiï¼Œé•¿åº¦ä¸ºkæ•°å­—ä¸²è½¬æ¢ä¸ºåè¿›åˆ¶æ•°å­—int digi(int i)&#123; int x = 0; for(int j=0; j&lt;k; j++) &#123; x *= 10; x += ak[j]; &#125; return x;&#125;//åˆ¤æ–­å­—ç¬¦ä¸²aå’Œç¬¬bä¸ªå­—ç¬¦ä¸²æ˜¯å¦äº’ä¸ä¸ºå‰ç¼€bool pref(int a, int b)&#123; int bb =b;//è¿™é‡Œç”¨bbåªæ˜¯å› ä¸ºåŸä»£ç ä¸å¤ªå¯¹,æˆ‘ç›´æ¥æ”¹äº† int x = a; int y = bb/10;//å»æ‰æœ€åä¸€ä½ï¼Œå¾—åˆ°é«˜k-1ä½(å› ä¸ºéªŒè¯çš„æ—¶å€™è¿™ä½æ˜¯è‚¯å®šè¦å‰”é™¤çš„ //æŒ‰ç†è¯´xä¹Ÿè¦å‰”é™¤æœ€é«˜ä½ï¼Œä½†æ˜¯åé¢çš„å¾ªç¯ä¸ä¼šç¢°åˆ°æœ€é«˜ä½ï¼Œæ‰€ä»¥è¿™é‡Œæ²¡å‰”é™¤äº† for(int i=0; i&lt;k-1; i++) //ak[0, k-2]å­˜æ”¾xçš„ä½k-1ä½ï¼Œak[k-1, k-1 + (k-2)]å­˜æ”¾y &#123; ak[k-i-2] = x % 10; x /= 10; ak[2*k-i-3] = y % 10; y /= 10; &#125; for(int i=0; i&lt;k-1; i++) //ç›¸å½“äºä¾æ¬¡åˆ¤æ–­a2a3..akb1, a3a4..b1b2, akb1..bk-1æ˜¯å¦å·²å­˜åœ¨äºSä¸­ï¼Œæœ¬ç¨‹åºä¸­ä¸‹æ ‡ä»0å¼€å§‹ if(S.count(digi(i)) &gt; 0||digi(i)==bb) //å¦‚æœå·²å­˜åœ¨äºSä¸­ return true; x = bb; y = a/10; for(int i=0; i&lt;k-1; i++)//å…ˆæ”¾bå†æ”¾a &#123; ak[k-i-2] = x % 10; x /= 10; ak[2*k-i-3] = y % 10; y /= 10; &#125; for(int i=0; i&lt;k-1; i++) if(S.count(digi(i)) &gt; 0||digi(i)==bb) return true; return false;&#125;//åˆ¤æ–­å½“å‰ä¸‹æ ‡ä¸ºbçš„å­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥åŠ å…¥å­—å…¸//å°†å­—ç¬¦ä¸²a1a2..akçœ‹ä½œkä½åè¿›åˆ¶æ•°bool oka(int b)&#123; int bb = L[b]; set&lt;int&gt;::iterator it; //å®šä¹‰è¿­ä»£å™¨ it = S.begin(); while(it != S.end()) &#123; int a = *it; if(pref(a, bb)) //å¦‚æœa,bå…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªçš„å‰ç¼€ return false; it++; &#125; return true;&#125;//å¾—åˆ°æ€»å…ƒç´ ä¸ªæ•°ä¸ºnï¼Œé•¿åº¦ä¸ºmçš„å…¨æ’åˆ—void Perm(int list[], int dep, int m, int n)&#123; if(dep&gt;m) &#123; int x = 0; for(int i=1; i&lt;=m; i++) x = x*10 + list[i]; //è½¬æ¢ä¸ºåè¿›åˆ¶æ•°å­— L.push_back(x); //å°†æ‰€æœ‰çš„æ•°å­—å­—ç¬¦ä¸²å­˜åˆ°é›†åˆLä¸­ &#125; else for(int j=1;j&lt;=n;j++) &#123; swap(list[dep], list[j]); Perm(list, dep+1, m, n); swap(list[dep], list[j]); &#125;&#125;void backtrack(int dep)&#123; if(dep &gt;= lk) &#123; if(S.size() &gt; best) best = S.size(); return; &#125; if(oka(dep)) &#123; insert(dep); backtrack(dep+1); erase(dep); &#125; if(lk-dep+S.size()&gt;best) backtrack(dep+1);&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;è¾“å…¥æ­£æ•´æ•°nï¼š&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\nè¾“å…¥æ­£æ•´æ•°kï¼š&quot;; fin &gt;&gt; k; cout &lt;&lt; k; ak = new int[2*k]; lk = n; for(int i=1; i&lt;k; i++) //kä¸ªå­—ç¬¦ä¸­ï¼Œæ¯ä¸€ä¸ªå­—ç¬¦éƒ½æœ‰nç§é€‰æ‹©ï¼Œn^kè¡¨ç¤ºæ‰€æœ‰ç”±kä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ç§æ•° lk *= n; lk--; int *x = new int[n+1]; for(int i=1; i&lt;=n; i++) x[i] = i; Perm(x, 1, k, n); //å°†é•¿åº¦ä¸ºkçš„å…¨æ’åˆ—å­˜å…¥é›†åˆLä¸­ backtrack(0); cout &lt;&lt; &quot;\\næœ€å¤§æ— åˆ†éš”ç¬¦å­—å…¸å…ƒç´ ä¸ªæ•°ä¸ºï¼š&quot; &lt;&lt; best; cout &lt;&lt; endl; cout &lt;&lt; endl; fin.close(); return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºnä¸ªå­—ç¬¦ï¼Œé•¿åº¦ä¸ºkçš„é—®é¢˜ï¼Œå¯¹äºæ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œæœç´¢éœ€è¦è€—è´¹æ—¶é—´ä¸º$O(n^kk)$ï¼Œå¯¹äºå³å­èŠ‚ç‚¹æœç´¢éœ€è¦çš„æ—¶é—´ä¸º$O(1)$ï¼Œå¯¹äºå¶èŠ‚ç‚¹éœ€è¦æ—¶é—´$O(1)$ï¼Œæ•…è€—è´¹çš„æ—¶é—´$T=O(2^{n^k-1}n^k*k)$ 5-6 æ— åˆé›†é—®é¢˜ å¤§æ¦‚çš„æ€è·¯æ˜¯ä»1å¼€å§‹æ¯ä¸ªæ•°éƒ½å°è¯•æ”¾å…¥nä¸ªå­é›†çš„æ¯ä¸ªå­é›†ï¼Œç„¶åç”¨é¢˜ç›®ç»™çš„æ¡ä»¶x+yä¸å±äºSè¿›è¡Œå‰ªæ 1. è§£ç©ºé—´å’Œè§£ç»“æ„ä»1å¼€å§‹å°è¯•æ”¾å…¥æ¯ä¸ªå­é›†ä¸­ï¼Œå¯¹äºå­é›†ä¸ºnçš„æ— åˆé›†é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºé•¿åº¦ä¸ºkçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹ä¸º1~nï¼Œè¡¨ç¤ºå¯¹åº”ä¸‹æ ‡çš„æ•°åˆ†é…åˆ°çš„å­é›†ï¼Œå…¶ä¸­kä¸ºæœ¬é¢˜æ‰€æ±‚ï¼Œä»¥n=3ä¸ºä¾‹ï¼Œè§£ç»“æ„å¦‚ä¸‹ï¼š 2. å‰ªæç­–ç•¥æ®é¢˜æ„ï¼Œè‹¥æ•°iæ— æ³•åˆ†é…åˆ°é›†åˆj(ä¸æ»¡è¶³å’Œä¸åœ¨é›†åˆçš„æ¡ä»¶)ï¼Œåˆ™è¯¥èŠ‚ç‚¹çš„ç¬¬jä¸ªåˆ†æ”¯æ— éœ€éå†ï¼Œå‰ªå»è¯¥åˆ†æ”¯ 3. ç¤ºä¾‹ 4. ä»£ç å®šä¹‰å­˜å‚¨å½“å‰è§£çš„æ•°ç»„a[N][N],å…¶ä¸­a[n][0]è¡¨ç¤ºç¬¬nä¸ªå­é›†çš„å…ƒç´ ä¸ªæ•°a[n][1]åˆ°a[n][a[n][0]]ä¸ºè¿™ä¸ªå­é›†çš„æ‰€æœ‰å…ƒç´ ã€‚å®šä¹‰nã€‚è®¾ç½®åˆå§‹çš„ç»“æœansä¸º1(æœ€åè¦å‡1ï¼Œæ‰€ä»¥åˆå§‹å€¼å…¶å®æ˜¯0)ï¼Œå®šä¹‰æœ€ä¼˜å€¼ä¸ºbestï¼Œå®šä¹‰æœ€ä¼˜è§£ä¸ºe[N][N]ï¼Œå…¶ä¸­çš„ç»“æ„å’Œa[N][N]ä¸€æ ·,ä»¥åŠå®šä¹‰åˆ¤å®šæ•°ç»„h[N][N]ï¼Œh[i][j]è¡¨ç¤ºç¬¬iä¸ªå­é›†ä¸­æ˜¯å¦æœ‰jè¿™ä¸ªå…ƒç´ ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int a[N][N], n, ans = 1, best, e[N][N];bool h[N][N];void dfs(int level)&#123; //åˆ¤æ–­å½“å‰ansä¸­çš„æ•°æ˜¯å¦èƒ½æ’å…¥ç¬¬levelä¸ªå­é›† if(level == n)&#123; //nä¸ªå­é›†çš„ä¸‹æ ‡æ˜¯0åˆ°n-1,æ‰€ä»¥å½“levelç­‰äºnæ—¶è¡¨ç¤ºå½“å‰ansä¸èƒ½æ’å…¥æ‰€æœ‰å­é›† if(ans &lt;= best) return; //å¦‚æœå½“å‰ansä¸å¦‚å½“å‰æœ€ä¼˜å€¼bestï¼Œå°±è¿”å› best = ans; //å¦‚æœæ¯”æœ€ä¼˜å€¼å¥½ï¼Œæ›´æ–°æœ€ä¼˜å€¼å’Œæœ€ä¼˜è§£ for(int i = 0; i &lt; n; i ++)&#123; for(int j = 0; j &lt;= a[i][0]; j ++) e[i][j] = a[i][j]; &#125; return; &#125; else&#123; //åˆ¤æ–­ansèƒ½å¦æ’å…¥ç¬¬levelä¸ªå­é›† bool flag = true; for(int i = 1; i &lt;= a[level][0]; i ++)&#123;//éå†å­é›† //å¦‚æœanså‡å½“å‰å…ƒç´ åœ¨å­é›†ä¸­ä¸”è¿™ä¸ªå…ƒç´ ä¸æ˜¯å®ƒæœ¬èº«,flagå°±ä¸ºfalse,è¡¨ç¤ºansä¸èƒ½æ’å…¥è¿™ä¸ªå­é›† if(h[level][ans - a[level][i]] &amp;&amp; ans - a[level][i] != a[level][i]) flag = false; &#125; if(!flag) dfs(level + 1); //ä¸èƒ½æ’å…¥ï¼Œåˆ¤æ–­ansèƒ½ä¸èƒ½æ’å…¥ç¬¬level+1ä¸ªå­é›† else&#123; //å¯ä»¥æ’å…¥ï¼Œåˆ†ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯æ’å…¥ï¼Œä¸€ç§æ˜¯ä¸æ’å…¥æ­¤å­é›† //æ’å…¥çš„æƒ…å†µ a[level][++ a[level][0]] = ans; //ç¬¬iä¸ªå­é›†ä¸ªæ•°åŠ ä¸€ï¼ŒæŠŠå…ƒç´ è®°å…¥å­é›† h[level][ans ++] = true; //æŠŠæ­¤å…ƒç´ æ ‡è®°ä¸ºåœ¨æ­¤å­é›†ä¸­ dfs(0); //åˆ¤æ–­ä¸‹ä¸€ä¸ªæ•°æ˜¯å¦èƒ½æ’å…¥ç¬¬0ä¸ªå­é›† //å›æº¯åˆ°ä¸æ’å…¥çš„æƒ…å†µï¼ŒæŠŠå­é›†ä¸ªæ•°å‡1ï¼Œå†æŠŠå½“å‰å…ƒç´ æ ‡è®°ä¸ºä¸åœ¨æ­¤å­é›†ä¸­ -- a[level][0]; h[level][-- ans] = false; dfs(level + 1); //åˆ¤æ–­è¿™ä¸ªæ•°æ˜¯å¦èƒ½æ’å…¥ä¸‹ä¸€ä¸ªå­é›† &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); cout &lt;&lt; --best &lt;&lt; endl; //è®°å½•çš„æ˜¯æœ€ä¼˜å€¼åŠ ä¸€ï¼Œè¿™é‡Œå‡å»ä¸€å¹¶è¾“å‡º for(int i = 0; i &lt; n; i ++)&#123; for(int j = 1; j &lt;= e[i][0]; j ++) printf(&quot;%d &quot;, e[i][j]); //è¾“å‡ºæœ€ä¼˜è§£ puts(&quot;&quot;); &#125; return 0;&#125; å‚è€ƒï¼šæ— å’Œé›†é—®é¢˜ - AcWing 5. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå‡è®¾å…¶ä½äºç¬¬iå±‚ï¼Œåˆ™æ—¶é—´æ¶ˆè€—ä¸º$O(i)$ï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå…¶æ—¶é—´æ¶ˆè€—ä¸º$O(1)$,æœ¬é¢˜æ—¶é—´æ¶ˆè€—è¿˜ä¸æ ‘çš„å±‚æ•°æœ‰å…³ï¼Œè€Œå±‚æ•°åˆæ˜¯è¦æ±‚çš„ã€‚ã€‚ã€‚ï¼Œéœ€è¦ä¸€äº›æ¨å¯¼æ¥å¾—åˆ°ä¸€ä¸ªä¸Šç•Œå§~ 5-7 nè‰²æ–¹æŸ±é—®é¢˜ ä¸ºäº†æé«˜æ•ˆç‡ï¼Œç”¨å›¾è®ºçš„çŸ¥è¯†ç®€åŒ–äº†é¢˜ç›®ï¼ˆæˆ‘æ²¡æ€ä¹ˆçœ‹æ‡‚ä¸ºå•¥è¿™æ ·ç®€åŒ–çš„ï¼‰ï¼Œè°¢è°¢æœ‰è¢«æ¶å¿ƒåˆ° æœ‰ç‚¹éš¾æ‡‚ï¼Œæˆ‘è§‰å¾—ä¸ä¼šè€ƒã€‚ã€‚ã€‚ï¼Œç†è§£ä¸€ä¸‹ä»£ç å§ ä»£ç input.txt: 1234564RGBY0 2 1 3 0 03 0 2 1 0 12 1 0 2 1 31 3 3 0 2 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 50;int board[MAX][6]; //å­˜å‚¨nä¸ªç«‹æ–¹ä½“å„é¢çš„é¢œè‰²int solu[MAX][6]; //å­˜å‚¨è§£int n; //ç«‹æ–¹ä½“ä¸ªæ•°ã€é¢œè‰²ç§æ•°int ans = 0; //è§£çš„ä¸ªæ•°int used[MAX];char color[MAX];//æ‰¾åˆ°ä¸€ä¸ªè§£åï¼Œè¾“å‡ºvoid out(int edge[])&#123; int i, j, k, a, b, c, d; for(i=0; i&lt;2; i++) //2ä¸ªå­å›¾ &#123; for(j=0; j&lt;n; j++) used[j] = 0; do&#123; j = 0; d = c = -1; while(j&lt;n &amp;&amp; used[j]&gt;0) //æ‰¾ä¸‹ä¸€æ¡æœªç”¨çš„è¾¹ j++; if(j &lt; n) do&#123; a = board[j][edge[i*n+j]*2]; b = board[j][edge[i*n+j]*2+1]; if(b == d) //å¦‚æœä¸Šä¸€æ¡è¾¹çš„ç»ˆç‚¹ä¸bç›¸åŒï¼Œè¯´æ˜bä¸ºå§‹ç‚¹ï¼Œäº¤æ¢ï¼Œä¿è¯aä¸ºå§‹ç‚¹ swap(a, b); //ä¿è¯æœ‰å‘è¾¹çš„å§‹ç‚¹å¯¹åº”äºå‰é¢å’Œå·¦é¢ï¼Œç»ˆç‚¹å¯¹åº”äºèƒŒé¢å’Œå³é¢ solu[j][i*2] = a; solu[j][i*2+1] = b; used[j] = 1; if(c&lt;0) //å¼€å§‹é¡¶ç‚¹ c = a; d = b; for(k=0; k&lt;n; k++) //æ‰¾ä¸‹ä¸€ä¸ªç«‹æ–¹ä½“ if(used[k]==0 &amp;&amp; (board[k][edge[i*n+k]*2]==b || board[k][edge[i*n+k]*2+1]==b)) j = k; &#125;while(b != c); //æ‰¾äº†ä¸€åœˆï¼Œå›åˆ°èµ·ç‚¹ &#125;while(j&lt;n); //æ‰€æœ‰ç«‹æ–¹ä½“éƒ½æ‰¾é &#125; for(j=0; j&lt;n; j++) //ç«‹æ–¹ä½“çš„é¡¶é¢å’Œåº•é¢çš„é¢œè‰² &#123; k = 3 - edge[j] - edge[j+n]; a = board[j][k*2]; b = board[j][k*2+1]; solu[j][4] = a; solu[j][5] = b; &#125; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;6; j++) cout &lt;&lt; color[solu[i][j]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;&#125;void search()&#123; int i, t, cube; bool ok, newg, over; int *vert = new int[n]; //è®°å½•å­å›¾ä¸­æ¯ä¸ªé¡¶ç‚¹çš„åº¦ï¼Œåº”å‡ä¸º2 int *edge = new int[n*2]; //è®°å½•æ¯ä¸ªç«‹æ–¹ä½“ä¸­è¾¹è¢«é€‰ç”¨çš„æ¡æ•°ï¼Œæ¯ä¸ªç«‹æ–¹ä½“åªæœ‰3æ¡è¾¹ï¼Œæœ‰ä¸¤ä¸ªå­å›¾è¦é€‰ç”¨ for(i=0; i&lt;n; i++) vert[i] = 0; t = -1; newg = true; while(t &gt; -2) &#123; t++; cube = t % n; //æ¯ä¸ªç«‹æ–¹ä½“æ‰¾2æ¬¡ï¼Œå¾—åˆ°çœŸå®çš„ç«‹æ–¹ä½“ç¼–å·ï¼Œä¹Ÿæ˜¯å­å›¾ä¸­è¾¹çš„ç¼–å· if(newg) //å¦‚æœæ²¡æœ‰è¾¹è¢«é€‰å…¥å­å›¾ edge[t] = -1; over = false; //æ˜¯å¦ç»“æŸï¼Œå³ä¸¤ä¸ªå­å›¾æ„å»ºå®Œæˆ ok = false; //æ ‡è®°è¾¹æ˜¯å¦å·²ç”¨è¿‡ï¼Œä¸¤ä¸ªå­å›¾ä¸åº”æœ‰å…¬å…±è¾¹ while(!ok &amp;&amp; !over) &#123; edge[t]++; //è¾¹è¢«é€‰ç”¨åŠ å…¥å­å›¾ï¼Œä½¿ç”¨æ¬¡æ•°å¢åŠ  if(edge[t]&gt;2) //åœ¨ç«‹æ–¹ä½“æ¯å¯¹ç›¸å¯¹é¢çš„é¡¶ç‚¹è¿ä¸€æ¡è¾¹ï¼Œæ¯ä¸ªç«‹æ–¹ä½“åªæœ‰3æ¡è¾¹ over = true; else ok = (t&lt;n || edge[t]!=edge[cube]); //æ˜¯å¦å·²ç”¨è¿‡ &#125; if(!over) &#123; //æ£€æµ‹è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦ if(++vert[board[cube][edge[t]*2]] &gt; 2+t/2*2) //å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå­å›¾ï¼Œé¡¶ç‚¹åº¦ä¸èƒ½è¶…è¿‡2 ok = false; //å¦‚æœæ˜¯ç¬¬äºŒä¸ªå­å›¾ï¼ŒåŠ ä¸Šç¬¬ä¸€ä¸ªå­å›¾ï¼Œé¡¶ç‚¹åº¦ä¸èƒ½è¶…è¿‡4 if(++vert[board[cube][edge[t]*2+1]] &gt; 2+t/2*2) ok = false; if(t%n == n-1 &amp;&amp; ok) //å¦‚æœä¸€ä¸ªæˆ–ä¸¤ä¸ªå­å›¾å·²æ„å»ºå®Œæˆ for(i=0; i&lt;n; i++) if(vert[i] &gt; 2+t/n*2) ok = false; if(ok) &#123; if(t == n*2-1) //æ‰¾åˆ°è§£ &#123; ans++; out(edge); return; &#125; else newg = true; &#125; else //å–ä¸‹ä¸€æ¡è¾¹ &#123; --vert[board[cube][edge[t]*2]]; //è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ --vert[board[cube][edge[t]*2+1]]; t--; newg = false; &#125; &#125; else //å›æº¯ &#123; t--; if(t &gt; -1) &#123; cube = t % n; --vert[board[cube][edge[t]*2]]; --vert[board[cube][edge[t]*2]]; &#125; t--; newg = false; &#125; &#125;&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;è¾“å…¥ç«‹æ–¹ä½“ä¸ªæ•°ï¼š&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\nè¾“å…¥é¢œè‰²ï¼š&quot;; for(int i=0; i&lt;n; i++) &#123; fin &gt;&gt; color[i]; cout &lt;&lt; color[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\nè¾“å…¥ç«‹æ–¹ä½“å„é¢é¢œè‰²ï¼š\\n&quot;; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;6; j++) &#123; fin &gt;&gt; board[i][j]; cout &lt;&lt; board[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;\\nç«‹æ–¹ä½“å ç½®æ–¹æ¡ˆä¸ºï¼š\\n&quot;; search(); if(ans == 0) cout &lt;&lt; &quot;No Solutionï¼\\n&quot;; cout &lt;&lt; end; fin.close(); return 0;&#125; 5-8 æ•´æ•°å˜æ¢é—®é¢˜ è¿™é“é¢˜æ˜¯ä¸€å®šèƒ½æ‰¾åˆ°çš„ï¼Œæœ‰ç‚¹ç±»ä¼¼äº3n+1?ï¼Œè¦ä¸ç„¶ä¼šè¦æ±‚è¾“å‡ºno solutionçš„ï¼Œè€Œä¸”æˆ‘ä»¬ä¹Ÿä¸èƒ½ç®€å•åœ°é€šè¿‡nå’Œmçš„å¤§å°å…³ç³»æ¥å¾—åˆ°æ­¤æ—¶éœ€è¦åšçš„æ“ä½œã€‚é¢˜ç›®çš„æ€è·¯å¤§æ¦‚å°±æ˜¯DFSæš´åŠ›æœç´¢ï¼Œå·¦å­æ ‘få˜æ¢ï¼Œå³å­æ ‘gå˜æ¢ï¼Œä¸»è¦é—®é¢˜åœ¨äºéœ€è¦é™åˆ¶æœç´¢çš„å±‚æ•°ï¼Œå› ä¸ºæœ‰äº›åˆ†æ”¯æ˜¯å¾—ä¸åˆ°è§£çš„ 1. è§£ç©ºé—´å’Œè§£ç»“æ„è§£ç©ºé—´æ˜¯ä¸€ä¸ªé•¿åº¦ä¸ºkçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹æ˜¯fæˆ–è€…gï¼Œkçš„å¤§å°ä¸è¾“å…¥æœ‰å…³ï¼Œè§£ç»“æ„å¦‚ä¸‹ï¼šå·¦å­æ ‘æ˜¯è¿›è¡Œfå˜æ¢ï¼Œå³å­æ ‘æ˜¯è¿›è¡Œgå˜æ¢ã€‚ 2. å‰ªæç­–ç•¥è™½ç„¶çœ‹åˆ°ä¸€äº›åšå®¢æ ¹æ®nå’Œmçš„å¤§å°å‰ªæï¼Œä½†æ˜¯å®é™…ä¸Šåœ¨ä»£ç ä¸­ä»–ä»¬æ²¡æœ‰è¿™æ ·åšï¼Œè€Œä¸”è¿™ç§åšæ³•åº”è¯¥æ˜¯ä¸å¯¹çš„ã€‚ã€‚ã€‚ æˆ‘è§‰å¾—è¿™é‡Œæ›´åŠ ç±»ä¼¼äºDFSï¼Œä»£ç ä¹Ÿæ²¡ä½“ç°å‡ºä»€ä¹ˆå‰ªæçš„ç­–ç•¥ï¼Œè¿™é‡Œçš„æœç´¢è¿‡ç¨‹æœ‰ç‚¹åƒæ˜¯ä¸€å±‚ä¸€å±‚å¾€ä¸‹æœç´¢ï¼Œkæ§åˆ¶ç€å±‚æ•° 3. ç¤ºä¾‹1237 43gfg 4. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define N 25#define inf 0x3f3f3f3fint n, m;//å®šä¹‰kæ¥è¡¨ç¤ºæœç´¢æ ‘çš„æ·±åº¦int k = 1;//å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—æ¥å­˜æ”¾å„ç±»æ“ä½œqueue&lt;char&gt; q;bool DFS(int x, int n)&#123; //é˜²æ­¢æ­»å¾ªç¯ï¼Œä¿è¯æœ€å¤šåªèƒ½è®¿é—®åˆ°ä¸‹ä¸€å±‚ if(x &gt; k) return false; //æ‰¾åˆ°è¿”å›true if(n == m) return true; //è¿™é‡Œå¿…é¡»ç”¨ä¸€ä¸ªtempåšä¸´æ—¶å˜é‡ //è‹¥ä¸ç”¨tempåšä¸´æ—¶å˜é‡ï¼Œå›æº¯çš„æ—¶å€™nçš„å€¼å‘ç”Ÿå˜åŒ– //å¯¼è‡´ç»“æœå¼‚å¸¸ int temp = n; //å·¦å³éƒ½åšä¸€éï¼Œçœ‹çœ‹èƒ½å¦åˆ°è¾¾ç›®çš„ for(int i = 0; i &lt; 2; i++) &#123; if(i == 0) temp = n * 3; else temp = n / 2; if(DFS(x+1, temp)) &#123; if(i == 0) q.push(&#x27;f&#x27;); else q.push(&#x27;g&#x27;); //è¿™é‡Œå¿…é¡»è¦return true //å› ä¸ºåªéœ€è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„é‚£æ¡è·¯å¾„ //å›æº¯è¿”å›çš„æ—¶å€™æŠŠè·¯å¾„ä¸Šçš„è¿ç®—åŠ å…¥é˜Ÿåˆ—å³å¯ã€‚ return true; &#125; &#125; //å¦‚æœæ²¡æ‰¾åˆ°è¿”å›false,k++ //å¯å¾€æ›´æ·±ä¸€å±‚æ¢ç´¢ return false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //æ‰¾ä¸åˆ°ï¼Œå¾€æ›´æ·±ä¸€å±‚æ¢ç´¢ï¼ while(!DFS(0, n)) k++; cout &lt;&lt; k &lt;&lt; endl; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); &#125; return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦æ ‘çš„å±‚æ•°å’Œè¾“å…¥çš„æ•°å…³ç³»æ¯”è¾ƒå¤§ï¼Œä¸å¤ªå¥½åˆ†æã€‚ã€‚ã€‚ï¼Œå¦‚æœæ ‘çš„å±‚æ•°å¯ä»¥å¾—åˆ°ä¸€ä¸ªä¸Šç•Œçš„è¯ï¼Œå¯ä»¥æ¨å¯¼ä¸€ä¸‹æœ€åæƒ…å†µ å‚è€ƒï¼šhttps://blog.csdn.net/Small___ming/article/details/103218990 5-9 æ‹‰ä¸çŸ©é˜µé—®é¢˜ å¯ä»¥ä»å·¦åˆ°å³ä»ä¸Šåˆ°ä¸‹æ¥å¡«å……çŸ©é˜µçš„æ¯ä¸ªâ€œæ ¼å­â€ï¼Œå³æ ‘çš„æ¯ä¸€å±‚å°±æ˜¯è€ƒè™‘æ¯ä¸ªæ ¼å­é‡Œæ”¾ä»€ä¹ˆï¼Œè¿™å°†å¾—åˆ°ä¸€æ£µæ¯”è¾ƒå¤§çš„æ ‘ï¼Œå‰ªæçš„ç­–ç•¥å°±æ˜¯é¢˜ç›®æ‰€è¦æ±‚çš„ï¼Œæ¯è¡Œæ¯åˆ—éƒ½æ²¡æœ‰ç›¸åŒçš„å½¢çŠ¶ï¼Œè‹¥åœ¨è¯¥æ ¼å­é‡Œæ”¾å…¥ç¬¬iç§å®çŸ³èƒ½æ»¡è¶³è¦æ±‚ï¼Œåˆ™å°†å…¶æ”¾å…¥ï¼Œå¦åˆ™å‰ªå»è¯¥æ¡åˆ†æ”¯ï¼Œå¯¹äºæ£€æŸ¥æ¯è¡Œæ¯åˆ—æ˜¯å¦æœ‰ç›¸åŒå½¢çŠ¶ï¼Œå¯ä»¥é‡‡ç”¨ä¸¤ä¸ªçŸ©é˜µæ¥è®°å½•ï¼Œè¿™æ ·æ—¶é—´æ•ˆç‡ä¼šé«˜ç‚¹ 1. è§£ç©ºé—´å’Œè§£ç»“æ„æœ¬é¢˜æ˜¯æ±‚å¯è¡Œè§£çš„ä¸ªæ•°ï¼Œè§£ç©ºé—´æ˜¯ä¸€ä¸ªnè¡Œmåˆ—çš„çŸ©é˜µï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºn*mé•¿åº¦çš„å‘é‡ï¼Œå…¶ä¸­å‘é‡çš„æ¯ä¸ªå…ƒç´ ä¸º1~nï¼Œå¯¹åº”çš„è§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥ç»´æŠ¤çŸ©é˜µrow[N][N]ï¼Œå…¶ä¸­row[i][j]=1è¡¨ç¤ºç¬¬iè¡Œå·²ç»ä½¿ç”¨äº†å½¢çŠ¶jï¼ŒçŸ©é˜µcol[N][N]ï¼Œå…¶ä¸­col[j][i]=1è¡¨ç¤ºç¬¬iåˆ—ä½¿ç”¨äº†å½¢çŠ¶jï¼Œè€ƒè™‘åœ¨ä¸ºçŸ©é˜µ(x,y)ä½ç½®ä¸Šå…ƒç´ é€‰æ‹©å®çŸ³æ—¶ï¼Œè‹¥é€‰æ‹©å®çŸ³iï¼Œåˆ™éœ€è¦ä¿è¯row[x][i]==0&amp;&amp;col[i][y]==0ï¼Œå³ä¸ä¸xè¡Œå’Œyåˆ—ä¸Šå·²æœ‰çš„å½¢çŠ¶å†²çªï¼Œè‹¥ä¸æ»¡è¶³è¯¥æ¡ä»¶ï¼Œåˆ™å¯å‰ªå»è¯¥å­æ ‘ 3. ç¤ºä¾‹ 4. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#define N 10int m,n; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—int count=0;int a[N][N]=&#123;0&#125;;int row[N][N]=&#123;0&#125;;//row[i][j]=1è¡¨ç¤ºç¬¬iè¡Œå·²ç»ä½¿ç”¨äº†å½¢çŠ¶jint col[N][N]=&#123;0&#125;;//col[j][i]=1è¡¨ç¤ºç¬¬iåˆ—å·²ç»ä½¿ç”¨äº†å½¢çŠ¶jvoid backtrack(int t)//tè¡¨ç¤ºæ­£åœ¨å¡«å……çš„çŸ©é˜µçš„ä¸€ä¸ªå°æ ¼å­,æ ¼å­èŒƒå›´ä¸º0~m*n-1//å¦‚ç¬¬ä¸€è¡Œå°±æ˜¯0 1 2 3 4...&#123; int i,j; int x,y; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—ï¼ˆåæ ‡ï¼‰ if(t==m*n)//å¦‚æœæ’å®Œäº†,è¯´æ˜å¾—åˆ°äº†ä¸€ç§å¯è¡Œè§£ &#123; count++; return; &#125; //å¦åˆ™ç»§ç»­æ’åˆ— x=t/n; //è¡Œåæ ‡ y=t%n; //åˆ—åæ ‡ for(i=1;i&lt;=n;i++)//å¯¹æ¯ç§å½¢çŠ¶éƒ½è¿›è¡Œå°è¯• &#123; if(row[x][i]==0&amp;&amp;col[i][y]==0) &#123; row[x][i]=1; col[i][y]=1; a[x][y]=i; backtrack(t+1); row[x][i]=0;//å›æº¯ col[i][y]=0; a[x][y]=0; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); backtrack(0); printf(&quot;count=%d\\n&quot;,count); return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æ—¶é—´æ¶ˆè€—ä¸º$O(1)$ï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹å…¶æ—¶é—´æ¶ˆè€—ä¸º$O(n)$ï¼Œå¯¹äºnç§å®çŸ³ï¼Œæ’æˆnè¡Œmåˆ—çš„æ‹‰ä¸çŸ©é˜µé—®é¢˜ï¼Œæ—¶é—´æ¶ˆè€—ä¸º$T=O(n^{mn})$ 5-10 æ’åˆ—å®çŸ³é—®é¢˜ è¿™é“é¢˜æ˜¯ç±»ä¼¼äº5-9çš„(ç›´æ¥åœ¨5-9ä¸Šé¢æ”¹çš„å‡ è¡Œ)ï¼Œè¯´ä¸€ä¸‹æ€è·¯å§ï¼šç±»ä¼¼äºå¯¹å¾…ä¸åŒå®çŸ³ç±»å‹è¦æ±‚æ¯è¡Œæ¯åˆ—éƒ½ä¸é‡å¤ï¼Œå¼•å…¥æ•°ç»„color_rowå’Œæ•°ç»„color_colï¼Œå…¶å¤§è‡´ç»“æ„å’Œå«ä¹‰ä¸rowå’Œcolç±»ä¼¼ï¼Œç”¨äºè®°å½•è¯¥è¡Œæˆ–è€…è¯¥åˆ—æ˜¯å¦å·²ç»ä½¿ç”¨è¿‡è¯¥ç§é¢œè‰²çš„å®çŸ³ï¼Œè¿˜å¼•å…¥usedæ•°ç»„ç”¨äºæ»¡è¶³é¢˜ä¸­çš„æ¯ç§å®çŸ³né¢—ä¸”ä¸åŒè‰²ï¼ˆé¿å…ä¸€ç§å®çŸ³çš„ä¸€ç§é¢œè‰²ä½¿ç”¨äº†å¤šæ¬¡ï¼‰ï¼Œå…¶ä¸­used[i][j]=1è¡¨ç¤ºç±»å‹içš„å®çŸ³çš„ç¬¬jç§é¢œè‰²å·²ç”¨ã€‚ ä¸5-9å¯¹æ¯”ï¼Œæ’åˆ—æ ‘å¯é€‰çš„åˆ†æ”¯å¤§å¤§å¢åŠ äº†ï¼Œä¸è¿‡å‰ªå»çš„åˆ†æ”¯ä¹Ÿæ¯”è¾ƒå¤šï¼Œæ—¶é—´å¤æ‚åº¦å¾€ä¸Šè¹­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define N 10using namespace std;int n; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—int res=0;int row[N][N]=&#123;0&#125;;//row[i][j]=1è¡¨ç¤ºç¬¬iè¡Œå·²ç»ä½¿ç”¨äº†å½¢çŠ¶jint col[N][N]=&#123;0&#125;;//col[j][i]=1è¡¨ç¤ºç¬¬iåˆ—å·²ç»ä½¿ç”¨äº†å½¢çŠ¶jint color_row[N][N]=&#123;0&#125;;int color_col[N][N]=&#123;0&#125;;int used[N][N]=&#123;0&#125;;//used[i][j]=1è¡¨ç¤ºç±»å‹içš„ç¬¬jç§é¢œè‰²å·²ç”¨void backtrack(int t)//tè¡¨ç¤ºæ­£åœ¨å¡«å……çš„çŸ©é˜µçš„ä¸€ä¸ªå°æ ¼å­,æ ¼å­èŒƒå›´ä¸º0~m*n-1//å¦‚ç¬¬ä¸€è¡Œå°±æ˜¯0 1 2 3 4...&#123; int i,j; int x,y; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—ï¼ˆåæ ‡ï¼‰ if(t==n*n)//å¦‚æœæ’å®Œäº†,è¯´æ˜å¾—åˆ°äº†ä¸€ç§å¯è¡Œè§£ &#123; res++; return; &#125; //å¦åˆ™ç»§ç»­æ’åˆ— x=t/n; //è¡Œåæ ‡ y=t%n; //åˆ—åæ ‡ for(i=1;i&lt;=n;i++)//å¯¹æ¯ç§å½¢çŠ¶éƒ½è¿›è¡Œå°è¯• &#123; for(j=1;j&lt;=n;j++)&#123;//jä¸ºé¢œè‰² if(!row[x][i]&amp;&amp;!col[i][y]&amp;&amp;!color_row[x][j]&amp;&amp;!color_col[j][y]&amp;&amp;!used[i][j]) &#123; row[x][i]=1; col[i][y]=1; color_row[x][j]=1; color_col[j][y]=1; used[i][j]=1; backtrack(t+1); row[x][i]=0; col[i][y]=0; color_row[x][j]=0; color_col[j][y]=0; used[i][j]=0; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); backtrack(0); printf(&quot;res=%d\\n&quot;,res); return 0;&#125; 5-11 é‡å¤æ‹‰ä¸çŸ©é˜µé—®é¢˜ è¿™é¢˜æ˜¯ç±»ä¼¼äº5-9çš„ï¼Œæˆ‘çš„ä»£ç ä¸€ç›´æ²¡ACï¼Œå‚è€ƒäº†ä¸‹ç­”æ¡ˆçš„ï¼Œæ€è·¯æ˜¯ï¼šç¬¬ä¸€è¡ŒæŒ‰ç…§é¢˜æ„ï¼Œç”±äºå¯¹æ¯è¡Œæ¯ç§å®çŸ³æ•°é‡çš„é™åˆ¶ï¼Œä¸”è¦æ±‚ç¬¬ä¸€è¡Œæœ€å°å­—å…¸åºï¼Œæ‰€ä»¥æ˜¯å›ºå®šçš„ï¼Œæ— éœ€å›æº¯ï¼Œæ•…ä»ç¬¬äºŒè¡Œå¼€å§‹è¿›è¡Œæœç´¢ã€‚ç­”æ¡ˆéµç…§æ•™æçš„æ’åˆ—æ ‘çš„å†™æ³•ï¼Œå…ˆåˆå§‹åŒ–çŸ©é˜µï¼Œç„¶åå†åšswapæ“ä½œï¼ŒçŸ©é˜µåˆå§‹åŒ–æƒ…å†µå¦‚è™šçº¿ä¸ŠçŸ©é˜µ(ç¤ºä¾‹ä¸ºä¾‹)ï¼Œåœ¨æœç´¢çš„æ—¶å€™ï¼Œåªéœ€è¦è€ƒè™‘æ¯åˆ—å®çŸ³è¦æ±‚å³å¯ï¼ˆå› ä¸ºåˆå§‹åŒ–çš„åŸå› ï¼Œä¸éœ€è¦è€ƒè™‘æ¯è¡Œäº†ï¼‰ï¼Œä½†æ˜¯å¾ˆå¥‡æ€ªçš„æ˜¯ï¼Œä»£ç æ²¡æœ‰è€ƒè™‘ç¬¬ä¸€åˆ—çš„æƒ…å†µäº†ï¼Œå³è®¤ä¸ºç¬¬ä¸€åˆ—ä¹Ÿæ˜¯å›ºå®šçš„ï¼Œä½†æ˜¯æˆ‘è§‰å¾—ä¸å¤ªå¯¹ï¼Œæ¯”å¦‚è™šçº¿ä¸‹é¢çš„ä¸€ç§ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ 12345678910çœç•¥ç¬¬0è¡Œã€ç¬¬0åˆ—1 1 2 2 3 3 31 &lt;1&gt; 2 2 3 3 32 1 1 2 3 3 32 1 2 1 3 3 3-------------1 1 2 2 3 3 3 3 3 3 2 2 1 1 3 3 3 1 2 2 1 3 3 2 1 3 1 2 input: 124 7 32 2 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 50;int n, m, k;int times[MAX]; //æ¯ç§å®çŸ³çš„é‡å¤æ¬¡æ•°int id[MAX]; //æ¯ä¸ªå®çŸ³çš„ä»·å€¼åºå·int board[MAX][MAX]; //å®çŸ³çŸ©é˜µ//è€ƒå¯Ÿå½“å‰åˆ—å®çŸ³æ•°æ˜¯å¦å¤šäºåº”å‡ºç°çš„æ¬¡æ•°bool ok(int r, int c, int s)&#123; int k = board[r][s]; int i; if(s &gt; c) for(i=c; i&lt;s; i++) if(board[r][i] == k) //å¦‚æœå·²ç»è¯•è¿‡ç›¸åŒç±»å‹çš„å®çŸ³ï¼Œè¿™æ¬¡å°±ä¸å†è¯•äº† return false; int count = 0; for(i=1; i&lt;r; i++) //è€ƒå¯Ÿå½“å‰åˆ—å®çŸ³æ•°æ˜¯å¦å¤šäºåº”å‡ºç°çš„æ¬¡æ•° if(board[i][c] == k) count++; if(count &gt;= times[k]) //times[k]è¡¨ç¤ºç§ç±»ä¸ºkçš„å®çŸ³åº”å‡ºç°çš„æ¬¡æ•° return false; else return true;&#125;double num = 0; //ä¸åŒçš„å®çŸ³æ’åˆ—æ–¹æ¡ˆæ•°//ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³é€’å½’æœç´¢ï¼Œå³å…ˆè¡Œååˆ—void backtrack(int r, int c)&#123; for(int i=c; i&lt;=n; i++) //åˆ— if(ok(r, c, i)) &#123; swap(board[r][c], board[r][i]); if(c == n) //å¦‚æœåˆ—è€ƒå¯Ÿå®Œæ¯• &#123; if(r == m) //å¦‚æœè¡Œè€ƒå¯Ÿå®Œæ¯• &#123; num += 1; //cout &lt;&lt; num &lt;&lt; &quot; &quot;; return; &#125; else backtrack(r+1, 2); //è€ƒå¯Ÿä¸‹ä¸€è¡Œ &#125; else backtrack(r, c+1); //è€ƒå¯Ÿä¸‹ä¸€åˆ— swap(board[r][c], board[r][i]); &#125;&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;\\nè¾“å…¥è¡Œæ•°mï¼š&quot;; fin &gt;&gt; m; cout &lt;&lt; m; cout &lt;&lt; &quot;\\nè¾“å…¥åˆ—æ•°nï¼š&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\nè¾“å…¥å®çŸ³ä»·å€¼ç§æ•°ï¼š&quot;; fin &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl; int i, temp; int t = 1; for(i=1; i&lt;=k; i++) &#123; cout &lt;&lt; &quot;è¾“å…¥ç¬¬&quot; &lt;&lt; i &lt;&lt; &quot;ç§å®çŸ³åœ¨æ¯è¡Œæ¯åˆ—å‡ºç°çš„æœ€å¤šæ¬¡æ•°ï¼š&quot;; fin &gt;&gt; times[i]; cout &lt;&lt; times[i] &lt;&lt; &quot;\\n&quot;; temp = times[i]; while(temp&gt;0) &#123; id[t++] = i; temp--; &#125; &#125; int j; for(i=1; i&lt;=m; i++) //åˆå§‹åŒ–ä¸ºå•ä½çŸ©é˜µ for(j=1; j&lt;=n; j++) board[i][j] = id[j]; //ç¬¬ä¸€è¡Œå·²ç»æ’åˆ—å¥½äº†,æ— éœ€å†æ”¹å˜äº† /* ç”±äºåˆå§‹åŒ–åçš„å•ä½çŸ©é˜µçš„ç¬¬ä¸€åˆ—éƒ½æ˜¯1ï¼Œä¸ºä½¿çŸ©é˜µçš„ç¬¬ä¸€åˆ—åŒæ—¶æ»¡è¶³ä¸€ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š åŒä¸€ç§å®çŸ³æ•°éƒ½ä¸è¶…è¿‡è§„å®šçš„æ•°é‡ï¼Œç¬¬1åˆ—ä»ä¸Šåˆ°ä¸‹çš„å®çŸ³æŒ‰å®çŸ³çš„ä»·å€¼æœ€å°å­—å…¸åºä»å°åˆ°å¤§æ’åˆ— å°†ç¬¬iè¡Œçš„ç¬¬ä¸€ä¸ªå®çŸ³ä¸å®ƒåŒè¡Œçš„ç¬¬iä¸ªå®çŸ³äº¤æ¢ä½ç½® */ for(i=2; i&lt;=n; i++) swap(board[i][1],board[i][i]); backtrack(2, 2); cout &lt;&lt; &quot;\\nä¸åŒçš„å®çŸ³æ’åˆ—æ–¹æ¡ˆæ•°ä¸ºï¼š&quot; &lt;&lt; num; cout &lt;&lt; endl &lt;&lt; endl; return 0;&#125; ä¸‹é¢æ˜¯æˆ‘çš„ä»£ç ï¼Œåœ¨5-9åŸºç¡€ä¸Šæ”¹çš„ï¼Œè¾“å‡ºçš„æ–‡ä»¶out.txtæ˜¯æ‰€æœ‰çš„æƒ…å†µ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define N 10using namespace std;int m,n,k; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—int res=0;int a[N][N]=&#123;0&#125;;int row[N][N]=&#123;0&#125;;//row[i][j]=1è¡¨ç¤ºç¬¬iè¡Œå·²ç»ä½¿ç”¨äº†å½¢çŠ¶jint col[N][N]=&#123;0&#125;;//col[j][i]=1è¡¨ç¤ºç¬¬iåˆ—å·²ç»ä½¿ç”¨äº†å½¢çŠ¶jint maxtime[N]=&#123;0&#125;;void backtrack(int t,ofstream&amp;out)//tè¡¨ç¤ºæ­£åœ¨å¡«å……çš„çŸ©é˜µçš„ä¸€ä¸ªå°æ ¼å­,æ ¼å­èŒƒå›´ä¸º0~m*n-1//å¦‚ç¬¬ä¸€è¡Œå°±æ˜¯0 1 2 3 4...&#123; int x,y; //åˆ†åˆ«ä¸ºè¡Œã€åˆ—ï¼ˆåæ ‡ï¼‰ if(t==m*n)//å¦‚æœæ’å®Œäº†,è¯´æ˜å¾—åˆ°äº†ä¸€ç§å¯è¡Œè§£ &#123; res++; out&lt;&lt;&quot;---&quot;&lt;&lt;res&lt;&lt;endl; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; out&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; &#125; out&lt;&lt;endl; &#125; out&lt;&lt;endl; return; &#125; //å¦åˆ™ç»§ç»­æ’åˆ— x=t/n; //è¡Œåæ ‡ y=t%n; //åˆ—åæ ‡ for(int i=1;i&lt;=k;i++)//å¯¹æ¯ç§å½¢çŠ¶éƒ½è¿›è¡Œå°è¯• &#123; bool flag=true; if(x==0&amp;&amp;y&gt;0&amp;&amp;i&lt;a[x][y-1]) flag=false; if(y==0&amp;&amp;x&gt;0&amp;&amp;i&lt;a[x-1][y]) flag=false; if(flag&amp;&amp;row[x][i]&lt;maxtime[i]&amp;&amp;col[i][y]&lt;maxtime[i]) &#123; //cout&lt;&lt;maxtime[i]&lt;&lt;&quot;: &quot;&lt;&lt;row[x][i]&lt;&lt;&quot;,&quot;&lt;&lt;col[i][y]&lt;&lt;&quot;| &quot;&lt;&lt;res&lt;&lt;endl; row[x][i]++; col[i][y]++; a[x][y]=i; backtrack(t+1,out); row[x][i]--;//å›æº¯ col[i][y]--; a[x][y]=0; &#125; &#125;&#125;int main()&#123; ofstream out; out.open(&quot;out.txt&quot;); scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k); for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;maxtime[i]); backtrack(0,out); printf(&quot;res=%d\\n&quot;,res); out.close(); return 0;&#125; 5-12 ç½—å¯†æ¬§ä¸æœ±ä¸½å¶çš„è¿·å®«é—®é¢˜ ä»ç½—å¯†æ¬§çš„ä½ç½®å¼€å§‹ï¼Œæ¯æ¬¡éƒ½å¯ä»¥èµ°å…«ä¸ªæ–¹å‘ï¼Œç”¨æ•°å­—è®°å½•æ–¹å‘ï¼Œè‹¥ä¸‹ä¸€æ¬¡èµ°çš„æ–¹å‘ä¸ç›´æ¥çš„ä¸åŒåˆ™è®°è½¬å‘æ¬¡æ•°åŠ ä¸€ï¼Œåœ¨è€ƒè™‘è¿›å…¥å…«ä¸ªæ–¹å‘çš„ä¸‹ä¸€ä½ç½®å‰ï¼Œéœ€è¦è€ƒè™‘è¯¥ä½ç½®æ˜¯å¦è¶Šç•Œï¼Œæ˜¯å¦æ˜¯å°é—­ä½ç½®ï¼Œæ˜¯å¦å·²ç»èµ°è¿‡ï¼Œä¸”æ˜¯å¦èµ°å…¥åå½“å‰è½¬å‘æ¬¡æ•°å¤§äºå½“å‰æœ€ä¼˜è§£æ­¤æ—¶ï¼Œä»¥æ­¤ä½œä¸ºå‰ªæç­–ç•¥ï¼Œå½“éå†å®Œæ‰€æœ‰çš„ä½ç½®åï¼Œè‹¥åˆ°è¾¾äº†æœ±ä¸½å¶çš„ä½ç½®ï¼Œåˆ™è€ƒè™‘æ›´æ–°å½“å‰æœ€ä¼˜è§£æˆ–è€…æ˜¯å¢åŠ æœ€ä¼˜è§£çš„æ¬¡æ•° 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnè¡Œmåˆ—ï¼Œå°é—­æˆ¿é—´æ•°ä¸ºkçš„è¿·å®«ï¼Œè¿·å®«é—®é¢˜çš„è§£ç©ºé—´ä¸º1~n*m-kçš„å…¨æ’åˆ—ï¼Œè¡¨ç¤ºæŸä¸ªæˆ¿é—´ç¬¬å‡ æ¬¡åˆ°è¾¾ï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥çº¦æŸå‡½æ•°ï¼šåœ¨å°è¯•èµ°å…¥ä¸‹ä¸€ä½ç½®å‰ï¼Œæ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦åˆæ³•ï¼Œå³æ˜¯å¦æ•°ç»„è¶Šç•Œï¼Œæ˜¯å¦ä¸ºå°é—­æˆ¿é—´ï¼Œæ˜¯å¦å·²ç»èµ°è¿‡ï¼Œè‹¥ä¸åˆæ³•ï¼Œåˆ™å‰ªå»è¯¥å­æ ‘ é™ç•Œå‡½æ•°ï¼šç»´æŠ¤å˜é‡curr_rotationè¡¨ç¤ºå½“å‰è½¬å‘æ¬¡æ•°ï¼Œmin_rotationè¡¨ç¤ºå½“å‰æœ€ä¼˜è§£çš„è½¬å‘æ¬¡æ•°ï¼Œè‹¥åœ¨è€ƒè™‘ä¸‹ä¸€ä½ç½®æ—¶ï¼Œåˆ°è¾¾è¯¥ä½ç½®åçš„è½¬å‘æ¬¡æ•°å¤§äºæœ€ä¼˜è§£çš„è½¬å‘æ¬¡æ•°ï¼Œåˆ™å‰ªå»è¯¥å­æ ‘ 3. ä»£ç input: 123453 4 21 23 41 12 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; int x, y;&#125;;Point luo;Point ye;Point pos;// å®šä¹‰å…«ä¸ªæ–¹å‘:å³,int dx[8] = &#123; 1, 0, -1, 0, 1, 1, -1, -1 &#125;; //å…«ä¸ªæ–¹å‘int dy[8] = &#123; 0, 1, 0, -1, 1, -1, 1, -1 &#125;;const int MAX = 10;int n, m, k;int board[MAX][MAX];int best[MAX][MAX];int curr_rotation = 0; //è½¬å¼¯æ¬¡æ•°int min_rotation = 100000; //æœ€å°‘è½¬å¼¯æ¬¡æ•°int min_count = 0; //ä¸åŒçš„æœ€å°‘è½¬å¼¯é“è·¯æ•°bool flag = false;bool Point_check(Point pos) &#123; if (pos.x &gt; 0 &amp;&amp; pos.x &lt;= n &amp;&amp; pos.y &gt; 0 &amp;&amp; pos.y &lt;= m &amp;&amp; board[pos.x][pos.y] == 0) return true; return false;&#125;// æ›´æ–°å½“å‰æœ€å°‘è½¬å¼¯æƒ…å†µä¸‹çš„è·¯çº¿void upgrade() &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) best[i][j] = board[i][j]; flag = true;&#125;// å›æº¯ç®—æ³•---&gt;å½¢å¼å‚æ•°è¡¨ç¤ºçš„æ˜¯traceBackçš„å±‚æ•°void traceBack(int depth, Point pos, int di) &#123; /* å›æº¯æ³•çš„ç»ˆæ­¢æ¡ä»¶ï¼Œ å½“æŠŠæ‰€æœ‰çš„ç©ºæˆ¿é—´éƒ½éå†ä¸€é ä¸”å½“å‰åˆ°è¾¾çš„ä½ç½®æ˜¯æœ±ä¸½å¶çš„ä½ç½® ä¸”å½“å‰è½¬å¼¯çš„æ¬¡æ•°å°‘äºç­‰äºå†å²çš„æ¬¡æ•° */ if (depth == m * n - k &amp;&amp; pos.x == ye.x &amp;&amp; pos.y == ye.y &amp;&amp; curr_rotation &lt;= min_rotation) &#123; /* å¦‚æœå½“å‰çš„curr_countå°äºmin_rotationæ›´æ–°min_rotationã€min_countä»¥åŠè·¯å¾„å›¾ */ if (curr_rotation &lt; min_rotation) &#123;//æœ‰æ›´å°‘çš„è½¬å‘ min_rotation = curr_rotation; min_count = 1;//é‡æ–°è®¡æ•° // æ›´æ–°è·¯å¾„å›¾ upgrade(); &#125; else &#123; min_count++; &#125; return; &#125; else &#123; // å‰ªæç­–ç•¥-----å½“åˆ°è¾¾è¿™ä¸ªä½ç½®çš„æ—¶å€™curr_rotationå·²ç»å¤§äºmin_rotationé‚£ä¹ˆè¿›è¡Œå‰ªæ for (int i = 0; i &lt; 8; i++) &#123; // é€šè¿‡èµ°çš„æ–¹å‘ï¼Œè®¡ç®—ä¸‹ä¸€ä¸ªä½ç½® Point next_pos; next_pos.x = pos.x + dx[i]; next_pos.y = pos.y + dy[i]; // æ¯æ¬¡èµ°ä¸€æ­¥éœ€è¦åˆ¤æ–­ä½ ä¸‹ä¸€ä¸ªåœ°ç‚¹çš„ä½ç½®æ˜¯å¦åˆæ³• if (Point_check(next_pos)) &#123; board[next_pos.x][next_pos.y] = depth + 1; if (depth &gt; 1 &amp;&amp; di != i) curr_rotation++; if (curr_rotation &lt;= min_rotation) traceBack(depth + 1, next_pos, i); // è¿›è¡Œå›æº¯ board[next_pos.x][next_pos.y] = 0; if (depth &gt; 1 &amp;&amp; di != i) curr_rotation--; &#125; &#125; &#125;&#125;int main() &#123; // è¿·å®«çš„åˆå§‹åŒ– memset(board, 0, sizeof(board)); memset(best,0,sizeof(board)); // æ–‡ä»¶çš„è¾“å…¥ ifstream datain(&quot;input.txt&quot;); cout &lt;&lt; &quot;è¾“å…¥è¿·å®«çš„å®½åº¦ï¼š&quot;; datain &gt;&gt; n; cout &lt;&lt; n&lt;&lt;endl; cout &lt;&lt; &quot;\\nè¾“å…¥è¿·å®«çš„é•¿åº¦ï¼š&quot;; datain &gt;&gt; m; cout &lt;&lt; m &lt;&lt; endl; cout &lt;&lt; &quot;\\nè¾“å…¥å°é—­æˆ¿é—´ä¸ªæ•°ï¼š&quot;; datain &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl; // å°é—­æˆ¿é—´æ•°æ®çš„è¾“å…¥ Point forbidden_rooms; for (int i = 0; i &lt; k; i++) &#123; datain &gt;&gt; forbidden_rooms.x &gt;&gt; forbidden_rooms.y; board[forbidden_rooms.x][forbidden_rooms.y] = -1; &#125; // è¾“å…¥ç½—å¯†æ¬§å’Œæœ±ä¸½å¶çš„ä½ç½®ä¿¡æ¯ datain &gt;&gt; luo.x &gt;&gt; luo.y; cout &lt;&lt; endl &lt;&lt; &quot;ç½—å¯†æ¬§ä½ç½®åæ ‡ï¼š[&quot; &lt;&lt; luo.x &lt;&lt; &quot;, &quot; &lt;&lt; luo.y &lt;&lt; &quot;]&quot; &lt;&lt; endl; board[luo.x][luo.y] = 1;//èµ·å§‹ä½ç½® datain &gt;&gt; ye.x &gt;&gt; ye.y; cout &lt;&lt; endl &lt;&lt; &quot;æœ±ä¸½å¶ä½ç½®åæ ‡ï¼š[&quot; &lt;&lt; ye.x &lt;&lt; &quot;, &quot; &lt;&lt; ye.y &lt;&lt; &quot;]&quot; &lt;&lt; endl; // å›æº¯ç®—æ³•å¼€å§‹ traceBack(1, luo, 0); // æŠŠç»“æœè¾“å‡ºåˆ°txtæ–‡ä»¶ä¸­ ofstream dataout(&quot;output_data1.txt&quot;, ios::trunc); if (flag) &#123; cout &lt;&lt; &quot;\\næœ€å°è½¬å¼¯æ¬¡æ•°ï¼š&quot; &lt;&lt; min_rotation &lt;&lt; endl; cout &lt;&lt; &quot;\\næœ€å°è½¬å¼¯æ¬¡æ•°çš„è½¬å¼¯é“è·¯æ•°ï¼š&quot; &lt;&lt; min_count &lt;&lt; endl; cout &lt;&lt; &quot;è¡Œèµ°çš„è·¯çº¿å›¾ï¼š&quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; best[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; board[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; cout&lt;&lt; &quot;\\nNo Solution!&quot; &lt;&lt; endl; &#125; return 0;&#125; 5-13 å·¥ä½œåˆ†é…é—®é¢˜ ç”±äºæ¯ä¸ªå·¥ä½œä»…ç”±ä¸€äººå®Œæˆï¼Œæ¯ä¸ªäººä»…åšä¸€ä¸ªå·¥ä½œï¼Œå¯¹äºç¤ºä¾‹çš„è¾“å…¥çŸ©é˜µï¼Œæ‰€æ±‚å³ä¸ºåœ¨æ¯ä¸€è¡Œå–ä¸€ä¸ªæ•°ï¼Œä¸”ä¿è¯æ‰€å–æ•°ä¸åœ¨åŒä¸€åˆ—ï¼Œæ±‚ä»–ä»¬çš„å’Œæœ€å°å€¼ï¼Œæ˜“çŸ¥å¦‚æœç”¨æš´åŠ›è§£æ³•ï¼Œè®¾çŸ©é˜µçš„è¡Œæ•°ä¸ºnï¼Œåˆ™è§£ä¸ºnä¸ªæ•°çš„æ’åˆ—ç»„åˆï¼Œå…¶ä¸­ç¬¬iä¸ªæ•°è¡¨ç¤ºç¬¬iä¸ªå·¥ä½œåˆ†é…ç»™ç¬¬jä¸ªäººï¼Œåˆ™å¯¹äºä¸Šè¿°è¾“å…¥çŸ©é˜µï¼Œå¯ä»¥å¾—åˆ°å¯è¡Œè§£ï¼ˆ3,2,1ï¼‰ï¼Œï¼ˆ2,1,3ï¼‰ï¼Œâ€¦â€¦ 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªå·¥ä½œçš„å·¥ä½œåˆ†é…é—®é¢˜ï¼Œå…¶è§£ç©ºé—´å³ä¸º1~nçš„å…¨æ’åˆ—ï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ï¼Œå…·ä½“è€Œè¨€æ ‘çš„ç¬¬iå±‚è¡¨ç¤ºç¬¬iä¸ªå·¥ä½œçš„åˆ†é…ï¼Œæ¯å±‚çš„é¡¶ç‚¹è¡¨ç¤ºè¯¥å·¥ä½œåˆ†é…çš„äººï¼Œå¦‚çº¢è‰²æ–¹æ¡†æ¡†å‡ºçš„èŠ‚ç‚¹å³è¡¨ç¤ºç¬¬1ä¸ªå·¥ä½œåˆ†é…ç»™C1 2. å‰ªæç­–ç•¥åœ¨æœç´¢çš„è¿‡ç¨‹ä¸­è®°å½•å½“å‰è´¹ç”¨cvå’Œæœ€ä¼˜è´¹ç”¨bestv,è‹¥cvå¤§äºç­‰äºbestvï¼Œåˆ™æ— éœ€å†éå†è¯¥èŠ‚ç‚¹çš„å­æ ‘ï¼ˆå› ä¸ºå‘ä¸‹æœç´¢çš„è¿‡ç¨‹è´¹ç”¨ä¸€å®šæ˜¯å•è°ƒé€’å¢çš„ï¼‰ 3. ç¤ºä¾‹åˆ†æˆä¸¤å¹…å›¾æ¥ç”»äº†ï¼Œå®é™…ä¸Šæ˜¯ä¸€å¹…å›¾ 4. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10010;int num;int Min=INT_MAX;int arr[N][N];int sum=0;int state[N];void dfs(int t)//ä»ç¬¬tå±‚å¼€å§‹æœç´¢&#123; if(t&gt;=num) //å·²ç»åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œç»§ç»­åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†æœ€å°æ€»è´¹ç”¨ &#123; if(Min&gt;sum)//è‹¥å½“å‰è´¹ç”¨å°äºæœ€ä¼˜è´¹ç”¨ &#123; Min=sum;//æ›´æ–°æœ€ä¼˜è´¹ç”¨ return; &#125; &#125; for(int i=0;i&lt;num;i++)//æœç´¢è¿‡ç¨‹:å°†ä½œä¸štè¿›è¡Œåˆ†é… &#123; if(!state[i])//è‹¥ç¬¬iä¸ªäººå½“å‰æ— ä½œä¸š &#123; state[i]=1;//å°†ä»»åŠ¡tåˆ†é…ç»™ç¬¬iä¸ªäºº sum+=arr[t][i];//æ›´æ–°å½“å‰è´¹ç”¨ if(sum&lt;Min) dfs(t+1);//è‹¥å½“å‰è´¹ç”¨å°äºæœ€ä¼˜è´¹ç”¨,åˆ™ç»§ç»­å‘ä¸‹æœç´¢ state[i]=0;//å›æº¯,æ¢å¤åŸçŠ¶æ€ sum-=arr[t][i];//å°†å½“å‰è´¹ç”¨æ¢å¤ &#125; &#125;&#125;int main()&#123; ifstream in; ofstream out; in.open(&quot;input.txt&quot;); out.open(&quot;output.txt&quot;); in&gt;&gt;num; Min=INT_MAX; sum=0; for(int i=0;i&lt;num;i++) &#123; for(int j=0;j&lt;num;j++) &#123; in&gt;&gt;arr[i][j]; &#125; state[i]=0; &#125; dfs(0); cout&lt;&lt;&quot;æœ€å°è´¹ç”¨ä¸ºï¼š&quot;&lt;&lt;Min&lt;&lt;endl; out&lt;&lt;&quot;æœ€å°è´¹ç”¨ä¸ºï¼š&quot;&lt;&lt;Min&lt;&lt;endl; in.close(); out.close(); return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå…¶æœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(n)$ï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(1)$ï¼Œæ•…å¯¹äºnä¸ªå·¥ä½œçš„å·¥ä½œåˆ†é…é—®é¢˜ï¼Œå…¶æ—¶é—´æ¶ˆè€—$T=n(n+nn-1+â€¦+n!)+n!=O(n!*n)$ 5-14 å¸ƒçº¿é—®é¢˜ ç»å…¸æ’åˆ—æ ‘ï¼Œç„¶åå‰ªæç­–ç•¥å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå½“å‰æœ€ä¼˜è§£çš„æˆæœ¬ï¼Œè‹¥å½“å‰æˆæœ¬å¤§äºç­‰äºè¯¥å˜é‡ï¼Œåˆ™å‰ªå»è¯¥åˆ†æ”¯ã€‚ 12332 33 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªå…ƒä»¶çš„å¸ƒçº¿é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸º1~nçš„å…¨æ’åˆ—ï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥ç»´æŠ¤å½“å‰æœ€ä¼˜è§£çš„æˆæœ¬bestvå’Œå½“å‰è´¹ç”¨cvï¼Œåœ¨è€ƒè™‘çº¿è·¯æ¿tä½ç½®ä¸Šæ˜¯å¦æ”¾ç½®å…ƒä»¶iæ—¶ï¼Œè‹¥å½“å‰è´¹ç”¨åŠ ä¸Šæ”¾ç½®å…ƒä»¶iæ‰€å¸¦æ¥çš„æˆæœ¬å°äºå½“å‰æœ€ä¼˜è§£çš„æˆæœ¬ï¼Œåˆ™å¯ç»§ç»­æœç´¢ï¼Œå¦åˆ™å‰ªå»è¯¥åˆ†æ”¯ 3. ç¤ºä¾‹ 4. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N=25;int n;int conn[N][N];int bestx[N];int bestv=INT_MAX;int cv;int cx[N];int currentvalue(int cx[],int t)//è®¡ç®—cxç¬¬tä½å¸¦æ¥çš„æˆæœ¬&#123; int res=0; for(int i=0;i&lt;t;i++)//tæ˜¯ä»0å¼€å§‹çš„ &#123; res=res+conn[cx[i]][cx[t]]*(t-i);//cxä»0å¼€å§‹ &#125; return res;&#125;void traceback(int t)&#123; if(t==n)//åˆ°è¾¾å¶å­èŠ‚ç‚¹ &#123; if(cv&lt;bestv) &#123; for(int i=0;i&lt;n;i++) &#123; bestx[i]=cx[i]; &#125; bestv=cv; &#125; return; &#125; for(int i=t;i&lt;n;i++)//cxä»0å¼€å§‹ &#123; swap(cx[t],cx[i]); int value=currentvalue(cx,t);//è®¡ç®—tè¿™ä¸€ä½å¸¦æ¥çš„æˆæœ¬ if(value+cv&lt;bestv)//æ»¡è¶³é™ç•Œæ¡ä»¶ &#123; cv+=value; traceback(t+1); cv-=value; &#125; swap(cx[t],cx[i]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; cin&gt;&gt;conn[i][j];//æ„é€ é¢†æ¥çŸ©é˜µ conn[j][i]=conn[i][j];//è¡¥å…¨å¦ä¸€åŠ &#125; &#125; for(int i=0;i&lt;n;i++) cx[i]=i+1;//å½“å‰è§£,å…ˆåˆå§‹åŒ–ä¸º123... traceback(0); cout&lt;&lt;bestv&lt;&lt;endl; for(int i=0;i&lt;n;i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; return 0;&#125; 5. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºnä¸ªå…ƒä»¶çš„å¸ƒçº¿é—®é¢˜ï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå…¶æ¶ˆè€—çš„æ—¶é—´ä¸å…¶å±‚æ•°tæœ‰å…³ï¼Œä¸º$O(n-t)$,å¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æ¶ˆè€—çš„æ—¶é—´ä¸º$O(n)$ï¼Œæ•…è¯¥é—®é¢˜æ—¶é—´æ¶ˆè€—ä¸º:$T=nn+n(n-1)(n-1)+n(n-1)(n-2)(n-2)+â€¦+n!+n!n=O(n!n)$ 5-15 æœ€ä½³è°ƒåº¦é—®é¢˜å¯ä»¥ä¸€ä¸€ä¸ºæ¯ä¸ªä»»åŠ¡åˆ†é…å·¥ä½œï¼Œæ¯ä¸ªä»»åŠ¡éƒ½å¯ä»¥å°è¯•åˆ†é…ç»™æ¯å°æœºå™¨ï¼Œä»è€Œå¯¹æ’åˆ—æ ‘è¿›è¡Œæœç´¢ã€‚ç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ¯å°æœºå™¨å·²ç»åˆ†é…çš„ä»»åŠ¡çš„æ€»è€—æ—¶ï¼Œæœç´¢åˆ°å¯è¡Œè§£åè¿™ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼å³ä¸ºå½“å‰è§£æ‰€éœ€æ—¶é—´ï¼Œåœ¨å‰ªæçš„è¿‡ç¨‹ä¸­ï¼Œå°†æ›´æ–°åè¯¥æ•°ç»„çš„å€¼ï¼ˆå³è¡¨ç¤ºé€‰æ‹©åˆ†é…ç»™è¯¥æœºå™¨ï¼‰ä¸å½“å‰æœ€ä¼˜è§£çš„è€—æ—¶æ¯”è¾ƒï¼Œè‹¥å°äºåˆ™å¯ç»§ç»­æœç´¢ã€‚ 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªä»»åŠ¡kå°æœºå™¨çš„æœ€ä½³è°ƒåº¦é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºé•¿åº¦ä¸ºnçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹ä¸º1~kï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥æŒ‰ç…§é¢˜æ„ï¼Œè¦æ±‚å®Œæˆå…¨éƒ¨ä»»åŠ¡çš„æ—¶é—´æœ€æ—©ï¼Œæ•…ç»´æŠ¤å˜é‡mintimeè¡¨ç¤ºå½“å‰æœ€ä¼˜è§£çš„å®Œæˆæ—¶é—´ï¼Œæ•°ç»„anså­˜å‚¨æ¯å°æœºå™¨å®Œæˆå½“å‰ä»»åŠ¡åçš„æ—¶é—´ï¼Œåœ¨ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­ï¼Œå°è¯•å°†ä»»åŠ¡iåˆ†é…ç»™æœºå™¨jï¼Œè‹¥t[i]+ans[j]&gt;=mintimeï¼Œåˆ™å°†è¯¥åˆ†æ”¯å‰ªå»ï¼Œæ— éœ€å†æœç´¢ 3. ä»£ç 127 32 14 4 16 6 5 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,k,t[99],ans[99],min_time=0x3f3f3f3f;//ans[i]è¡¨ç¤ºç¬¬iä¸ªæœºå™¨è¿è¡Œå®Œå…¶ä¸Šä»»åŠ¡åçš„æ—¶é—´//t[i]è¡¨ç¤ºç¬¬iä¸ªä»»åŠ¡éœ€è¦çš„æ—¶é—´void dfs(int level)&#123; if(level==n) &#123; int tmp=*max_element(ans,ans+n);//max_elementæ‰¾æ•°ç»„çš„æœ€å¤§å€¼ if(tmp&lt;min_time) min_time=tmp; return; &#125; for(int i=0;i&lt;k;i++)//å°è¯•åˆ†é…ç»™ç¬¬iå°æœºå™¨ &#123; ans[i]+=t[level]; if(ans[i]&lt;min_time) dfs(level+1); ans[i]-=t[level]; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;t[i]; dfs(0); cout&lt;&lt;min_time&lt;&lt;endl;&#125; 4. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œå…¶æ—¶é—´æ¶ˆè€—ä¸º$O(k)$ï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æ—¶é—´æ¶ˆè€—ä¸º$O(n)$ï¼Œæ•…å¯¹äºnä¸ªä»»åŠ¡kå°æœºå™¨çš„æœ€ä½³è°ƒåº¦é—®é¢˜ï¼Œå…¶æ—¶é—´æ¶ˆè€—ä¸º$T=k(k+k^2+â€¦+k^{n-1})+nk^n=O(n*k^n)$ 5-16 æ— ä¼˜å…ˆçº§è¿ç®—é—®é¢˜ æœ‰ç‚¹ç±»ä¼¼äºæ•´æ•°å˜æ¢é—®é¢˜ï¼Œè¿™é‡Œä¹Ÿæ˜¯ä¸çŸ¥é“æ ‘çš„å±‚æ•°ï¼Œå¯ä»¥ä»1ä¸ªæ•°ï¼Œ2ä¸ªæ•°ï¼Œâ€¦,nä¸ªæ•°é€æ­¥å¢åŠ æ ‘çš„å±‚æ•°ï¼Œåœ¨é€‰æ‹©æ•°çš„æ—¶å€™ï¼Œåªèƒ½ä½¿ç”¨æœªé€‰è¿‡çš„æ•°ï¼Œä»¥æ­¤ä½œä¸ºå‰ªæç­–ç•¥ï¼ˆå¯ä»¥ç”¨è¿‡æ•°ç»„è®°å½•æŸä¸ªæ•°æ˜¯å¦é€‰è¿‡ï¼‰ï¼Œä½¿ç”¨æ•°ç»„è®°å½•è¯¥æ•°å³ä¾§çš„è¿ç®—ç¬¦ï¼Œæ¯ç§ç¬¦å·çš„é€‰æ‹©å‡ä½œä¸ºåˆ†æ”¯å‘ä¸‹æœç´¢ï¼Œå½“åˆ°è¾¾å¶å­èŠ‚ç‚¹æ—¶ï¼Œæ£€æŸ¥å½“å‰è¿ç®—ç»“æœæ˜¯å¦ä¸ºmï¼Œè‹¥ä¸ºmï¼Œåˆ™ä¸ç»§ç»­æœç´¢ï¼Œç¨‹åºç»“æŸ 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªæ­£æ•´æ•°çš„æ— ä¼˜å…ˆçº§è¿ç®—é—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºé•¿åº¦ä¸º2k-1(kä»1åˆ°n)çš„å‘é‡ï¼Œè¯¥å‘é‡çš„æ¯ä¸€ä¸ªå¥‡æ•°é¡¹ä¸º1~nçš„æ•°ä¸”ç›¸äº’ä¹‹é—´ä¸é‡å¤ï¼Œå¶æ•°é¡¹ä¸º1ã€2ã€3ã€4ï¼Œåˆ†åˆ«è¡¨ç¤º+,-,*,\\ï¼Œè§£çš„ç»“æ„ä¸ºæ’åˆ—æ ‘ï¼Œå…·ä½“è€Œè¨€å¦‚ä¸‹æ‰€ç¤ºï¼š 2. å‰ªæç­–ç•¥ç»´æŠ¤æ•°ç»„flagè¡¨ç¤ºnä¸ªæ•°æ˜¯å¦ä½¿ç”¨ï¼Œflag[i]=1è¡¨ç¤ºç¬¬iä¸ªæ•°å·²ç»ä½¿ç”¨ï¼Œå½“ç»™ç¬¬depä½æ•°é€‰æ‹©æ•°æ—¶ï¼Œè‹¥è¯¥æ•°å·²ç»ä½¿ç”¨è¿‡ï¼Œåˆ™æ— æ³•é€‰æ‹©ï¼Œå‰ªå»è¯¥åˆ†æ”¯ 3. ä»£ç 125 255 2 3 6 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;int a[N];//å­˜å‚¨é¢˜ç›®æ‰€ç»™nä¸ªæ•°int num[N];//å­˜å‚¨å½“å‰è§£int oper[N];//num[i] oper[i] num[i+1]int flag[N];//å­˜å‚¨iä¸ªæ•°çš„çŠ¶æ€ï¼Œæ˜¯å¦ä½¿ç”¨int k;//è¡¨ç¤ºä½¿ç”¨çš„æ•°çš„ä¸ªæ•°bool found()&#123;//åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°è§£ int x=num[0]; for(int i=0;i&lt;k;i++) &#123; switch(oper[i])&#123; case 0:x+=num[i+1]; break; case 1:x-=num[i+1]; break; case 2:x*=num[i+1]; break; case 3:x/=num[i+1]; break; &#125; &#125; return (x==m);&#125;bool traceback(int dep)//è€ƒè™‘ç¬¬depä¸ªæ•°&#123; if(dep&gt;k)&#123; if(found()) return true; else return false; &#125; for(int i=0;i&lt;n;i++)//ç¬¬depä¸ªæ•°å°è¯•é€‰æ‹©æ•°i &#123; if(flag[i]==0) &#123; num[dep]=a[i]; flag[i]=1; for(int j=0;j&lt;4;j++)//é€‰æ‹©è¯¥æ•°å³è¾¹çš„ç¬¦å· &#123; oper[dep]=j; if(traceback(dep+1)) return true; &#125; flag[i]=0; &#125; &#125; return false;&#125;void out()//è¾“å‡ºå‡½æ•°&#123; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;num[i]; switch(oper[i])&#123; case 0:cout&lt;&lt;&quot;+&quot;;break; case 1:cout&lt;&lt;&quot;-&quot;;break; case 2:cout&lt;&lt;&quot;*&quot;;break; case 3:cout&lt;&lt;&quot;/&quot;;break; &#125; &#125; cout&lt;&lt;num[k]; return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; flag[i]=0; &#125; for(k=1;k&lt;=n;k++) &#123; if(traceback(0)) &#123; cout&lt;&lt;k&lt;&lt;endl; out(); return 0; &#125; &#125; cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 4. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œéœ€è¦nä¸ªæ•°ï¼Œæ¯ä¸ªéå¶å­èŠ‚ç‚¹çš„æ—¶é—´æ¶ˆè€—ä¸º$O(n)$ï¼Œæ¯ä¸ªå¶å­èŠ‚ç‚¹çš„æ—¶é—´æ¶ˆè€—ä¸º$O(n)$ï¼Œæ­¤æ—¶æ—¶é—´æ¶ˆè€—ä¸º$T=n(1+n+4n+4n^2+4^2n^2+â€¦+4^{n-1}n^{n})=O(n^nn4^{n-1})$ï¼ŒçœŸçš„å¾ˆå¤§ã€‚ã€‚ã€‚ 5-17 ä¸–ç•Œåç”»é™ˆåˆ—é¦†é—®é¢˜ input: 14 4 output: 123454 0 0 1 01 0 0 00 0 0 10 1 0 0 è¿™é¢˜çš„æ€è·¯å‚è€ƒäº†ä¹¦çš„ç­”æ¡ˆï¼Œä»–çš„å‰ªæç­–ç•¥æœ‰ç‚¹å¤æ‚ 1. è§£ç©ºé—´å’Œè§£ç»“æ„è§£ç©ºé—´ä¸ºé•¿åº¦ä¸ºn*mçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹ä¸º0æˆ–è€…1ï¼Œè¡¨ç¤ºæ˜¯å¦æ”¾ç½®è­¦å«ï¼Œè§£ç»“æ„ä¸ºå­é›†æ ‘ 2. å‰ªæç­–ç•¥ å¯ä»¥è¯æ˜,å½“å‰è®¿é—®çš„æ ¼ç‚¹(i,j)å·²è¢«ç›‘è§†æ—¶,æ”¾ç½®åœ¨(i,j)çš„æƒ…å†µä¸€å®šä¸ä¼šæ¯”æ”¾ç½®åœ¨(i+1,j+1)çš„æƒ…å†µå¥½.å½“(i+1,j+1)ä¸åœ¨ç½‘æ ¼ä¸­æ—¶,(i+1,j)å’Œ(i,j+1)åŒç†.æ‰€ä»¥,å¦‚æœ(i,j)å·²è¢«ç›‘è§†,åˆ™ä¸éœ€è¦åœ¨æ­¤å¤„æ”¾ç½®æœºå™¨äºº,ç›´æ¥è·³è¿‡å³å¯.ï¼ˆupdate,è¯æ˜ï¼šå› ä¸ºæ˜¯ä»ä¸Šåˆ°ä¸‹ä»å·¦åˆ°å³ä½¿å¾—æ ¼å­è¿›å…¥ç›‘è§†çŠ¶æ€ï¼Œå½“å‰æ­£åœ¨æ£€æŸ¥è®¿é—®(i,j)ã€‚è¯´æ˜åœ¨è¿™ä¹‹å‰çš„(i-1,j)å’Œ(i,j-1)å·²è¢«ç›‘è§†ã€‚æ­¤æ—¶å¦‚æœæ”¾åœ¨(i,j)å¤„ï¼Œåªä¼šä½¿å¾—(i+1,j)å’Œ(i,j+1)è¿›å…¥è®¿é—®çŠ¶æ€ã€‚è€Œå¦‚æœæ”¾åœ¨(i+1,j+1)å¤„ï¼Œæ˜¾ç„¶åœ¨å®Œæˆä¸Šè¿°ç›®æ ‡çš„æƒ…å†µä¸‹å¯ä»¥ä½¿æ›´å¤šæ ¼å­è¿›å…¥è®¿é—®çŠ¶æ€ï¼‰ å½“(i,j)æœªè¢«ç›‘è§†æ—¶,è‹¥(i,j+1)å·²è¢«ç›‘è§†,åˆ™åœ¨(i,j)æ”¾ç½®ä¸€å®šä¸ä¼šæ¯”åœ¨(i+1,j)æ”¾ç½®çš„æƒ…å†µå¥½.æ‰€ä»¥å½“ä¸”ä»…å½“(i,j)åœ¨ç½‘æ ¼å³ä¸‹è§’æˆ–è€…(I,j+1)æœªè¢«ç›‘è§†æ—¶æ‰è€ƒè™‘æ”¾ç½®åœ¨(i,j)çš„æƒ…å†µ. å½“(i,j)æœªè¢«ç›‘è§†æ—¶,è‹¥(i,j+1)å’Œ(i,j+2)å‡è¢«ç›‘è§†,åˆ™åœ¨(i+1,j)æ”¾ç½®ä¸€å®šä¸ä¼šæ¯”åœ¨(i+1,j)æ”¾ç½®çš„æƒ…å†µå¥½,æ‰€ä»¥å½“ä¸”ä»…å½“(i,j+1)æˆ–(i,j+2)æœªè¢«ç›‘è§†æ—¶æ‰è€ƒè™‘æ”¾ç½®åœ¨(i,j+1)çš„æƒ…å†µ. å½“i=næ—¶,ä¸è€ƒè™‘æ”¾ç½®åœ¨(i+1,j)çš„æƒ…å†µ. è®°å½•å·²ç»ç›‘è§†çš„æ ¼ç‚¹æ•°,(å½“å‰æœ€ä¼˜å€¼å‡å»å½“å‰å·²æ”¾ç½®ä¸ªæ•°)*5å¦‚æœå°äºæœªç›‘è§†çš„æ ¼ç‚¹æ•°,åˆ™ä¸€å®šè¾¾ä¸åˆ°æ¯”å½“å‰æœ€ä¼˜å€¼æ›´å¥½çš„æƒ…å†µ,å‰ªå». ç±»ä¼¼äº(5),è€ƒè™‘æ›´ç´§çš„æƒ…å†µ,å¹¶éæ¯ä¸ªæœºå™¨äººéƒ½èƒ½ç‹¬ç«‹ç›‘è§†5ä¸ªæ ¼ç‚¹,è‡³å°‘ä¼šæœ‰m/4+5çš„å†—ä½™,è¿™ä¸ªå‰ªæä»…é€‚ç”¨äºi&lt;n-1çš„æƒ…å†µ,å› ä¸ºæœ€åä¸¤è¡Œç”±äºæœ€ä¼˜å€¼å’Œå·²æ”¾ç½®ä¸ªæ•°éå¸¸æ¥è¿‘,æ€»æ˜¯è¾¾ä¸åˆ°è¿™ä¸ªå€¼. å¤§æ¦‚å°±æ˜¯åˆ†ä¸ºä¸‹ç•Œå‰ªææ³•å’Œæ§åˆ¶å‰ªææ³•ä¸¤ç§ï¼Œä¸‹ç•Œå‰ªææ³•å°±æ˜¯è®¡ç®—å‰©ä½™éœ€è¦çš„è­¦å«æ•°ï¼Œç„¶ååŠ ä¸Šå½“å‰è­¦å«æ•°å’Œå½“å‰æœ€ä¼˜è§£è­¦å«æ•°æ¯”è¾ƒï¼Œæ§åˆ¶å‰ªææ³•å°±æ˜¯ä¸€å †å·²ç»è¯æ˜çš„æ”¾ç½®ç­–ç•¥ï¼Œå¦‚2ã€3ã€4, 3. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int d[6][3]=&#123;&#123;0,0,0&#125;,&#123;0,0,0&#125;,&#123;0,0,-1&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,1,0&#125;&#125;;//dæ˜¯ä¸ªè¾…åŠ©ç”¨æ¥æ”¹å˜çŠ¶æ€çš„æ•°ç»„,ä»ç¬¬1é¡¹å¼€å§‹,å¯¹åº”æœ¬èº«,å·¦,ä¸Š,å³,ä¸‹int x[N][N];//å½“å‰çš„æ”¾ç½®ç­–ç•¥int y[N][N];//æ˜¯å¦å—ç›‘è§†int bestx[N][N];//æœ€ä¼˜æ”¾ç½®ç­–ç•¥int n,m,best,k=0,t=0,t1,t2,more;//kä¸ºå½“å‰è­¦å«æ•°é‡//tä¸ºå½“å‰å—ç›‘è§†çš„ä½ç½®çš„ä¸ªæ•°bool p;void place(int i,int j)//åœ¨(i,j)å¤„æ”¾ç½®è­¦å«,æ”¹å˜ç›¸é‚»ä½ç½®çš„ç›‘è§†æƒ…å†µ&#123; x[i][j]=1; k++; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]++; if(y[p][q]==1) t++; &#125;&#125;void noplace(int i,int j)//ç”¨äºæ’¤é”€åœ¨(i,j)ä¸Šæ”¾ç½®çš„è­¦å«&#123; x[i][j]=0; k--; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]--; if(y[p][q]==0) t--; &#125;&#125;void traceback(int i,int j)&#123; do&#123; j++; if(j&gt;m)&#123; i++; j=1; &#125; &#125;while(!(y[i][j]==0||i&gt;n)); //è‹¥å½“å‰åæ ‡æœªå—ç›‘è§†æˆ–å…¨éƒ¨åæ ‡éƒ½å—åˆ°ç›‘è§†è·³å‡ºå¾ªç¯ if(i&gt;n)&#123; if(k&lt;best)&#123; best=k; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[i][j]=x[i][j]; &#125; &#125; &#125; return; &#125; if(k+(t1-t)/5&gt;=best)//åˆ©ç”¨kå’Œtä¼°è®¡è­¦å«ä¸‹ç•Œ, return; if((i&lt;n-1)&amp;&amp;(k+(t2-t)/5)&gt;=best)//ä¹Ÿæ˜¯åˆ©ç”¨kå’Œtä¼°è®¡ä¸‹ç•Œ return; if(i&lt;n)&#123;//ä¸‹ä¾§æ”¾è­¦å« place(i+1,j); traceback(i,j); noplace(i+1,j); &#125; if(j&lt;m&amp;&amp;(y[i][j+1]==0||y[i][j+2]==0))&#123; place(i,j+1);//åœ¨å³ä¾§æ”¾è­¦å« traceback(i,j); noplace(i,j+1); &#125; if((y[i+1][j]==0&amp;&amp;y[i][j+1]==0)) &#123; place(i,j);//åœ¨æœ¬èº«æ”¾è­¦å« traceback(i,j); noplace(i,j); &#125;&#125;void output()&#123; cout&lt;&lt;best&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;bestx[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;void solve()&#123; //ä¸‹ç•Œå‰ªææ³•çš„è¾…åŠ©ï¼Œä¸»è¦æ˜¯ç”¨æ¥è¾…åŠ©é€šè¿‡tå’Œkä¼°è®¡è­¦å«äººæ•°çš„ä¸‹ç•Œçš„ more=m/4+1; if(m%4==3) more++; else if(m%4==2) more+=2; t2=m*n+more+4; t1=m*n+4; //ä¸‹é¢å°±å¾ˆå¥½çœ‹æ‡‚äº† best=INT_MAX; memset(y,0,sizeof(y)); memset(x,0,sizeof(x)); if(n==1&amp;&amp;m==1) &#123; cout&lt;&lt;1&lt;&lt;endl&lt;&lt;1&lt;&lt;endl; return; &#125; //æ„é€ è¾¹ç•Œ for(int i=0;i&lt;=m+1;i++) &#123; y[0][i]=1; y[n+1][i]=1; &#125; for(int i=0;i&lt;=n+1;i++) &#123; y[i][0]=1; y[i][m+1]=1; &#125; traceback(1,0); output();&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n; solve(); return 0;&#125; 5-18 ä¸–ç•Œåç”»é™ˆåˆ—é¦†é—®é¢˜ï¼ˆä¸é‡å¤ç›‘è§†ï¼‰ åœ¨5-17ä¸Šæ”¹äº†ä¸‹ï¼Œæ¡†æ¶æ²¡å˜ï¼Œå»æ‰äº†ç­”æ¡ˆé‚£äº›æ§åˆ¶å‰ªææ³•çš„å‰ªæç­–ç•¥ï¼ŒåŠ ä¸Šäº†é¢˜ç›®ä¸­è¦æ±‚çš„ä¸é‡å¤ç›‘è§†çš„å‰ªæç­–ç•¥ï¼Œä¸”åœ¨å¶å­èŠ‚ç‚¹å¤„åŠ ä¸Šäº†å¯¹æ•´ä¸ªçŸ©é˜µæ£€æŸ¥æ˜¯å¦å…¨éƒ¨ç›‘è§†äº†ï¼Œä¸»è¦åŠ äº†checkå‡½æ•°ï¼Œcheckallå‡½æ•°ï¼Œæ”¹äº†tracebackå‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int d[6][3]=&#123;&#123;0,0,0&#125;,&#123;0,0,0&#125;,&#123;0,0,-1&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,1,0&#125;&#125;;//dæ˜¯ä¸ªè¾…åŠ©ç”¨æ¥æ”¹å˜çŠ¶æ€çš„æ•°ç»„,ä»ç¬¬1é¡¹å¼€å§‹,å¯¹åº”æœ¬èº«,å·¦,ä¸Š,å³,ä¸‹int x[N][N];//å½“å‰çš„æ”¾ç½®ç­–ç•¥int y[N][N];//æ˜¯å¦å—ç›‘è§†int bestx[N][N];//æœ€ä¼˜æ”¾ç½®ç­–ç•¥int n,m,best,k=0,t=0,t1,t2,more;//kä¸ºå½“å‰è­¦å«æ•°é‡//tä¸ºå½“å‰å—ç›‘è§†çš„ä½ç½®çš„ä¸ªæ•°bool p;void place(int i,int j)//åœ¨(i,j)å¤„æ”¾ç½®è­¦å«,æ”¹å˜ç›¸é‚»ä½ç½®çš„ç›‘è§†æƒ…å†µ&#123; x[i][j]=1; k++; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]++; if(y[p][q]==1) t++; &#125;&#125;bool check(int i,int j)//æ£€æŸ¥(i,j)æ˜¯å¦èƒ½æ”¾ç½®è­¦å«&#123; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; if(y[p][q]) &#123; return false; &#125; &#125; return true;&#125;bool checkall()//æ£€æŸ¥æ˜¯å¦å…¨éƒ¨éƒ½æœ‰è­¦å«&#123; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(!y[i][j]) return false; &#125; &#125; return true;&#125;void noplace(int i,int j)//ç”¨äºæ’¤é”€åœ¨(i,j)ä¸Šæ”¾ç½®çš„è­¦å«&#123; x[i][j]=0; k--; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]--; if(y[p][q]==0) t--; &#125;&#125;void traceback(int i,int j)&#123; do&#123; j++; if(j&gt;m)&#123; i++; j=1; &#125; &#125;while(!(y[i][j]==0||i&gt;n)); //è‹¥å½“å‰åæ ‡æœªå—ç›‘è§†æˆ–å…¨éƒ¨åæ ‡éƒ½å—åˆ°ç›‘è§†è·³å‡ºå¾ªç¯ if(i&gt;n)&#123; if(k&lt;best&amp;&amp;checkall())&#123; best=k; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[i][j]=x[i][j]; &#125; &#125; &#125; return; &#125; if(k+(t1-t)/5&gt;=best)//åˆ©ç”¨kå’Œtä¼°è®¡è­¦å«ä¸‹ç•Œ, return; if((i&lt;n-1)&amp;&amp;(k+(t2-t)/5)&gt;=best)//ä¹Ÿæ˜¯åˆ©ç”¨kå’Œtä¼°è®¡ä¸‹ç•Œ return; if(check(i,j)) &#123; place(i,j); traceback(i,j); noplace(i,j); &#125; traceback(i,j);&#125;void output()&#123; cout&lt;&lt;best&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;bestx[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;void solve()&#123; more=m/4+1; if(m%4==3) more++; else if(m%4==2) more+=2; t2=m*n+more+4; t1=m*n+4; //ä¸‹é¢å°±å¾ˆå¥½çœ‹æ‡‚äº† best=INT_MAX; memset(y,0,sizeof(y)); memset(x,0,sizeof(x)); if(n==1&amp;&amp;m==1) &#123; cout&lt;&lt;1&lt;&lt;endl&lt;&lt;1&lt;&lt;endl; return; &#125; traceback(1,0); output();&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n; solve(); return 0;&#125; 5-19 ç®—mç‚¹é—®é¢˜ ç±»ä¼¼äº5-16ï¼Œä½†æ˜¯è¿™é‡Œä¸€å®šç”¨åˆ°äº†kä¸ªæ•´æ•°ï¼Œæ‰€ä»¥åªéœ€è¦ç¨å¾®æ”¹æ”¹(æŠŠkè®¾ç½®ä¸ºn-1ç„¶åæ”¹è¾“å‡º)ï¼Œè€Œä¸”è¿™ç§è®¡ç®—æ–¹å¼å¯ä»¥çœ‹æˆæ˜¯æ— ä¼˜å…ˆçº§çš„ ç¤ºä¾‹åº”è¯¥ç»™é”™äº†ï¼Œåº”è¯¥æ˜¯ä¸‹é¢è¿™æ ·ï¼š 125 1257 2 2 12 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;int a[N];//å­˜å‚¨é¢˜ç›®æ‰€ç»™nä¸ªæ•°int num[N];//å­˜å‚¨å½“å‰è§£int oper[N];//num[i] oper[i] num[i+1]int flag[N];//å­˜å‚¨iä¸ªæ•°çš„çŠ¶æ€ï¼Œæ˜¯å¦ä½¿ç”¨int k;//è¡¨ç¤ºä½¿ç”¨çš„æ•°çš„ä¸ªæ•°bool found()&#123;//åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°è§£ int x=num[0]; for(int i=0;i&lt;k;i++) &#123; switch(oper[i])&#123; case 0:x+=num[i+1]; break; case 1:x-=num[i+1]; break; case 2:x*=num[i+1]; break; case 3:x/=num[i+1]; break; &#125; &#125; return (x==m);&#125;bool traceback(int dep)//è€ƒè™‘ç¬¬depä¸ªæ•°&#123; if(dep&gt;k)&#123; if(found()) return true; else return false; &#125; for(int i=0;i&lt;n;i++)//ç¬¬depä¸ªæ•°å°è¯•é€‰æ‹©æ•°i &#123; if(flag[i]==0) &#123; num[dep]=a[i]; flag[i]=1; for(int j=0;j&lt;4;j++)//é€‰æ‹©è¯¥æ•°å³è¾¹çš„ç¬¦å· &#123; oper[dep]=j; if(traceback(dep+1)) return true; &#125; flag[i]=0; &#125; &#125; return false;&#125;void out()//è¾“å‡ºå‡½æ•°&#123; int ans=num[0]; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;ans; switch(oper[i])&#123; case 0:cout&lt;&lt;&quot;+&quot;;ans+=num[i+1];break; case 1:cout&lt;&lt;&quot;-&quot;;ans-=num[i+1];break; case 2:cout&lt;&lt;&quot;*&quot;;ans*=num[i+1];break; case 3:cout&lt;&lt;&quot;/&quot;;ans/=num[i+1];break; &#125; cout&lt;&lt;num[i+1]&lt;&lt;&quot;=&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;; &#125; return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; flag[i]=0; &#125; k=n-1; if(traceback(0)) &#123; out(); return 0; &#125; cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 5-20 éƒ¨è½å«é˜Ÿé—®é¢˜ ç±»ä¼¼äº0-1èƒŒåŒ…é—®é¢˜ï¼Œå­é›†æ ‘ï¼Œå·¦å­æ ‘ä¸º1ï¼Œå³å­æ ‘ä¸º0,çº¦æŸå‡½æ•°å°±æ˜¯ä¸èƒ½å’Œå½“å‰å«é˜Ÿé‡Œå·²æœ‰çš„å±…æ°‘ä¸ºä»‡æ•Œï¼Œè‹¥ä¸ºä»‡æ•Œï¼Œåˆ™å‰ªå»å·¦å­æ ‘ã€‚é™ç•Œå‡½æ•°æ˜¯å½“å‰å«é˜Ÿé‡Œçš„äººæ•°åŠ ä¸Šé™¤å»å½“å‰è€ƒè™‘çš„å±…æ°‘çš„å‰©ä½™çš„å±…æ°‘ï¼Œè‹¥æ•°é‡è¿˜æ˜¯æ¯”bestå°ï¼Œåˆ™å‰ªå»å³å­æ ‘ 1. è§£ç©ºé—´å’Œè§£ç»“æ„å¯¹äºnä¸ªå±…æ°‘çš„éƒ¨è½å«é˜Ÿé—®é¢˜ï¼Œå…¶è§£ç©ºé—´ä¸ºé•¿åº¦ä¸ºnçš„å‘é‡ï¼Œå‘é‡çš„æ¯ä¸€é¡¹ä¸º0æˆ–è€…1ï¼Œè§£ç»“æ„ä¸ºå­é›†æ ‘ 2. å‰ªæç­–ç•¥è€ƒè™‘å±…æ°‘tæ˜¯å¦åŠ å…¥å«é˜Ÿï¼ŒåŠ å…¥å«é˜Ÿå³è¿›å…¥å·¦å­æ ‘ï¼Œå¦åˆ™è¿›å…¥å³å­æ ‘ çº¦æŸå‡½æ•°ï¼šè‹¥å±…æ°‘tå’Œ1~t-1ä¸­å·²ç»åŠ å…¥å«é˜Ÿçš„å±…æ°‘ç›´æ¥æœ‰ä»‡è§†å…³ç³»ï¼Œåˆ™tä¸èƒ½åŠ å…¥å«é˜Ÿï¼Œå‰ªå»å·¦å­æ ‘ é™ç•Œå‡½æ•°ï¼šè‹¥å±…æ°‘tä¸åŠ å…¥å«é˜Ÿï¼Œç»´æŠ¤å˜é‡cvä¸ºå½“å‰å«é˜Ÿä¸­å±…æ°‘äººæ•°ï¼Œåˆ™å«é˜Ÿæœªæ¥å¯èƒ½çš„æœ€å¤šäººæ•°ä¸ºcv+n-tï¼Œè‹¥è¯¥å€¼å¤§äºnï¼Œæ‰æœç´¢å³å­æ ‘ï¼Œå¦åˆ™å‰ªå»å³å­æ ‘ 3. ä»£ç inputï¼š 12345678910117 101 21 42 42 32 52 63 53 64 55 6 ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;//nä¸ªå±…æ°‘,mä¸ªå…³ç³»int relation[N][N];//å±…æ°‘å…³ç³»,0è¡¨ç¤ºæ­£å¸¸ï¼Œ1è¡¨ç¤ºä»‡è§†,ä»1å¼€å§‹çš„int cbest=0;//æœ€å¤šçš„å«å…µint bestx[N];//å­˜å‚¨æœ€ä¼˜è§£int cv=0;//å½“å‰å«å…µäººæ•°int x[N];//å½“å‰è§£,x[i]=1è¡¨ç¤ºç¬¬iä¸ªå±…æ°‘æ˜¯å«å…µvoid traceback(int t)//ç¬¬tä¸ªå±…æ°‘æ˜¯å¦ä½œä¸ºå«å…µ&#123; if(t==n)//åˆ°è¾¾å¶å­èŠ‚ç‚¹ &#123; if(cv&gt;cbest) &#123; for(int i=0;i&lt;n;i++) &#123; bestx[i]=x[i]; cbest=cv; &#125; &#125; return; &#125; bool flag=true;//åˆ¤æ–­æ˜¯å¦æœ‰å†²çª for(int i=0;i&lt;t;i++) &#123; if(x[i]==1&amp;&amp;relation[t+1][i+1]==1) &#123; flag=false; break; &#125; &#125; if(flag)//è€ƒè™‘æ˜¯å¦è¿›å…¥å·¦å­æ ‘ &#123; x[t]=1; cv++; traceback(t+1); x[t]=0; cv--; &#125; if(cv+n-t&gt;cbest)//è€ƒè™‘æ˜¯å¦è¿›å…¥å³å­æ ‘ &#123; traceback(t+1); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int t1,t2; for(int i=0;i&lt;m;i++)//æ„é€ é¢†æ¥çŸ©é˜µ &#123; cin&gt;&gt;t1&gt;&gt;t2; relation[t1][t2]=1; relation[t2][t1]=1; &#125; traceback(0);//ä»ç¬¬0ä¸ªå±…æ°‘å¼€å§‹è€ƒè™‘ cout&lt;&lt;cbest&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 4. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œæœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(t+1)$ï¼Œå…¶ä¸­tä¸ºå½“å‰çš„å±‚æ•°ï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œå…¶æœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(n)$ï¼Œæ•…å±…æ°‘æ•°é‡ä¸ºnçš„éƒ¨è½å«é˜Ÿé—®é¢˜çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n*2^n)$ 5-21ã€5-22è£…è½½é—®é¢˜å’Œ0-1èƒŒåŒ…é—®é¢˜ï¼Œè§ä¹¦ä¸Šä¾‹é¢˜~ 5-23 åœ†æ’åˆ—é—®é¢˜ æ’åˆ—æ ‘ï¼Œåœ¨é€‰æ‹©ä¸€ä¸ªåœ†çš„æ—¶å€™ï¼Œå°±èƒ½è®¡ç®—ä»–å¸¦æ¥çš„é•¿åº¦ï¼ˆéœ€è¦å•ç‹¬è€ƒè™‘ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªçš„åŠå¾„å¸¦æ¥çš„é•¿åº¦ï¼‰ï¼Œç»´æŠ¤å½“å‰æœ€ä¼˜è§£ï¼Œè‹¥å½“å‰è§£å°äºæœ€ä¼˜è§£æ‰ç»§ç»­æœç´¢ï¼Œçœ‹çœ‹ä»£ç å¤§æ¦‚å°±èƒ½æ‡‚å•¦ï¼ˆçªç„¶å‘ç°ä¹¦ä¸Šæœ‰è¿™é“ä¾‹é¢˜ï¼Œä¹Ÿå¯ä»¥çœ‹çœ‹ä¹¦ä¸Šçš„ï¼‰ 1231 1 2 1. è§£ç©ºé—´å’Œè§£ç»“æ„nä¸ªåœ†çš„åœ†æ’åˆ—é—®é¢˜çš„è§£ç©ºé—´ä¸º1~nçš„å…¨æ’åˆ—ï¼Œè§£ç»“æ„ä¸ºæ’åˆ—æ ‘ 2. å‰ªæç­–ç•¥ç»´æŠ¤å˜é‡minlenè¡¨ç¤ºå½“å‰æœ€ä¼˜è§£çš„é•¿åº¦ï¼Œclenè¡¨ç¤ºå½“å‰é•¿åº¦ï¼Œå½“è€ƒè™‘æ”¾ç½®ç¬¬tä¸ªåœ†æ—¶ï¼Œè®¡ç®—å…¶å¸¦æ¥çš„é•¿åº¦lï¼Œè‹¥l+clen&gt;=minlenï¼Œåˆ™å‰ªå»è¯¥å­æ ‘ 3. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int n;double r[N];double minlen=DBL_MAX;double clen=0;int x[N];//å½“å‰çš„æ’åˆ—double bring(int t)&#123; if(t==0) return r[x[t]];//ç¬¬ä¸€ä¸ªå°±æ˜¯åŠå¾„ else&#123;//åŠ ä¸Štå’Œt-1ä½ç½®ä¸Šåœ†å¿ƒçš„xä¹‹é—´çš„è·ç¦» double res=0; res=sqrt((r[x[t]]+r[x[t-1]])*(r[x[t]]+r[x[t-1]])-abs(r[x[t]]-r[x[t-1]])*abs(r[x[t]]-r[x[t-1]])); if(t==n-1) res+=r[x[t]];//æœ€åä¸€ä¸ªè¿˜è¦åŠ åŠå¾„ return res; &#125;&#125;void traceback(int t)//è€ƒè™‘æ”¾ç½®çš„ç¬¬tä¸ªåœ†&#123; if(t==n)//å¶èŠ‚ç‚¹ï¼Œæ›´æ–°min &#123; if(clen&lt;minlen) minlen=clen; return; &#125; for(int i=t;i&lt;n;i++)//è€ƒè™‘å°†æœªä½¿ç”¨çš„åœ†æ”¾åœ¨tä½ç½® &#123; swap(x[t],x[i]); double ctmp=clen; if(clen+bring(t)&lt;minlen)//å½“å‰é•¿åº¦å°äºæœ€ä¼˜è§£é•¿åº¦ &#123; clen=clen+bring(t); traceback(t+1); clen=ctmp; &#125; swap(x[t],x[i]);t &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;r[i]; x[i]=i; &#125; traceback(0); cout&lt;&lt;minlen; return 0;&#125; 4. æ—¶é—´å¤æ‚åº¦è€ƒè™‘æœ€åæƒ…å†µï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹ï¼Œæœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(n-t)$ï¼Œtä¸ºå¶å­èŠ‚ç‚¹çš„å±‚æ•°ï¼Œå¯¹äºå¶å­èŠ‚ç‚¹ï¼Œæœç´¢æ‰€éœ€æ—¶é—´ä¸º$O(1)$ï¼Œæ•…nä¸ªåœ†çš„åœ†æ’åˆ—é—®é¢˜çš„æœ€åæƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ä¸º$O(n!)$ 5-24å›¾ç€è‰²é—®é¢˜ï¼Œè§ä¹¦ä¸Šä¾‹é¢˜~ 5-25 æœ€çŸ­åŠ æ³•é“¾é—®é¢˜ ç±»ä¼¼äºæ•´æ•°å˜æ¢é‚£é¢˜ï¼Œä¹Ÿæ˜¯æ ‘çš„å±‚æ•°æœªçŸ¥ï¼Œæ‰€ä»¥å¯ä»¥ç”¨å˜é‡æ§åˆ¶å±‚æ•°æ…¢æ…¢åŠ å¤§ï¼Œå¯ä»¥é‡‡ç”¨æ— ä¼˜å…ˆçº§è¿ç®—é—®é¢˜çš„ç±»ä¼¼æ¡†æ¶å»è§£è¿™é“é¢˜ï¼Œä¸åŒçš„æ˜¯è¿™é¢˜éšç€å±‚æ•°çš„åŠ å¤§åˆ†æ”¯æ•°ä¹ŸåŠ å¤§äº†ï¼Œå‰ªæç­–ç•¥æ˜¯å½“å‰è€ƒè™‘çš„é¡¹ä¸èƒ½å¤§äº23ï¼Œçœ‹çœ‹ä»£ç å°±å·®ä¸å¤š~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int N=100;int n;//éœ€è¦å¾—åˆ°çš„æ•°int x[N];//åŠ æ³•é“¾æ•°ç»„int k;//æ§åˆ¶å±‚æ•°bool traceback(int t)//è€ƒè™‘åŠ æ³•é“¾çš„ç¬¬té¡¹&#123; if(t==k) &#123; if(x[k-1]==n) return true; else return false; &#125; //é€‰æ‹©åŠ æ³•é“¾ä¸­çš„ä¸¤ä¸ªç›¸åŠ å¾—åˆ°ç¬¬té¡¹ for(int i=0;i&lt;t;i++) &#123; for(int j=0;j&lt;t;j++) &#123; if(x[i]+x[j]&lt;=n)//å‰ªæï¼Œè¯¥é¡¹è¦å°äºç­‰äºn &#123; x[t]=x[i]+x[j]; if(traceback(t+1)) &#123; return true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n; x[0]=1; for(k=1;k&lt;=n;k++)//æœ€å¤šnå±‚ &#123; if(traceback(1))//è¿™é‡Œå¾—æ˜¯1,å› ä¸ºå¦‚æœæ˜¯0ä¼šç›´æ¥è¿”å›false &#123; cout&lt;&lt;k-1&lt;&lt;endl; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;; &#125; return 0; &#125; &#125; return 0;&#125; å®Œç»“æ’’èŠ±ğŸ‰~","categories":[],"tags":[]},{"title":"algorithm","slug":"algorithm","date":"2022-12-14T14:09:57.000Z","updated":"2025-02-17T11:56:31.567Z","comments":true,"path":"2022/12/14/algorithm/","link":"","permalink":"https://leungto.github.io/2022/12/14/algorithm/","excerpt":"ä»£ç å‚è€ƒacwing-yxc","text":"ä»£ç å‚è€ƒacwing-yxc tips c++é‡Œé¢1e7å’Œ1e8çš„å¤æ‚åº¦å¤§æ¦‚1sèƒ½å¤Ÿè®¡ç®—å¾—åˆ° 10çš„9æ¬¡æ–¹ä»¥å†…æˆ–è€…32ä½æ•´æ•°ç”¨intå­˜æ”¾ï¼Œ10çš„18æ¬¡æ–¹ä»¥å†…æˆ–è€…64ä½æ•´æ•°ç”¨long long å­˜æ”¾ å°å†™å­—æ¯æ¯”å¤§å†™å­—æ¯çš„ASCIIå¤§32 %d-æ•´æ•°ï¼›%s-å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦æ•°ç»„ï¼‰ï¼Œ%f-æµ®ç‚¹æ•°ï¼Œ%c-char å¯¹äºå››èˆäº”å…¥çš„å¤„ç†ï¼šå¯ä»¥ç›´æ¥è¿›è¡Œåˆ¤æ–­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æµ®ç‚¹æ•°çš„roundå‡½æ•° è‡ªå»ºæ•°æ®ç»“æ„ä¸€å®šè¦è€ƒè™‘åˆå§‹åŒ– C++ä½è¿ç®—çš„ä¼˜å…ˆçº§æ¯”åŠ å‡ä¹˜é™¤çš„ä¼˜å…ˆçº§ä½ï¼Œæ‰€ä»¥é‡åˆ°ä½è¿ç®—å’ŒåŠ å‡ä¹˜é™¤ä¸€èµ·çš„ï¼Œè¦åŠ ä¸ªæ‹¬å·ã€‚ æ³¨æ„è¦ä¸è¦ç”¨long long åŸºç¡€ç®—æ³•å¿«é€Ÿæ’åºå¿«é€Ÿæ’åºåˆ†æ²» ç¡®å®šåˆ†ç•Œç‚¹ q[l]ï¼Œq[(l+r)/2],q[r],éšæœºï¼Œä½¿å…¶å€¼ä¸ºx è°ƒæ•´èŒƒå›´ ï¼ˆå·¦åŠè¾¹&lt;=xï¼‰ï¼ˆå³åŠè¾¹&gt;=xï¼‰ï¼Œæ³¨æ„åˆ†ç•Œç‚¹ä¸ä¸€å®šæ˜¯x é€’å½’å¤„ç†å·¦å³ä¸¤æ®µ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N = 100010;int q[N];//åˆ†æ²»æ³•æ€æƒ³void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; //åŒæŒ‡é’ˆ int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];//å–ä¸­é—´ä½œä¸ºåŸºå‡† while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x);//å·¦å³æŒ‡é’ˆç§»åŠ¨ do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]);//äº¤æ¢ &#125; quick_sort(q, l, j);//é€’å½’å¤„ç†å·¦å³éƒ¨åˆ† quick_sort(q, j + 1, r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); return 0;&#125; python 12345678910111213141516171819202122232425262728def quick_sort(q, l, r): if l &gt;= r: return x = q[l + r &gt;&gt; 1] i = l - 1 j = r + 1 while i &lt; j: while 1: i += 1 if q[i] &gt;= x: break while 1: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j + 1, r)def main(): n = int(input()) data = [int(x) for x in input().split()] quick_sort(data, 0, n - 1) print(&quot; &quot;.join(list(map(str, data))))main() ç¬¬kä¸ªæ•°æ³¨æ„è¿™ä¸ªä»£ç å·¦è¾¹&lt;=x, å³è¾¹&gt;=x, ä½†åˆ†ç•Œç‚¹ä¸ä¸€å®š=x ï¼Œæ¨¡æ‹Ÿä¸€ä¸‹3 4 2 8 9 5 7ï¼Œè¿™ä¸ªä»£ç å¯èƒ½å’Œæœ‰äº›ä¸ä¸€æ · 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int quick_sort(int q[], int l, int r, int k)//åŸºäºå¿«æ’&#123; if (l &gt;= r) return q[l];//æ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªæ•° int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j)//å¿«æ’æŒ‰åŸºå‡†åˆ’åˆ† &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; if (j - l + 1 &gt;= k) return quick_sort(q, l, j, k);//è‹¥å·¦åŠéƒ¨åˆ†å…ƒç´ ä¸ªæ•°å¤§äºç­‰äºkï¼Œæœå·¦è¾¹ else return quick_sort(q, j + 1, r, k - (j - l + 1));//å¦åˆ™æœå³è¾¹ï¼Œæ›´æ–°æœç´¢ç¬¬k - (j - l + 1)ä¸ªå…ƒç´ &#125;int main()&#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); cout &lt;&lt; quick_sort(q, 0, n - 1, k) &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930def quick_sort(q, l, r, k): if l &gt;= r: return q[l] x = q[l + r &gt;&gt; 1] i = l - 1 j = r + 1 while i &lt; j: while 1: i += 1 if q[i] &gt;= x: break while 1: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] if j - l + 1 &gt;= k: return quick_sort(q, l, j, k) else: return quick_sort(q, j + 1, r, k - (j - l + 1))def main(): n, k = list(map(int, input().split())) data = [int(x) for x in input().split()] print(quick_sort(data, 0, n - 1, k))main() å½’å¹¶æ’åºå½’å¹¶æ’åº1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], tmp[N];void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//åˆ†åˆ«å¯¹å·¦å³éƒ¨åˆ†è¿›è¡Œæ’åº int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r)//è¿›è¡Œåˆå¹¶ if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//åˆå¹¶å‰©ä½™éƒ¨åˆ† while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];//é‡æ–°æ‹·è´åˆ°åŸæ•°ç»„&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, a[i]); return 0;&#125; pythonï¼špythonçš„æœ€åæ”¶å°¾æœ‰æ›´åŠ ç®€å•çš„æ–¹æ³• 123456789101112131415161718192021222324252627282930def merge_sort(q, l, r): if l &gt;= r: return mid = l + r &gt;&gt; 1 i = l j = mid + 1 merge_sort(q, l, mid) merge_sort(q, mid + 1, r) tmp = list() while i &lt;= mid and j &lt;= r: if q[i] &lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 tmp += q[i : mid + 1] tmp += q[j : r + 1] q[l : r + 1] = tmp[:]def main(): n = int(input()) data = list(map(int, input().split())) merge_sort(data, 0, n - 1) print(&quot; &quot;.join(list(map(str, data))))main() é€†åºå¯¹å…¶å®åœ¨è®¡ç®—çš„è¿‡ç¨‹ä¸­å¯ä»¥æƒ³è±¡ï¼Œåªéœ€è¦ç»™ååŠæ®µçš„æ¯ä¸€ä¸ªå€¼è®¡ç®—ä¸€ä¸ªé€†åºå¯¹æ•°é‡ï¼Œå¦‚æœç¢°åˆ°q[i]&gt;q[j]ï¼Œåˆ™ç”±äºå‰åŠæ®µå·²ç»æ’å¥½åºï¼Œæ‰€ä»¥i~midéƒ½æ˜¯æ¯”jè¦å¤§çš„ï¼Œjä½ç½®ä¸Šçš„é€†åºå¯¹æ•°é‡å¯ä»¥è®¡ç®—å¾—åˆ°ï¼Œå¦‚æœq[i]&lt;=q[j],è¯´æ˜jä½ç½®ä¸Šçš„é€†åºå¯¹éœ€è¦æš‚ç¼“è®¡ç®—ï¼ˆå› ä¸º1~iä¸Šçš„å€¼éƒ½æ¯”jå°ï¼Œæ„ä¸æˆé€†åºå¯¹ï¼Œæ‰€ä»¥jåœ¨ç­‰å¾…ä¸€ä¸ªi+kï¼Œä½¿å¾—q[i+k]&gt;q[j]ï¼Œç„¶åjçš„é€†åºå¯¹æ•°é‡å°±æ˜¯i+k~midäº†ï¼‰ï¼Œå¦‚æœæ²¡æœ‰ç­‰åˆ°è¿™ä¸ªi+kï¼Œåˆ™è¯´æ˜æ²¡æœ‰é€†åºå¯¹å€¼ æ³¨æ„è¾¹ç•Œæ¡ä»¶&gt;=,å†™é”™äº†å¯å°±EML 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int a[N], tmp[N];LL merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else &#123; res += mid - i + 1; tmp[k ++ ] = q[j ++ ]; &#125; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; return res;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); cout &lt;&lt; merge_sort(a, 0, n - 1) &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627def merge_sort(q, l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 i = l j = mid + 1 result = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r) tmp = list() while i &lt;= mid and j &lt;= r: if q[i] &lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 result = result + mid - i + 1 tmp += q[i : mid + 1] tmp += q[j : r + 1] q[l : r + 1] = tmp[:] return resultdef main(): n = int(input()) data = list(map(int, input().split())) print(merge_sort(data, 0, n - 1))main() äºŒåˆ†æ•°çš„èŒƒå›´12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); while (m -- ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= x) r = mid; else l = mid + 1; &#125; if (q[l] != x) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;//è¿™é‡Œlræ— æ‰€è°“ï¼Œæœ€ål=r else &#123; cout &lt;&lt; l &lt;&lt; &#x27; &#x27;; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125; pythonï¼š 1234567891011121314151617181920212223242526272829def binary_search(q, n, k): l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if q[mid] &gt;= k: r = mid else: l = mid + 1 if q[l] != k: print(&quot;-1 -1&quot;) else: print(l, end=&quot; &quot;) l, r = 0, n - 1 while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if q[mid] &lt;= k: l = mid else: r = mid - 1 print(l)def main(): n, m = list(map(int, input().split())) data = list(map(int, input().split())) for i in range(m): k = int(input()) binary_search(data, n, k)main() æ•´æ•°äºŒåˆ†æ€»ç»“æ•´æ•°äºŒåˆ†æ³•ï¼šæœ‰å•è°ƒæ€§å¯ä»¥äºŒåˆ†ï¼Œæ— å•è°ƒæ€§ä¹Ÿå¯èƒ½å¯ä»¥ã€‚ä¸»è¦æ˜¯å¦å­˜åœ¨ä¸€ç§æ€§è´¨èƒ½æŠŠåŒºé—´åˆ†æˆä¸¤åŠâ€”â€”è¾¹ç•Œ äºŒåˆ†å¯ä»¥æ±‚è¿™ä¸ªåˆ’åˆ†çš„è¾¹ç•Œï¼Œå­˜åœ¨å·¦åŠéƒ¨åˆ†çš„å³è¾¹ç•Œå’Œå³åŠéƒ¨åˆ†çš„å·¦è¾¹ç•Œï¼Œæœ‰ä¸¤å¥—æ¨¡æ¿ï¼Œé€‰æ‹©çš„æ—¶å€™åˆ¤æ–­æ€§è´¨æŠŠmidæ”¾åœ¨leftè¿˜æ˜¯rightä¸Š äºŒåˆ†æ¯æ¬¡éƒ½è¦†ç›–æœ€ç»ˆçš„ç»“æœï¼Œæœ€ååªå‰©ä¸€ä¸ªæ•°çš„æ—¶å€™å°±æ˜¯ç»“æœ äºŒåˆ†æ¨¡æ¿ä¸€å…±æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«é€‚ç”¨äºä¸åŒæƒ…å†µã€‚ç®—æ³•æ€è·¯ï¼šå‡è®¾ç›®æ ‡å€¼åœ¨é—­åŒºé—´[l, r]ä¸­ï¼Œ æ¯æ¬¡å°†åŒºé—´é•¿åº¦ç¼©å°ä¸€åŠï¼Œå½“l = ræ—¶ï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ç›®æ ‡å€¼ã€‚ ç‰ˆæœ¬1å½“æˆ‘ä»¬å°†åŒºé—´[l, r]åˆ’åˆ†æˆ[l, mid]å’Œ[mid + 1, r]æ—¶ï¼Œå…¶æ›´æ–°æ“ä½œæ˜¯r = midæˆ–è€…l = mid + 1;ï¼Œè®¡ç®—midæ—¶ä¸éœ€è¦åŠ 1ã€‚ 12345678910int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; ç‰ˆæœ¬2å½“æˆ‘ä»¬å°†åŒºé—´[l, r]åˆ’åˆ†æˆ[l, mid - 1]å’Œ[mid, r]æ—¶ï¼Œå…¶æ›´æ–°æ“ä½œæ˜¯r = mid - 1æˆ–è€…l = mid;ï¼Œæ­¤æ—¶ä¸ºäº†é˜²æ­¢æ­»å¾ªç¯ï¼Œè®¡ç®—midæ—¶éœ€è¦åŠ 1ã€‚ 12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1;//éœ€è¦åŠ ä¸€ï¼Œå¦åˆ™å¯èƒ½å‡ºç°æ­»å¾ªç¯ if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; å‡è®¾æœ‰ä¸€ä¸ªæ€»åŒºé—´ï¼Œç»ç”±æˆ‘ä»¬çš„ check å‡½æ•°åˆ¤æ–­åï¼Œå¯åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œè¿™è¾¹ä»¥oä½œ trueï¼Œâ€¦..ä½œ false ç¤ºæ„è¾ƒå¥½è¯†åˆ« å¦‚æœæˆ‘ä»¬çš„ç›®æ ‡æ˜¯ä¸‹é¢è¿™ä¸ªvï¼Œé‚£éº½å°±å¿…é¡»ä½¿ç”¨æ¨¡æ¿ 1 â€¦â€¦â€¦â€¦â€¦.vooooooooo å‡è®¾ç»ç”± check åˆ’åˆ†åï¼Œæ•´ä¸ªåŒºé—´çš„å±æ€§ä¸ç›®æ ‡vå¦‚ä¸‹ï¼Œåˆ™æˆ‘ä»¬å¿…é¡»ä½¿ç”¨æ¨¡æ¿ 2 oooooooovâ€¦â€¦â€¦â€¦â€¦â€¦. æ‰€ä»¥ä¸‹æ¬¡å¯ä»¥è§‚å¯Ÿ check å±æ€§å†ä¸æ¨¡æ¿1 or 2 äº’ç›¸æ­é…å°±ä¸ä¼šå†™é”™å•¦ æ•°çš„ä¸‰æ¬¡æ–¹æ ¹1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -100, r = 100;//è¾¹ç•Œçš„é€‰æ‹© while (r - l &gt; 1e-8)//æ³¨æ„å¯¹æµ®ç‚¹æ•°çš„å¤„ç† &#123; double mid = (l + r) / 2; if (mid * mid * mid &gt;= x) r = mid;//ç±»ä¼¼äºæ•´æ•°äºŒåˆ† else l = mid; &#125; printf(&quot;%.6lf\\n&quot;, l);//æ³¨æ„æµ®ç‚¹ä¿ç•™å°æ•°ä½ return 0;&#125; (cè¯­è¨€printf()è¾“å‡ºæ ¼å¼å¤§å…¨_printfè¾“å‡ºæ ¼å¼_rusty_knifeçš„åšå®¢-CSDNåšå®¢ doubleè¾“å‡ºä¸º%lf python python printï¼ˆï¼‰å‡½æ•°æ§åˆ¶è¾“å‡ºæ ¼å¼_python æ‰“å°æ ¼å¼æ ¼å¼-CSDNåšå®¢ 123456789101112131415def binary_search(x): l = -10000 r = 10000 while r - l &gt;= 1e-8: mid = (l+r)/2.0 if mid**3 &gt;= x: r = mid else: l = mid return ldef main(): x = float(input()) result = binary_search(x) print(&quot;&#123;:.6f&#125;&quot;.format(result))main() æµ®ç‚¹äºŒåˆ†æ€»ç»“æµ®ç‚¹äºŒåˆ†æ˜¯ç±»ä¼¼äºæ•´æ•°äºŒåˆ†çš„ï¼Œä¸”å…¶æ— éœ€è€ƒè™‘+1-1çš„ï¼Œéœ€è¦æ³¨æ„ï¼š whileçš„æ¡ä»¶ï¼Œr-l&gt;ç²¾åº¦*10^-2^ï¼Œæ¯”å¦‚é¢˜ç›®è¦æ±‚ç²¾åº¦æ˜¯-6æ¬¡ï¼Œr-l&gt;1e-8 rå’Œlç›´æ¥å–è¾¹ç•Œå€¼å³å¯ é«˜ç²¾åº¦ tipsï¼š æ³¨æ„å¤„ç†è¿›ä½ï¼ŒåŒ…æ‹¬æœ€é«˜ä½çš„è¿›ä½ å€Ÿä½çš„å¤„ç†ï¼Œå€Ÿä½ä¸æ˜¯t/10ï¼Œè€Œæ˜¯æ­£è´Ÿåˆ¤å®šèµ‹å€¼ æ³¨æ„æ˜¯å¦éœ€è¦å¤„ç†å‰å¯¼0,æ³¨æ„ä¹˜æ³•æ˜¯ä¸æ˜¯å¯ä»¥ä¹˜ä»¥0 stringçš„å­˜å‚¨ï¼šâ€12345â€ 0 1 2 3 4 1 2 3 4 5 é«˜ç²¾åº¦åŠ æ³• å­˜å‚¨æ—¶ä½¿ç”¨æ•°ç»„å­˜å‚¨ï¼ˆå¯ç”¨vectorï¼‰ï¼Œä»ä¸ªä½å¼€å§‹å­˜å‚¨ï¼Œå¦‚æ•°12345ï¼Œåœ¨æ•°ç»„é‡Œçš„å­˜å‚¨æ–¹å¼ä¸ºï¼šï¼ˆä¸ºäº†æ–¹ä¾¿åŠ æ³•ï¼‰ æ•°ç»„çš„ç¬¬Xä½ 0 1 2 3 4 å­˜å‚¨çš„æ•°å­— 5 4 3 2 1 è¿ç®—çš„æ–¹æ³•ï¼šæ¨¡æ‹Ÿäººå·¥åŠ æ³•ï¼Œæ¯ä¸€ä½çš„ç»“æœç­‰äºä¸¤ä¸ªæ•°è¯¥ä½çš„ç»“æœåŠ ä¸Šä½ä½çš„è¿›ä½ ä¸å‹ä½ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if (A.size() &lt; B.size()) return add(B, A);//è®©Aæ€»æ˜¯æ›´é•¿ vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(t); //æ³¨æ„å¤„ç†æœ€åçš„è¿›ä½ return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); auto C = add(A, B); for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; return 0;&#125; å‹ä½ä»£ç  å‹ä½èƒ½å‡å°æ‰€éœ€ç©ºé—´ï¼Œé«˜ç²¾åº¦åŠ æ³•å¯ä»¥å‹9ä½ï¼Œä¹˜æ³•å¯ä»¥å‹4ä½ï¼Œå‹9ä½å°±æ˜¯æ•°ç»„çš„ä¸€ä½è¡¨ç¤ºåŸæ•°çš„9ä½ï¼ˆintèŒƒå›´çš„é™åˆ¶ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int base = 1000000000;//å‹9ä½ï¼ŒåŠ æ³•è¿›ä½çš„æ—¶å€™æ˜¯éœ€è¦ä½™basevector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % base); t /= base; &#125; if (t) C.push_back(t); return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1, s = 0, j = 0, t = 1; i &gt;= 0; i -- ) &#123;//sè®°å½•å½“å‰ä½æ•°å­—ï¼Œjä¸ºå½“å‰å‹äº†å‡ ä½ï¼Œtä¸ºè¾…åŠ©ä¹˜æ•°é‡çº§ s += (a[i] - &#x27;0&#x27;) * t; j ++, t *= 10; if (j == 9 || i == 0) &#123; A.push_back(s); s = j = 0; t = 1; &#125; &#125; for (int i = b.size() - 1, s = 0, j = 0, t = 1; i &gt;= 0; i -- ) &#123; s += (b[i] - &#x27;0&#x27;) * t; j ++, t *= 10; if (j == 9 || i == 0) &#123; B.push_back(s); s = j = 0; t = 1; &#125; &#125; auto C = add(A, B); cout &lt;&lt; C.back();//å•ç‹¬è¾“å‡ºæœ€é«˜ä½(å› ä¸ºæ— éœ€è¡¥é«˜ä½0) for (int i = C.size() - 2; i &gt;= 0; i -- ) printf(&quot;%09d&quot;, C[i]);//éœ€è¦è¡¥é«˜ä½0ï¼Œé™åˆ¶åœ¨9ä½ cout &lt;&lt; endl; return 0;&#125; è™½ç„¶pythonè‡ªå¸¦å¤§æ•´æ•°è®¡ç®—ï¼Œä½†æ˜¯è¿˜æ˜¯æ¨¡æ‹Ÿä¸€ä¸‹ç®—æ³•æ€æƒ³ï¼š 12345678910111213141516171819202122232425def add(A,B): if len(A)&lt;len(B): return add(B,A) t = 0 result = [] for i in range(len(A)): t += A[i] if i &lt; len(B): t += B[i] result.append(t%10) t = t // 10 if t : result.append(t) return result def main(): A = list(map(int,list(input()))) B = list(map(int,list(input()))) A.reverse() B.reverse() C = add(A,B) C.reverse() print(&#x27;&#x27;.join(list(map(str,C)))) main() é«˜ç²¾åº¦å‡æ³• éœ€è¦é¦–å…ˆä¿è¯sub(A,B)ä¸­æœ‰A&gt;=B ç„¶åé€ä½ä½œå·®ï¼Œæ³¨æ„å€Ÿä½ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//åˆ¤æ–­æ˜¯å¦æœ‰ A&gt;=B&#123; if (A.size() != B.size()) return A.size() &gt; B.size();//é¦–å…ˆåˆ¤æ–­ä½æ•° for (int i = A.size() - 1; i &gt;= 0; i -- )//ç„¶åä»é«˜ä½èµ·å¼€å§‹åˆ¤æ–­ if (A[i] != B[i]) return A[i] &gt; B[i]; return true;//è‹¥ç›¸ç­‰ï¼Œä¹Ÿè¿”å›true&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//ä½œå·®ï¼Œæ­¤æ—¶å·²ç»ä¿è¯A &gt;= B&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ )//tè¡¨ç¤ºå€Ÿä½ &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//å»é™¤å‰å¯¼0 return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); vector&lt;int&gt; C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout &lt;&lt; &#x27;-&#x27;;//æ³¨æ„å¯¹ç¬¦å·çš„åˆ¤æ–­ for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; return 0;&#125; python 1234567891011121314151617181920212223242526272829303132333435363738def cmp(A, B): if len(A) != len(B): return len(A) &gt; len(B) for i in range(len(A) - 1, -1, -1): if A[i] != B[i]: return A[i] &gt; B[i] return Truedef sub(A, B): t = 0 result = [] for i in range(len(A)): t = A[i] - t if i &lt; len(B): t -= B[i] result.append((t + 10) % 10) if t &lt; 0: t = 1 else: t = 0 while len(result) &gt; 1 and result[-1] == 0: result.pop() return resultdef main(): A = list(map(int, input())) B = list(map(int, input())) A.reverse() B.reverse() if cmp(A, B): C = sub(A, B) else: print(&quot;-&quot;, end=&quot;&quot;) C = sub(B, A) C.reverse() print(&quot;&quot;.join(map(str, C)))main() é«˜ç²¾åº¦ä¹˜æ³• é¦–å…ˆæ³¨æ„è¿›ä½çš„å¤„ç†ï¼Œç±»ä¼¼åŠ æ³• å…¶æ¬¡æ³¨æ„å¤„ç†å‰å¯¼0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ )//å¤„ç†è¿›ä½ï¼Œ||t &#123; if (i &lt; A.size()) t += A[i] * b;//Açš„æ¯ä¸€ä½ C.push_back(t % 10); t /= 10;//è¿›ä½ &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//bä¸º0ï¼Œå‰å¯¼0 return C;&#125;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); return 0;&#125; ä¸Šé¢è¿™ç§æ–¹æ³•ä¸å¤ªå¥½è®°å¿†ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨ä¸‹é¢è¿™ç§ï¼š 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;vector&lt;int&gt; dot(vector&lt;int&gt;&amp;A,int b)&#123; int t=0; vector&lt;int&gt; res; for(int i=0;i&lt;A.size();i++) &#123; t+=A[i]*b; res.push_back(t%10); t=t/10; &#125; while(t)//å¤„ç†ä½™ä¸‹çš„è¿›ä½ &#123; res.push_back(t%10); t=t/10; &#125; while(res.back()==0&amp;&amp;res.size()&gt;1) res.pop_back();//å¤„ç†ä¹˜ä»¥0åçš„å‰å¯¼0 return res;&#125;int main()&#123; string a; int b; cin&gt;&gt;a&gt;&gt;b; vector&lt;int&gt;A,C; for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;); C=dot(A,b); for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i]; return 0;&#125; python 1234567891011121314151617181920212223def mul(A, b): t = 0 result = [] for i in range(len(A)): t += A[i] * b result.append(t % 10) t = t // 10 while t: result.append(t % 10) t = t // 10 while len(result) &gt; 1 and result[-1] == 0: result.pop() return resultdef main(): A = list(map(int, input())) b = int(input()) A.reverse() C = mul(A, b) C.reverse() print(&quot;&quot;.join(map(str, C)))main() é«˜ç²¾åº¦é™¤æ³• ç±»ä¼¼äºäººåšé™¤æ³•ï¼Œä»é«˜ä½å¼€å§‹é™¤ï¼Œæ³¨æ„å¯¹ä½™æ•°çš„å¤„ç† é™¤å®Œåå¾—åˆ°çš„æ˜¯ä»0å¼€å§‹é«˜ä½â€”â€”ä½ä½çš„æ ¼å¼ï¼Œè¿›è¡Œåè½¬ å¤„ç†å‰å¯¼0 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a; vector&lt;int&gt; A; int B; cin &gt;&gt; a &gt;&gt; B; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); int r; auto C = div(A, B, r); for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021def div(A, B): r = 0 result = [] for i in range(len(A) - 1, -1, -1): r = r * 10 + A[i] result.append(r // B) r %= B result.reverse() while len(result) &gt; 1 and result[-1] == 0: result.pop() return result, rdef main(): A = list(map(int, input())) B = int(input()) C, r = div(A, B) C.reverse() print(&quot;&quot;.join(map(str, C))) print(r)main() å‰ç¼€å’Œå’Œå·®åˆ†ä¸€ç»´å‰ç¼€å’Œ $S_i=a_1+a_2+â€¦+a_i$ $sum(l,r)=S_r-S_{l-1}$ ä¸ºäº†èƒ½ç»Ÿä¸€æ ¼å¼ï¼Œè¾“å…¥å¯ä»¥ä»1å¼€å§‹ï¼Œç„¶ås[i] = s[i - 1] + a[i]è¿™ä¸€æ“ä½œå°±ä¹Ÿå¯ä»¥ä»1å¼€å§‹äº† 12345678910111213141516171819202122232425#include &lt; iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i - 1] + a[i]; // å‰ç¼€å’Œçš„åˆå§‹åŒ– while (m -- ) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); // åŒºé—´å’Œçš„è®¡ç®— &#125; return 0;&#125; å¦‚æœä¸éœ€è¦åŸæ¥çš„æ•°ç»„ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç”¨aæ•°ç»„è‡ªå·±æ¥å˜æ¢ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m;int a[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; a[i]=a[i]+a[i-1]; &#125; int st,ed; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;st&gt;&gt;ed; cout&lt;&lt;a[ed]-a[st-1]&lt;&lt;endl; &#125; return 0;&#125; python 123456789101112N = 100010a = [0]*Ns = [0]*Ndef main(): n,m = map(int,input().split()) a[1:n+1] = list(map(int,input().split())) for i in range(1,n+1): s[i] = s[i-1] + a[i] for i in range(m): l,r = map(int,input().split()) print(s[r]-s[l-1])main() äºŒç»´å‰ç¼€å’Œ $S[i][j]$å­˜å‚¨åŒ…æ‹¬$a[i][j]$çš„å·¦ä¸Šä¾§å…ƒç´ çš„å’Œ $S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]$ æŸ¥è¯¢$(x_1,y_1)$å’Œ$(x_2,y_2)$èŒƒå›´å†…å…ƒç´ çš„å’Œï¼ˆåŒ…æ‹¬è¿™ä¸¤ä¸ªç‚¹ï¼‰ï¼Œ$S[x_2][y_2]-S[x_2][y_1-1]-S[x_1-1][y_2]+S[x_1-1][y_1-1]$ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int s[N][N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;s[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; while (q -- ) &#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); &#125; return 0;&#125; python 12345678910111213141516N = 1010a = [[0] * N for _ in range(N)]s = [[0] * N for _ in range(N)]def main(): n, m, q = map(int, input().split()) for i in range(1, n + 1): a[i][1 : m + 1] = list(map(int, input().split())) for i in range(1, n + 1): for j in range(1, m + 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] for i in range(q): x1, y1, x2, y2 = map(int, input().split()) print(s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]) main() ä¸€ç»´å·®åˆ† å·®åˆ†çš„æ ¸å¿ƒæ“ä½œæ˜¯ï¼šåœ¨æ•°ç»„a[L:R]ä¸Šå…¨éƒ½åŠ ä¸Šcï¼Œç­‰ä»·äºb[l]+=c,b[R+1]-=c å·®åˆ†æ˜¯å‰ç¼€å’Œçš„é€†è¿ç®—ï¼Œå³æ„é€ æ•°ç»„bï¼Œä½¿å¾—aæ•°ç»„æ˜¯å…¶å‰ç¼€å’Œæ•°ç»„ å·®åˆ†çš„æ•°ç»„bä¸éœ€è¦æ˜¾ç¤ºè®¡ç®—ï¼Œå¯ä»¥ç†è§£ä¸ºaæ•°ç»„åŸæœ¬æ˜¯å…¨0ï¼Œç„¶ååœ¨aæ•°ç»„ä¸Šæ’å…¥æ•°ï¼Œå³åœ¨a[i,i]ä¸Šæ’å…¥a[i][i] 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N];void insert(int l, int r, int c)//ç­‰ä»·åœ¨aä¸Šçš„[l,r]åŒºé—´çš„æ•°éƒ½åŠ ä¸Šc&#123; b[l] += c; b[r + 1] -= c;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) insert(i, i, a[i]); while (m -- ) &#123; int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for (int i = 1; i &lt;= n; i ++ ) b[i] += b[i - 1]; for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, b[i]); return 0;&#125;/*è¿˜è§è¿‡å¦å¤–ä¸€ç§å·®åˆ†æ–¹æ³•ï¼šfor (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];for (int i = n; i; i -- ) a[i] -= a[i - 1];*/ python 123456789101112131415161718192021N = 100010a = [0] * Nb = [0] * Ndef insert(l, r, c): b[l] += c b[r + 1] -= cdef main(): n, m = map(int, input().split()) a[1 : n + 1] = list(map(int, input().split())) for i in range(1, n + 1): insert(i, i, a[i]) for i in range(m): l, r, c = map(int, input().split()) insert(l, r, c) for i in range(1, n + 1): b[i] = b[i] + b[i - 1] print(&quot; &quot;.join(map(str, b[1 : n + 1])))main() äºŒç»´å·®åˆ† æ ¸å¿ƒæ€æƒ³ï¼šç»™å®šåŸçŸ©é˜µa[i,j]ï¼Œæ„é€ å·®åˆ†çŸ©é˜µb[i,j]ï¼Œä½¿å¾—aæ˜¯bçš„å‰ç¼€å’Œ æ ¸å¿ƒæ“ä½œï¼šç»™ä»¥(x1,y1)ä¸ºå·¦ä¸Šè§’,(x2,y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰æ•°åŠ ä¸Šcï¼Œå…¶å¯¹äºå·®åˆ†çŸ©é˜µçš„å½±å“æ˜¯ S[x1,y1]+=c;S[x1,y2+1]-=c;S[x2+1,y1]-=c;S[x2+1,y2+1]+=c åŒæ ·ä¸éœ€è¦æ˜¾å¼æ„é€ å·®åˆ†çŸ©é˜µï¼Œå€ŸåŠ©æ ¸å¿ƒæ“ä½œå¯å®Œæˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) insert(i, j, i, j, a[i][j]); while (q -- ) &#123; int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c); &#125; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; for (int i = 1; i &lt;= n; i ++ ) &#123; for (int j = 1; j &lt;= m; j ++ ) printf(&quot;%d &quot;, b[i][j]); puts(&quot;&quot;); &#125; return 0;&#125; python 123456789101112131415161718192021222324252627N = 1010a = [[0] * N for _ in range(N)]b = [[0] * N for _ in range(N)]def insert(x1, y1, x2, y2, c): b[x1][y1] += c b[x1][y2 + 1] -= c b[x2 + 1][y1] -= c b[x2 + 1][y2 + 1] += cdef main(): n, m, q = map(int, input().split()) for i in range(1, n + 1): a[i][1 : m + 1] = list(map(int, input().split())) for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, a[i][j]) for i in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c) for i in range(1, n + 1): for j in range(1, m + 1): b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] for i in range(1, n + 1): print(&quot; &quot;.join(map(str, b[i][1 : m + 1])))main() åŒæŒ‡é’ˆç®—æ³• å½’å¹¶æ’åºåŒæŒ‡é’ˆæŒ‡å‘ä¸¤ä¸ªæ•°ç»„ï¼Œå¿«æ’åŒæŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªæ•°ç»„ æ ¸å¿ƒæ€æƒ³ï¼šå°†æœ´ç´ çš„äºŒé‡å¾ªç¯ä¼˜åŒ–åˆ°$O(n)$ å†™çš„æ—¶å€™é¦–å…ˆå†™æœ´ç´ çš„äºŒé‡å¾ªç¯ï¼ˆå…ˆæšä¸¾ç»ˆç‚¹ï¼Œå†æšä¸¾èµ·ç‚¹ï¼‰ï¼Œç„¶åè€ƒè™‘i,jä¹‹é—´çš„å…³ç³»ï¼Œæ˜¯å¦å­˜åœ¨å•è°ƒçš„å…³ç³» !!!æ¨¡æ¿ï¼š 12345for(int i=0,j=0;i&lt;n;i++)&#123; while(j&lt;i&amp;&amp;check(i,j)) j++; //å…·ä½“é—®é¢˜çš„é€»è¾‘&#125; æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ—1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int q[N], s[N];//sç”¨æ¥åšhashçš„ï¼Œè¡¨ç¤ºæŸä¸ªæ•°çš„æ•°é‡int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); int res = 0; for (int i = 0, j = 0; i &lt; n; i ++ )//è€ƒè™‘å³è¾¹ç•Œä¸ºiçš„æœ€é•¿å­åºåˆ— &#123; s[q[i]] ++ ;//ç”±äºå·¦ä¾§ä¸€å®šæ˜¯ä¸é‡å¤çš„ï¼Œæ‰€ä»¥åªéœ€è¦è€ƒè™‘è¿›å…¥çš„æ•°æ˜¯å¦é‡å¤ while (j &lt; i &amp;&amp; s[q[i]] &gt; 1) s[q[j ++ ]] -- ;//è‹¥é‡å¤åˆ™ç´§ç¼©å·¦è¾¹ç•Œä»¥è¾¾åˆ°å»é‡ç›®çš„ res = max(res, i - j + 1);//å»é‡åå–æœ€å¤§å€¼ä½œä¸ºè¾“å‡º &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; python ï¼šç›´æ¥å¼€æ•°ç»„çš„å†™æ³•ï¼š 123456789101112131415N = 100010s = [0]*Ndef main(): n = int(input()) data = list(map(int,input().split())) res = 0 j = 0 for i in range(n): s[data[i]] += 1 while j&lt;i and s[data[i]] &gt; 1: s[data[j]] -= 1 j += 1 res = max(res, i-j+1) print(res)main() pythonï¼šé‡‡ç”¨å†…ç½®å­—å…¸çš„å†™æ³• dict.fromkeys([],0) åˆå§‹åŒ–dict 1234567891011121314def main(): n = int(input()) data = list(map(int,input().split())) d = dict.fromkeys(data,0) j = 0 res = 0 for i in range(n): d[data[i]] += 1 while d[data[i]]&gt;1 and j&lt;i: d[data[j]] -= 1 j += 1 res = max(res,i-j+1) print(res)main() æ•°ç»„å…ƒç´ çš„ç›®æ ‡å’Œè€ƒè™‘å•è°ƒæ€§å»ä¼˜åŒ–äºŒé‡æœ´ç´ å¾ªç¯ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m,x;int a[N];int b[N];int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int j=0;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;b[j]); for(int i=n-1,j=0;i&gt;=0;i--) &#123; while(j&lt;m&amp;&amp;a[i]+b[j]&lt;x) j++; if(a[i]+b[j]==x) &#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; break; &#125; &#125; return 0;&#125; python 12345678910111213def main(): n, m, x = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) j = m - 1 for i in range(n): while a[i] + b[j] &gt; x and j &gt; 0: j -= 1 if a[i] + b[j] == x: print(i, j) breakmain() åˆ¤æ–­å­åºåˆ—12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; m; i ++ ) scanf(&quot;%d&quot;, &amp;b[i]); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] == b[j]) i ++ ; j ++ ; &#125; if (i == n) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; python 123456789101112131415def main(): n, m = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) i, j = 0, 0 while i &lt; n and j &lt; m: if a[i] == b[j]: i += 1 j += 1 if i == n: print(&quot;Yes&quot;) else: print(&quot;No&quot;)main() ä½è¿ç®—æ±‚nçš„ç¬¬kä½æ•°å­—ï¼šn&gt;&gt;k&amp;1 è¿”å›nçš„æœ€åä¸€ä½ï¼šlowbit(n)=n&amp;-nï¼Œå¦‚ï¼š x=1010ï¼Œlowbit(x)=10 x=101000ï¼Œlowbit(x)=1000 äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n -- ) &#123; int x, s = 0; scanf(&quot;%d&quot;, &amp;x); for (int i = x; i; i -= i &amp; -i) s ++ ; printf(&quot;%d &quot;, s); &#125; return 0;&#125; python 12345678910def main(): n = int(input()) data = list(map(int,input().split())) for x in data: res = 0 while x: x = x - (x&amp;-x) res += 1 print(res,end=&#x27; &#x27;)main() ç¦»æ•£åŒ–å½“å€¼åŸŸè·¨åº¦å¤§ï¼Œä½†ç‚¹åˆ†å¸ƒæ¯”è¾ƒç¨€ç–æ—¶å¯ç”¨ç¦»æ•£åŒ–ï¼Œå¦‚ç»™å®šæ•°-1e10,-1,1e10ï¼Œè¯¥æ•°ä¸Šæ‰€åœ¨ä½ç½®å¯¹åº”ä¸€ä¸ªæ•°ï¼Œæ­¤æ—¶å¯ç”¨ä¸€ä¸ªæ•°ç»„ä¸­å­˜å‚¨ä¸Šè¿°åˆ—ä¸¾çš„ç¨€ç–çš„æ•°ï¼Œä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨å¯¹åº”çš„æ•° ç¦»æ•£åŒ–çš„æœ¬è´¨æ˜¯å»ºç«‹äº†ä¸€æ®µæ•°åˆ—åˆ°è‡ªç„¶æ•°ä¹‹é—´çš„æ˜ å°„å…³ç³»ï¼ˆvalue -&gt; index)ï¼Œé€šè¿‡å»ºç«‹æ–°ç´¢å¼•ï¼Œæ¥ç¼©å°ç›®æ ‡åŒºé—´ï¼Œä½¿å¾—å¯ä»¥è¿›è¡Œä¸€ç³»åˆ—è¿ç»­æ•°ç»„å¯ä»¥è¿›è¡Œçš„æ“ä½œæ¯”å¦‚äºŒåˆ†ï¼Œå‰ç¼€å’Œç­‰â€¦ ç¦»æ•£åŒ–é¦–å…ˆéœ€è¦æ’åºå»é‡ï¼š 12341. æ’åºï¼šsort(alls.begin(),alls.end())2. å»é‡ï¼šalls.earse(unique(alls.begin(),alls.end()),alls.end());unique(alls.begin(),alls.end())/*è¿”å›å»é‡æœ€åä¸€ä½æ•°ï¼Œå¤–å±‚alls.erase()åˆ å»ä»allsä¸­å»é‡çš„æœ€åä¸€ä½æ•°åˆ°allsåé¢çš„é‡å¤æ•°çš„æœ€åä¸€ä½ï¼ˆä¹Ÿå°±æ˜¯æŠŠuniqueæ“ä½œä¸­ç§»åˆ°allsæœ«å°¾çš„é‡å¤æ•°å…¨éƒ¨åˆ æ‰ï¼‰*/ unique()å‡½æ•°çš„åº•å±‚åŸç† 12345678vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a) &#123; int j = 0; for (int i = 0; i &lt; a.size(); ++i) &#123; if (!i || a[i] != a[i - 1])//å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ æˆ–è€…è¯¥å…ƒç´ ä¸ç­‰äºå‰ä¸€ä¸ªå…ƒç´ ï¼Œå³ä¸é‡å¤å…ƒç´ ï¼Œæˆ‘ä»¬å°±æŠŠå®ƒå­˜åˆ°æ•°ç»„å‰jä¸ªå…ƒç´ ä¸­ a[j++] = a[i];//æ¯å­˜åœ¨ä¸€ä¸ªä¸åŒå…ƒç´ ï¼Œj++ &#125; return a.begin() + j;//è¿”å›çš„æ˜¯å‰jä¸ªä¸é‡å¤å…ƒç´ çš„ä¸‹æ ‡&#125; åŒºé—´å’Œå»ºç«‹x-&gt;valueçš„æ˜ å°„ï¼Œä½†æ˜¯åˆä¸èƒ½æ˜¯æ•°ç»„é‚£ç§ç›´æ¥hashï¼Œæ‰€ä»¥åšæ³•æ˜¯æŠŠæ‰€æœ‰å¯èƒ½çš„ä¸‹æ ‡éƒ½è®°å½•ä¸‹æ¥ï¼Œå»é‡åï¼Œç„¶åå†å»ºç«‹ä¸€ä¸ªæ–°çš„æ•°ç»„æ¥å­˜æ”¾å›ºå®šå¥½xåçš„ä»–ä»¬çš„valueå€¼ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int n, m;int a[N], s[N];vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for (int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; // å»é‡ sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // å¤„ç†æ’å…¥ for (auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; // é¢„å¤„ç†å‰ç¼€å’Œ for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; //è¿™é‡Œå¯ä»¥ç›´æ¥ä»1å¼€å§‹æ˜¯å› ä¸ºfindå‡½æ•°è¿”å›æ—¶ä»1å¼€å§‹çš„ // å¤„ç†è¯¢é—® for (auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; pythonï¼šå› ä¸ºæŠŠqueryçš„ä¸‹æ ‡éƒ½åŠ å…¥äº†ï¼Œæ‰€ä»¥è¿™é‡Œçš„findå‡½æ•°ä¸€å®šèƒ½æ‰¾åˆ°ç›¸åŒå€¼ï¼Œå¦‚æœä¸æ’å…¥çš„è¯ï¼Œå°±éœ€è¦å†™ä¸¤ä¸ªfindå‡½æ•°åˆ†åˆ«æŸ¥æ‰¾å¤§äºç­‰äºlçš„ä¸‹æ ‡å’Œå°äºç­‰äºrçš„ä¸‹æ ‡äº† 1234567891011121314151617181920212223242526272829303132def find(k, num): l = 0 r = len(k) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if k[mid] &gt;= num: r = mid else: l = mid + 1 return l + 1def main(): n, m = map(int, input().split()) add = [list(map(int, input().split())) for _ in range(n)] query = [list(map(int, input().split())) for _ in range(m)] d = dict() for item in add: d[item[0]] = d.get(item[0], 0) + item[1] for item in query: d[item[0]] = d.get(item[0], 0) d[item[1]] = d.get(item[1], 0) d = sorted(d.items()) k = [i[0] for i in d] v = [0] + [i[1] for i in d] for i in range(1, len(v)): v[i] = v[i - 1] + v[i] for pair in query: l = find(k, pair[0]) r = find(k, pair[1]) print(v[r] - v[l - 1])main() åŒºé—´åˆå¹¶1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt;PII;int n;void merge(vector&lt;PII&gt;&amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(),segs.end()); int st=-2e9,ed=-2e9; for(auto item:segs) &#123; if(item.first&gt;ed) &#123; if(st!=-2e9) res.push_back(&#123;st,ed&#125;);//æŠŠä¸Šä¸€ä¸ªå—å‹å…¥ st=item.first,ed=item.second;//å¼€å¯ä¸€ä¸ªæ–°çš„å— &#125; else ed=max(ed,item.second);//ä¸èƒ½å¼€å¯æ–°çš„å—,æ‹“å±•è¯¥å— &#125; //æ— è®ºä¸Šè¿°ä½•ç§æƒ…å†µï¼Œæœ€åä¸€ä¸ªå—éƒ½å°šæœªå‹å…¥ if(st!=-2e9) res.push_back(&#123;st,ed&#125;); segs=res;&#125;int main()&#123; cin&gt;&gt;n; int l,r; vector&lt;PII&gt;segs; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;l&gt;&gt;r; segs.push_back(&#123;l,r&#125;); &#125; merge(segs); cout&lt;&lt;segs.size(); return 0;&#125; python 12345678910111213141516171819202122def merge(data): data.sort(key=lambda x: x[0]) st, ed = -2e9, -2e9 res = [] for item in data: if item[0] &gt; ed: if st != -2e9: res.append([st, ed]) st, ed = item else: ed = max(ed, item[1]) if st != -2e9: res.append([st, ed]) return resdef main(): n = int(input()) data = [list(map(int, input().split())) for _ in range(n)] data = merge(data) print(len(data))main() æ•°æ®ç»“æ„å•é“¾è¡¨ä¸€èˆ¬å•é“¾è¡¨çš„å®ç°ï¼šæŒ‡é’ˆ+ç»“æ„ä½“ 1234struct Node&#123; int val; Node* next;&#125;; ä½†åœ¨ç¬”è¯•é¢˜é‡Œé¢ä¸æ€ä¹ˆç”¨ï¼Œå› ä¸ºnewçš„æ—¶å€™è€—æ—¶æ¯”è¾ƒé«˜ï¼Œåœ¨é¢è¯•ä¸­å¸¸ç”¨ å•é“¾è¡¨ï¼Œç”¨å¾—æœ€å¤šçš„æ˜¯é‚»æ¥è¡¨ï¼ˆnä¸ªé“¾è¡¨ï¼‰ï¼Œå¯ç”¨äºå­˜å‚¨æ ‘å’Œå›¾ åŒé“¾è¡¨ï¼Œç”¨äºä¼˜åŒ–æŸäº›é—®é¢˜ 12int head,idx,e[N],ne[N];//åˆ†åˆ«ä¸ºå¤´æŒ‡é’ˆ,idxä¸ºä¸‹ä¸€ä¸ªèƒ½æ”¾å…¥çš„ç‚¹,eæ•°ç»„å­˜å‚¨å€¼,neæ•°ç»„å­˜å‚¨nextèŠ‚ç‚¹ã€‚nullç”¨-1è¡¨ç¤º ä¸‹é¢æ˜¯å•é“¾è¡¨çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int N = 100010;// head è¡¨ç¤ºå¤´ç»“ç‚¹çš„ä¸‹æ ‡// e[i] è¡¨ç¤ºèŠ‚ç‚¹içš„å€¼// ne[i] è¡¨ç¤ºèŠ‚ç‚¹içš„nextæŒ‡é’ˆæ˜¯å¤šå°‘// idx å­˜å‚¨å½“å‰å·²ç»ç”¨åˆ°äº†å“ªä¸ªç‚¹int head, e[N], ne[N], idx;// åˆå§‹åŒ–void init()&#123; head = -1; idx = 0;&#125;// å°†xæ’åˆ°å¤´ç»“ç‚¹void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx ++ ;&#125;// å°†xæ’åˆ°ä¸‹æ ‡æ˜¯kçš„ç‚¹åé¢void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;// å°†ä¸‹æ ‡æ˜¯kçš„ç‚¹åé¢çš„ç‚¹åˆ æ‰void remove(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int m; cin &gt;&gt; m; init(); while (m -- ) &#123; int k, x; char op; cin &gt;&gt; op; if (op == &#x27;H&#x27;) &#123; cin &gt;&gt; x; add_to_head(x); &#125; else if (op == &#x27;D&#x27;) &#123; cin &gt;&gt; k; if (!k) head = ne[head]; else remove(k - 1); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142N = 100010e = [0]*Nne = [0]*Nhead,idx = -1,0def add_to_head(x): global idx,head e[idx]=x ne[idx]=head head = idx idx +=1def add(k,x): global idx e[idx] = x ne[idx] = ne[k] ne[k]=idx idx += 1def remove(k): ne[k]=ne[ne[k]]def main(): global idx,head m = int(input()) for i in range(m): op = input().split() if op[0]==&#x27;H&#x27;: x = int(op[1]) add_to_head(x) elif op[0]==&#x27;D&#x27;: k = int(op[1]) if k==0: head = ne[head] else: remove(k-1) else: k,x = int(op[1]),int(op[2]) add(k-1,x) i = head while i!=-1: print(e[i],end = &#x27; &#x27;) i = ne[i]main() åŒé“¾è¡¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;const int N=100010;int e[N],l[N],r[N],idx,m;void init()&#123; r[0]=1; l[1]=0; idx=2;&#125;//åœ¨ä¸‹æ ‡kåé¢æ’å…¥xvoid insert(int k,int x)&#123; e[idx]=x; l[idx]=k; r[idx]=r[k]; l[r[k]]=idx; r[k]=idx; idx++;&#125;void remove(int k)&#123; l[r[k]]=l[k]; r[l[k]]=r[k];&#125;int main()&#123; cin&gt;&gt;m; init(); while(m--) &#123; string op; int x,k; cin&gt;&gt;op; if(op==&quot;L&quot;) &#123; cin&gt;&gt;x; insert(0,x); &#125; else if(op==&quot;R&quot;) &#123; cin&gt;&gt;x; insert(l[1],x); &#125; else if(op==&quot;D&quot;) &#123; cin&gt;&gt;k; remove(k+1); &#125; else if(op==&quot;IL&quot;) &#123; cin&gt;&gt;k&gt;&gt;x; insert(l[k+1],x); &#125;else &#123; cin&gt;&gt;k&gt;&gt;x; insert(k+1,x); &#125; &#125; for(int i=r[0];i!=1;i=r[i]) &#123; cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950N = 100010e = [0] * Nl = [0] * Nr = [0] * Nidx = 2def init(): r[0] = 1 l[1] = 0def insert(k, x): global idx e[idx] = x l[r[k]] = idx r[idx] = r[k] l[idx] = k r[k] = idx idx += 1def remove(k): l[r[k]] = l[k] r[l[k]] = r[k]def main(): global idx init() m = int(input()) for i in range(m): op = input().split() if op[0] == &quot;L&quot;: x = int(op[1]) insert(0, x) elif op[0] == &quot;R&quot;: x = int(op[1]) insert(l[1], x) elif op[0] == &quot;D&quot;: k = int(op[1]) remove(k + 1) elif op[0] == &quot;IL&quot;: k, x = int(op[1]), int(op[2]) insert(l[k + 1], x) else: k, x = int(op[1]), int(op[2]) insert(k + 1, x) i = r[0] while i != 1: print(e[i], end=&quot; &quot;) i = r[i]main() æ ˆ123456789101112131415161718#include &lt;iostream&gt;using namespace std;const int N=100010;// *********æ ˆint stk[N],tt;//ttè¡¨ç¤ºæ ˆé¡¶(æ˜¯æŒ‡å‘ä¸€ä¸ªå…ƒç´ çš„)// æ’å…¥stk[++tt]=x;// å¼¹å‡ºtt--;//åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºif(tt&gt;0) not emptyelse empty//æ ˆé¡¶stk[tt]; æ¨¡æ‹Ÿæ ˆ1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=100010;int m;int stk[N],tt;int main()&#123; cin&gt;&gt;m; while(m--) &#123; string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;) &#123; cin&gt;&gt;x; stk[++tt]=x; &#125;else if(op==&quot;pop&quot;) &#123; tt--; &#125;else if(op==&quot;empty&quot;) &#123; cout&lt;&lt;(tt?&quot;NO&quot;:&quot;YES&quot;)&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;stk[tt]&lt;&lt;endl; &#125; &#125; return 0;&#125; pythonï¼šå€ŸåŠ©pythonç‰¹æ€§ç®€åŒ–ä¸€ä¸‹ 123456789101112131415def main(): m = int(input()) stk = [] for i in range(m): op = input().split() if op[0] == &#x27;push&#x27;: x = int(op[1]) stk.append(x) elif op[0] == &#x27;pop&#x27;: stk.pop() elif op[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(stk) else &#x27;YES&#x27;) else: print(stk[-1])main() è¡¨è¾¾å¼æ±‚å€¼å¦‚æœæ‰€æœ‰å­—ç¬¦çš„è¿ç®—é¡ºåºéƒ½ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´ä»å·¦å¾€å³ç®—å’Œä»å³å¾€å·¦ç®—éƒ½æ— åŒºåˆ«ï¼Œé‚£æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æ•°å­—å‹è¿›æ ˆä¸­ï¼Œæ‰€æœ‰æ“ä½œç¬¦å‹è¿›æ ˆä¸­ï¼Œç„¶ååševalæ“ä½œï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰æƒ…å†µæˆ‘ä»¬éƒ½å¯ä»¥ä»åå¾€å‰ç›´æ¥ç®—çš„ å¦‚æœå‰é¢è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§é«˜çš„è¯æˆ–è€…ç›¸ç­‰ï¼ˆè¿ç®—ç¬¦ä¼˜å…ˆçº§ç›¸ç­‰çš„è¯ä»å·¦å¾€å³ç®—ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»å…ˆç®—å‰é¢çš„æ“ä½œï¼Œå¦‚3*5-2ï¼Œå°±ä¸èƒ½å…ˆç®—5-2 å¦‚æœå‰é¢æœ‰æ‹¬å·ï¼Œå°±å¿…é¡»å…ˆç®—æ‹¬å·é‡Œçš„ï¼Œå¦‚(3-2)*5ï¼Œå°±ä¸èƒ½å…ˆç®—2*5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt;num;stack&lt;char&gt;op;void eval()&#123; auto b=num.top();num.pop();//bæ˜¯å³è¾¹çš„ auto a=num.top();num.pop();//aæ˜¯å·¦è¾¹çš„ auto c=op.top();op.pop(); int x; if(c==&#x27;+&#x27;) x=a+b; else if(c==&#x27;-&#x27;) x=a-b; else if(c==&#x27;*&#x27;) x=a*b; else x=a/b; num.push(x);&#125;int main()&#123; unordered_map&lt;char,int&gt; pr&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;&#125;;//ä¼˜å…ˆçº§å®šä¹‰ string str; cin&gt;&gt;str; for(int i=0;i&lt;str.size();i++) &#123; auto c=str[i]; if(isdigit(c))//æ•°å­—åˆ™æ„é€ æ•°å­— &#123; int x=0,j=i; while(j&lt;str.size()&amp;&amp;isdigit(str[j]))//æ„é€ x x=x*10+str[j++]-&#x27;0&#x27;; i=j-1; num.push(x); &#125; else if(c==&#x27;(&#x27;) op.push(c);//å¤„ç†æ‹¬å· else if(c==&#x27;)&#x27;)//å¤„ç†æ‹¬å·å‰ç®—çš„æƒ…å†µ &#123; while(op.top()!=&#x27;(&#x27;) eval(); op.pop(); &#125; else//å¤„ç†ä¼˜å…ˆçº§å‰ç®—çš„æƒ…å†µ &#123; while(op.size()&amp;&amp;op.top()!=&#x27;(&#x27;&amp;&amp;pr[op.top()]&gt;=pr[c]) eval();//ç®—å®Œå‰é¢çš„ op.push(c); &#125; &#125; while(op.size()) eval();//æ¥ä¸‹æ¥å°±æ²¡æœ‰å¼‚å¸¸æƒ…å†µäº†ï¼Œå¯ä»¥ç›´æ¥ç®—äº† cout&lt;&lt;num.top()&lt;&lt;endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142434445pr = &#123;&quot;+&quot;: 1, &quot;-&quot;: 1, &quot;*&quot;: 2, &quot;/&quot;: 2&#125;num = []op = []def myeval(): b = num.pop() a = num.pop() c = op.pop() x = 0 if c == &quot;+&quot;: x = a + b elif c == &quot;-&quot;: x = a - b elif c == &quot;*&quot;: x = a * b else: x = int(a / b) num.append(x)def main(): exp = input() i = 0 while i &lt; len(exp): if exp[i].isdigit(): j = i while j &lt; len(exp) and exp[j].isdigit(): j += 1 num.append(int(exp[i:j])) i = j - 1 elif exp[i] == &quot;(&quot;: op.append(exp[i]) elif exp[i] == &quot;)&quot;: while op[-1] != &quot;(&quot;: myeval() op.pop() else: while len(op) and op[-1] != &quot;(&quot; and pr[op[-1]] &gt;= pr[exp[i]]: myeval() op.append(exp[i]) i += 1 while len(op): myeval() print(num[-1])main() é˜Ÿåˆ—æ ˆå’Œé˜Ÿåˆ—ä¹¦å†™æ€è·¯å¯¹æ¯”ï¼š 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N=100010;// *********æ ˆint stk[N],tt;//ttè¡¨ç¤ºæ ˆé¡¶(æ˜¯æŒ‡å‘ä¸€ä¸ªå…ƒç´ çš„)// æ’å…¥stk[++tt]=x;// å¼¹å‡ºtt--;//åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºif(tt&gt;0) not emptyelse empty//æ ˆé¡¶stk[tt];//*********é˜Ÿåˆ—int q[N],hh,tt=-1;//hhä¸ºé˜Ÿå¤´ï¼Œttä¸ºé˜Ÿå°¾(åŒ…å«å…ƒç´ çš„),hhä¸ºé˜Ÿå¤´(åŒæ ·åŒ…å«å…ƒç´ ),é˜Ÿå¤´åœ¨ä½ä½ï¼Œé˜Ÿå°¾åœ¨é«˜ä½//æ’å…¥q[++tt]=x;//å¼¹å‡ºhh++;//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºif(hh&lt;=tt) not emptyelse empty//å–å‡ºé˜Ÿå¤´å…ƒç´ q[hh] //å–å‡ºé˜Ÿå°¾å…ƒç´ q[tt] æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œä»£ç ï¼š 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int q[N], hh, tt = -1;int main()&#123; cin &gt;&gt; m; while (m -- ) &#123; string op; int x; cin &gt;&gt; op; if (op == &quot;push&quot;) &#123; cin &gt;&gt; x; q[ ++ tt] = x; &#125; else if (op == &quot;pop&quot;) hh ++ ; else if (op == &quot;empty&quot;) cout &lt;&lt; (hh &lt;= tt ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl; else cout &lt;&lt; q[hh] &lt;&lt; endl; &#125; return 0;&#125; pythonç‰ˆæœ¬ å†™æ³•1ï¼šæ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜ï¼Œå› ä¸ºappend(op[1]) 123456789101112131415q = []def main(): num = int(input()) for i in range(num): op = input().split() ch = op[0] if ch == &#x27;push&#x27;: q.append(op[1]) elif ch == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(q) else &#x27;YES&#x27;) elif ch == &#x27;pop&#x27;: q.pop(0) else: print(q[0])main() å†™æ³•2ï¼šé™ä½äº†æ—¶é—´å¤æ‚åº¦ 123456789101112131415161718q = []def main(): hh,tt = 0,-1 num = int(input()) for i in range(num): op = input().split() ch = op[0] if ch == &#x27;push&#x27;: tt += 1 q.append(op[1]) elif ch == &#x27;pop&#x27;: hh += 1 elif ch == &#x27;empty&#x27;: print(&#x27;NO&#x27; if tt&gt;=hh else &#x27;YES&#x27;) else: print(q[hh])main() å†™æ³•ä¸‰ï¼špythonåº“ 123456789101112131415from collections import dequedef main(): q = deque() num = int(input()) for i in range(num): op = input().split() if op[0] == &#x27;push&#x27;: q.append(op[1]) elif op[0] == &#x27;pop&#x27;: q.popleft() elif op[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(q) else &#x27;YES&#x27;) else: print(q[0])main() å•è°ƒæ ˆè‹¥a[x]&gt;=a[y]ä¸”x&gt;yï¼Œåˆ™a[x]å¯ä»¥è¢«æ›¿æ¢ä¸ºyï¼Œæ•…å¦‚æœç”¨stkæ ˆç»“æ„æ¥å­˜å‚¨ä¸€ä¸ªæ•°å‰é¢çš„æ•°ï¼š è‹¥å½“å‰æ•°ä¸‹æ ‡ä¸º5ï¼Œç›®å‰æ ˆå†…çš„æ•°ä¸‹æ ‡ä¸º1~4ï¼Œç”±ä¸Šè¿°è¯´æ³•å¯çŸ¥ï¼Œå·¦ä¾§æ ‡çš„ä¸‰ä¸ªçº¢è‰²åœˆçš„æ•°éƒ½æ˜¯æ— æ•ˆçš„ï¼Œæ•…å¯è¢«æ›¿æ¢ä¸ºæ–°çš„æ•°ï¼Œæœ€ç»ˆå½¢æˆçº¢è‰²çš„çº¿ï¼Œå®è´¨ä¸Šæ˜¯ç»´æŒæ ˆä¸­å…ƒç´ éšç€ä¸‹æ ‡å•è°ƒé€’å¢ï¼Œä¸èƒ½å‡ºç°ä¸‹æŠ˜æˆ–è€…ç›´çº¿çš„æƒ…å†µ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N = 100010;int stk[N], tt;int main()&#123; int n; cin &gt;&gt; n; while (n -- ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); while (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;//è‹¥é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œä¸”æ ˆé¡¶å¤§äºç­‰äºxï¼Œæ ˆé¡¶å°†ä¸ä¼šå†è¢«ç”¨åˆ° if (!tt) printf(&quot;-1 &quot;); else printf(&quot;%d &quot;, stk[tt]);//è‹¥æ‰¾åˆ°stk[tt]&lt;x,æ»¡è¶³å•è°ƒæ ˆ stk[ ++ tt] = x; &#125; return 0;&#125; pythonç‰ˆæœ¬ï¼š 12345678910111213141516N = 100010stk = [0]*Ndef main(): tt = -1 num = int(input()) lst = list(map(int,input().split())) for i in range(num): while tt&gt;=0 and stk[tt]&gt;= lst[i]: tt -= 1 if tt &lt; 0: print(-1,end=&#x27; &#x27;) else: print(stk[tt],end=&#x27; &#x27;) tt += 1 stk[tt] = lst[i]main() å•è°ƒé˜Ÿåˆ—æ»‘åŠ¨é˜Ÿåˆ—123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=10000010;int a[N],q[N];int n,k;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int hh=0,tt=-1; for(int i=0;i&lt;n;i++) &#123; //i-k+1~iæ˜¯å½“å‰é˜Ÿåˆ— if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;//é¦–å…ˆè¸¢æ‰ä¸åœ¨é˜Ÿåˆ—ä¸­çš„ while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//ä¿æŒé˜Ÿå¤´åˆ°é˜Ÿå°¾é€’å¢ q[++tt]=i; //å‰é¢ä¸€æˆªæ˜¯ä¸å¤Ÿé˜Ÿåˆ—çš„ if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]); &#125; puts(&quot;&quot;); hh=0,tt=-1; for(int i=0;i&lt;n;i++) &#123; if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++; while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--; q[++tt]=i; if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]); &#125; return 0;&#125; pythonï¼š 123456789101112131415161718192021222324252627282930N = 1000010q = [0]*Ndef main(): hh,tt = 0,-1 n,k = map(int,input().split()) a = list(map(int,input().split())) res = [] for i in range(n): while tt&gt;=hh and q[hh]&lt;i-k+1: hh += 1 while tt&gt;=hh and a[q[tt]]&gt;=a[i]: tt -= 1 tt += 1 q[tt] = i if i-k+1&gt;=0: res.append(a[q[hh]]) print(&#x27; &#x27;.join(map(str,res))) res.clear() hh,tt = 0,-1 for i in range(n): while tt&gt;=hh and q[hh]&lt;i-k+1: hh += 1 while tt&gt;=hh and a[q[tt]]&lt;=a[i]: tt -= 1 tt += 1 q[tt] = i if i-k+1&gt;=0: res.append(a[q[hh]]) print(&#x27; &#x27;.join(map(str,res)))main() dequeï¼š 123456789101112131415161718192021222324252627from collections import dequeq = deque()res = []def main(): n,k = map(int,input().split()) a = list(map(int,input().split())) for i in range(n): while len(q)&gt;0 and i-k+1&gt;q[0]: q.popleft() while len(q)&gt;0 and a[q[-1]]&gt;=a[i]: q.pop() q.append(i) if i-k+1&gt;=0: res.append(a[q[0]]) print(&#x27; &#x27;.join(map(str,res))) res.clear() q.clear() for i in range(n): while len(q)&gt;0 and i-k+1&gt;q[0]: q.popleft() while len(q)&gt;0 and a[q[-1]]&lt;=a[i]: q.pop() q.append(i) if i-k+1&gt;=0: res.append(a[q[0]]) print(&#x27; &#x27;.join(map(str,res)))main() KMPå‰åç¼€ç­‰é•¿ç›¸ç­‰ p[1,j]=p[i-j+1,i] é¦–å…ˆæ˜ç¡®å‰åç¼€çš„å«ä¹‰ï¼Œç„¶åæ˜ç¡®nextæ•°ç»„çš„å«ä¹‰ æ³¨æ„æ€»æ˜¯ç”¨iå’Œj+1è¿›è¡ŒåŒ¹é… 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1e6+10;char p[N],s[N];int n,m;int ne[N];int main()&#123; cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;//ä¹ æƒ¯ä»1å¼€å§‹ for(int i=2,j=0;i&lt;=n;i++)//iä»2å¼€å§‹æ˜¯å› ä¸ºå¦‚æœç¬¬ä¸€ä½ä¸åŒ¹é…æ— æ³•å†é€€äº†,è¯¥å¾ªç¯è®¡ç®—ne[i] &#123; while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];//å¦‚æœjè¿˜æœ‰é€€è·¯,å³&gt;0,ä¸”éœ€è¦é€€,åˆ™é€€ if(p[i]==p[j+1]) j++;//è‹¥åŒ¹é…ä¸Šäº† ne[i]=j;//è®°å½• &#125; for(int i=1,j=0;i&lt;=m;i++)//è¿›è¡ŒåŒ¹é…,ä»å¾…åŒ¹é…ä¸²çš„ç¬¬ä¸€ä½å¼€å§‹åŒ¹é… &#123; while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j]; if(s[i]==p[j+1]) j++; if(j==n) &#123; cout&lt;&lt;i-n&lt;&lt;&quot; &quot;; &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324def main(): n = int(input()) p = &#x27; &#x27; + input() m = int(input()) s = &#x27; &#x27; + input() N = 100010 ne = [0] * N j = 0 for i in range(2,n+1): while j and p[i]!=p[j+1]: j = ne[j] if p[i] == p[j+1]: j += 1 ne[i] = j j = 0 for i in range(1,m+1): while j and s[i]!=p[j+1]: j = ne[j] if s[i] == p[j+1]: j += 1 if j == n: print(i-n+1-1,end =&#x27; &#x27;) j = ne[j] # å€ŸåŠ©å·²æœ‰ä¼˜åŠ¿ç»§ç»­åŒ¹é…main() Trie Trieï¼šé«˜æ•ˆåœ°å­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²ï¼Œæ˜¯ä¸€ä¸ªé›†åˆçš„æ•°æ®ç»“æ„ Trieæ ‘ä¸­æœ‰ä¸ªäºŒç»´æ•°ç»„ son[N][26]ï¼Œè¡¨ç¤ºå½“å‰ç»“ç‚¹çš„å„¿å­ï¼Œå¦‚æœæ²¡æœ‰çš„è¯ï¼Œå¯ä»¥ç­‰äº++idxã€‚Trieæ ‘æœ¬è´¨ä¸Šæ˜¯ä¸€é¢—å¤šå‰æ ‘ï¼Œå¯¹äºå­—æ¯è€Œè¨€æœ€å¤šæœ‰26ä¸ªå­ç»“ç‚¹ã€‚æ‰€ä»¥è¿™ä¸ªæ•°ç»„åŒ…å«äº†ä¸¤æ¡ä¿¡æ¯ã€‚æ¯”å¦‚ï¼šson[1][0]=2è¡¨ç¤º1ç»“ç‚¹çš„ä¸€ä¸ªå€¼ä¸ºaçš„å­ç»“ç‚¹ä¸ºç»“ç‚¹2;å¦‚æœson[1][0] = 0ï¼Œåˆ™æ„å‘³ç€æ²¡æœ‰å€¼ä¸ºaå­ç»“ç‚¹ã€‚è¿™é‡Œçš„son[N]/[26]ç›¸å½“äºé“¾è¡¨ä¸­çš„ne[N]ã€‚ 1234567891011void insert(char str[])&#123; int p = 0; //ä»æ ¹ç»“ç‚¹å¼€å§‹éå† for (int i = 0; str[i]; i ++ ) &#123; int u =str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; //æ²¡æœ‰è¯¥å­ç»“ç‚¹å°±åˆ›å»ºä¸€ä¸ª p = son[p][u]; //èµ°åˆ°pçš„å­ç»“ç‚¹ &#125; cnt[p] ++; // cntç›¸å½“äºé“¾è¡¨ä¸­çš„e[idx]&#125; Trieæ ‘å­—ç¬¦ä¸²ç»Ÿè®¡12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int son[N][26],cnt[N],idx;int n;char str[N];void insert(char*str)&#123; int p=0; for(int i=0;str[i];i++) &#123; int u=str[i]-&#x27;a&#x27;; if(son[p][u]==0) son[p][u]=++idx; p=son[p][u]; &#125; cnt[p]++;&#125;int query(char*str)&#123; int p=0; for(int i=0;str[i];i++) &#123; int u=str[i]-&#x27;a&#x27;; if(son[p][u]==0) return 0; p=son[p][u]; &#125; return cnt[p];&#125;int main()&#123; cin&gt;&gt;n; char op[2]; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%s%s&quot;,op,str); if(*op==&#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;,query(str)); &#125; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233N = 100010son = [[0]*26 for _ in range(N)]cnt = [0]*Nidx = 0def insert(exp): global idx p = 0 for ch in exp: u = ord(ch) - ord(&#x27;a&#x27;) if son[p][u] == 0: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1def query(exp): global idx p = 0 for ch in exp: u = ord(ch) - ord(&#x27;a&#x27;) if son[p][u] == 0: return 0 p = son[p][u] return cnt[p]def main(): n = int(input()) for i in range(n): op,ch = input().split() if op == &#x27;I&#x27;: insert(ch) else: res = query(ch) print(res)main() æœ€å¤§å¼‚æˆ–å¯¹æœ‰ç‚¹è´ªå¿ƒçš„å‘³é“ è¿™é“é¢˜çš„å¯ç¤ºæ˜¯ï¼šå­—å…¸æ ‘ä¸å•å•å¯ä»¥é«˜æ•ˆå­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²é›†åˆ,è¿˜å¯ä»¥å­˜å‚¨äºŒè¿›åˆ¶æ•°å­—æ€è·¯:å°†æ¯ä¸ªæ•°ä»¥äºŒè¿›åˆ¶æ–¹å¼å­˜å…¥å­—å…¸æ ‘,æ‰¾çš„æ—¶å€™ä»æœ€é«˜ä½å»æ‰¾æœ‰æ— è¯¥ä½çš„å¼‚. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N=100010,M=3100010;int n;int son[M][2],idx,a[N];void insert(int x)&#123; int p=0; for(int i=30;i&gt;=0;i--) &#123; int u=x&gt;&gt;i&amp;1; if(!son[p][u]) son[p][u]=++idx; p=son[p][u]; &#125;&#125;int search(int x)&#123; int p=0,res=0; for(int i=30;i&gt;=0;i--) &#123; int u=x&gt;&gt;i&amp;1; if(son[p][!u]) &#123; res+=1&lt;&lt;i; p=son[p][!u]; &#125;else p=son[p][u]; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; insert(a[i]); &#125; int res=0; for(int i=0;i&lt;n;i++) &#123; res=max(res,search(a[i])); &#125; cout&lt;&lt;res; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536N = 3100010son = [[0]*2 for _ in range(N)]idx = 0def insert(exp): global idx p = 0 for i in range(30,-1,-1): u = exp&gt;&gt;i&amp;1 if son[p][u] == 0: idx += 1 son[p][u] = idx p = son[p][u]def query(exp): global idx p = 0 res = 0 for i in range(30,-1,-1): u = exp&gt;&gt;i&amp;1 if son[p][1^u] == 0: p = son[p][u] else: res += 1&lt;&lt;i p = son[p][1^u] return res def main(): n = int(input()) lst = list(map(int,input().split())) for item in lst: insert(item) res = 0 for item in lst: res = max(res,query(item)) print(res)main() å¹¶æŸ¥é›†å¹¶æŸ¥é›†ï¼š å°†ä¸¤ä¸ªé›†åˆåˆå¹¶ è¯¢é—®ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ä¸ªé›†åˆä¸­ åŸºæœ¬åŸç†ï¼šæ¯ä¸ªé›†åˆç”¨ä¸€æ£µæ ‘æ¥è¡¨ç¤ºã€‚æ ‘æ ¹çš„ç¼–å·å°±æ˜¯æ•´ä¸ªé›†åˆçš„ç¼–å·ã€‚æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä»–çš„çˆ¶èŠ‚ç‚¹ï¼Œp[x]è¡¨ç¤ºxçš„çˆ¶èŠ‚ç‚¹ é—®é¢˜ä¸€ï¼šå¦‚ä½•åˆ¤æ–­æ ‘æ ¹ï¼šif(p[x]==x) é—®é¢˜äºŒï¼šå¦‚ä½•æ±‚xçš„é›†åˆç¼–å·ï¼šwhile(p[x]!=x) x=p[x]; é—®é¢˜ä¸‰ï¼šå¦‚ä½•åˆå¹¶ä¸¤ä¸ªé›†åˆï¼šå‡è®¾p[x]æ˜¯xçš„é›†åˆç¼–å·ï¼Œp[y]æ˜¯yçš„é›†åˆç¼–å·ã€‚åˆå¹¶ï¼šp[x]=y è¿‘ä¹O(1)çš„æ•ˆç‡å®Œæˆä¸Šè¿°ä¸¤ä¸ªæ“ä½œ ä¼˜åŒ–â€”â€”è·¯å¾„å‹ç¼©ï¼šå¯¹é—®é¢˜äºŒæ‰¾æ ¹çš„è¿‡ç¨‹è¿›è¡Œä¼˜åŒ–ï¼Œä¸€æ—¦å¾€ä¸Šèµ°çš„è¿‡ç¨‹ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œåˆ™æŠŠè·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„çš„æ ¹èŠ‚ç‚¹æŒ‡å‘æ ¹ï¼ˆè¿™æ ·å°±èƒ½å®ç°O(1)ï¼‰ åˆå¹¶é›†åˆ123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int p[N];int find(int x)//å¯»æ‰¾xç‚¹çš„æ ¹èŠ‚ç‚¹&#123; if(p[x]!=x) p[x]=find(p[x]);//è·¯å¾„å‹ç¼© return p[x];&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) p[i]=i;//å¼€å§‹æ—¶æ¯ä¸ªç‚¹éƒ½æ˜¯ç‹¬ç«‹çš„ char op[2]; int a,b; while(m--)//è¿›è¡Œmä¸ªæ“ä½œ &#123; scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b); if(*op==&#x27;M&#x27;) p[find(a)]=find(b); else&#123; if(find(a)==find(b)) cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324N = 100010p = [0]*Ndef find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return xdef main(): n,m = map(int,input().split()) for i in range(1,n+1): p[i] = i for i in range(m): op,a,b = input().split() a,b =int(a),int(b) if op == &#x27;M&#x27;: p[find(a)] = find(b) else: if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() è¿é€šå—ä¸­ç‚¹çš„æ•°é‡ä¸ä¸Šé¢˜ç±»ä¼¼ï¼Œä¸åŒä¹‹å¤„éœ€è¦è®°å½•æ•°é‡ï¼Œè¿™é‡Œè§„å®šåªæœ‰æ ¹èŠ‚ç‚¹çš„æ•°é‡å±æ€§æ˜¯æœ‰æ•ˆçš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m;int p[N],cnt[N];//cntè®°å½•æ•°é‡ï¼Œåªå¯¹æ ¹èŠ‚ç‚¹æœ‰æ•ˆint find(int x)&#123; if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; p[i]=i; cnt[i]=1; &#125; while(m--) &#123; string op; int a,b; cin&gt;&gt;op; if(op==&quot;C&quot;)//è¿é€š &#123; cin&gt;&gt;a&gt;&gt;b; a=find(a),b=find(b); if(a!=b) &#123; p[a]=b; cnt[b]+=cnt[a]; &#125; &#125; else if(op==&quot;Q1&quot;)//æŸ¥è¯¢æ˜¯å¦è¿é€š &#123; cin&gt;&gt;a&gt;&gt;b; if(find(a)==find(b)) cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; &#125;else&#123;//æŸ¥è¯¢è¿é€šé›† cin&gt;&gt;a; cout&lt;&lt;cnt[find(a)]&lt;&lt;endl; &#125; &#125; return 0;&#125; python 1234567891011121314151617181920212223242526272829N = 100010p = [0]*Ncnt = [1]*Ndef find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return p[x]def main(): n,m = map(int,input().split()) for i in range(1,n+1): p[i] = i for i in range(m): op = input().split() if op[0] == &#x27;C&#x27;: a = find(int(op[1])) b = find(int(op[2])) if a!=b: p[a] = b cnt[b] += cnt[a] elif op[0] == &#x27;Q1&#x27;: if find(int(op[1])) == find(int(op[2])): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) else: print(cnt[find(int(op[1]))])main() é£Ÿç‰©é“¾ find(x)æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼š 1 è·¯å¾„å‹ç¼©, 2 æ›´æ–° d[x]å‡è®¾æœ‰ä¸€æ£µæ ‘ a -&gt; b -&gt; c -&gt; dï¼Œ æ ¹èŠ‚ç‚¹ä¸º dã€‚d[b]ä¸€å¼€å§‹ç­‰äº bã€c ä¹‹é—´çš„è·ç¦»ï¼Œå†æ‰§è¡Œå®Œè·¯å¾„å‹ç¼©å‘½ä»¤ä¹‹åï¼Œd[b] ç­‰äºbã€dä¹‹é—´çš„è·ç¦»ã€‚ d[a] += d[b]: ä¸ºäº†ç¡®ä¿d[a]ç­‰äº èŠ‚ç‚¹aã€dçš„è·ç¦»ï¼Œd[b]å¿…é¡»ç­‰äºb ã€dçš„è·ç¦»ï¼Œæ‰€ä»¥è¦å…ˆè°ƒç”¨find(b)æ›´æ–°d[b]ï¼Œ åŒæ—¶p[x] = find(b)ä¼šæ”¹å˜p[x]çš„å€¼ï¼Œç»“æœå°±ä¼šå˜æˆd[a] += d[d],æ‰€ä»¥å…ˆç”¨ä¸€ä¸ªå˜é‡æŠŠp[a]çš„å€¼å­˜èµ·æ¥ã€‚ å…³é”®å°±æ˜¯æ—¢è¦å…ˆæ‰§è¡Œfind(p[x])ï¼Œ åˆè¦è®©d[x] += d[p[x]]ä¸­p[x]çš„å€¼ä¿æŒä¸å˜ï¼Œæ‰€ä»¥ä»£ç è¿˜å¯ä»¥è¿™ä¹ˆå†™ è¿™é“é¢˜çš„æ’å…¥æ–¹å¼éœ€è¦æ³¨æ„ï¼Œä¸”ä½¿ç”¨è·ç¦»æ¥ä½“ç°ä¸æ ¹èŠ‚ç‚¹çš„å…³ç³»ï¼Œd%3çš„æƒ…å†µå¦‚ä¸‹ï¼š =0ï¼Œåˆ™ä¸æ ¹èŠ‚ç‚¹åŒç±»å‹ =1ï¼Œä¸€å±‚èŠ‚ç‚¹ï¼Œå¯ä»¥åƒæ‰æ ¹èŠ‚ç‚¹ï¼Œå¯ä»¥è¢«äºŒå±‚èŠ‚ç‚¹åƒ =2ï¼ŒäºŒå±‚èŠ‚ç‚¹ï¼Œå¯ä»¥åƒæ‰ä¸€å±‚èŠ‚ç‚¹ï¼Œå¯ä»¥è¢«é›¶å±‚èŠ‚ç‚¹ï¼ˆæ ¹èŠ‚ç‚¹åŒç±»å‹ï¼‰åƒ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;const int N=50010;int n,m;int p[N],d[N];int find(int x)&#123; if(p[x]!=x) &#123; int t=find(p[x]); d[x]+=d[p[x]]; p[x]=t; &#125; return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i]=i; int res=0; while(m--) &#123; int t,x,y; scanf(&quot;%d%d%d&quot;,&amp;t,&amp;x,&amp;y); if(x&gt;n||y&gt;n) res++; else&#123; int px=find(x),py=find(y);//æ‰¾åˆ°xå’Œyçš„æ ¹èŠ‚ç‚¹ if(t==1)//ä¸¤è€…åŒç±» &#123; //è‹¥ç›¸åŒæ ¹ï¼Œè¯´æ˜ä¹‹å‰æ„é€ è¿‡ï¼Œåˆ™è‹¥ä¸åŒç±»(d[x]-d[y]%3!=0) //åˆ™æ˜¯éæ³•çš„ if(px==py&amp;&amp;(d[x]-d[y])%3) res++; else if(px!=py) &#123;//è‹¥ä¸åŒæ ¹ï¼Œè¯´æ˜è¿™æ˜¯ç¬¬ä¸€æ¬¡ï¼Œéœ€è¦è¿›è¡Œæ„é€  p[px]=py; d[px]=d[y]-d[x];//éœ€è¦å¼¥è¡¥x-&gt;px-&gt;yçš„ç¬¬äºŒæ®µçš„é•¿åº¦d[x]+d[px]=d[y] &#125; &#125; else&#123;//ä¸º2çš„æƒ…å†µï¼Œxå¯ä»¥åƒy //è‹¥px==pyï¼Œè¯´æ˜ä¹‹å‰æ„é€ è¿‡ï¼Œåˆ™è‹¥ä¸æ˜¯xåƒyçš„å…³ç³»((d[x]-d[y]-1)%3)=0 //åˆ™æ˜¯éæ³•çš„ if(px==py&amp;&amp;(d[x]-d[y]-1)%3) res++; else if(px!=py) &#123;//è‹¥æ˜¯ä¸åŒæ ¹ï¼Œè¯´æ˜è¿™æ˜¯ç¬¬ä¸€æ¬¡ï¼Œéœ€è¦è¿›è¡Œæ„é€  p[px]=py; //æ»¡è¶³d[y]+1=d[x]+d[px],å³å°†xçš„æ ¹èŠ‚ç‚¹ä½œä¸ºyçš„æ ¹èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¹‹å //è¿˜è¦æ»¡è¶³åƒçš„å…³ç³»ï¼ˆxæ¯”yä¸‹ä¸€å±‚ï¼‰ d[px]=d[y]+1-d[x]; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; å¦å¤–ä¸€ç§æ›´åŠ å®¹æ˜“ç†è§£çš„åšæ³•ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def main(): # è¯»å–è¾“å…¥çš„ N å’Œ K n, k = map(int, input().split()) # åˆå§‹åŒ–å¹¶æŸ¥é›†å’Œå…³ç³»æ•°ç»„ parent = [i for i in range(n + 1)] # çˆ¶èŠ‚ç‚¹æ•°ç»„ relation = [0] * (n + 1) # å…³ç³»æ•°ç»„ï¼Œ0: åŒç±», 1: åƒçˆ¶èŠ‚ç‚¹, 2: è¢«çˆ¶èŠ‚ç‚¹åƒ false_count = 0 # å‡è¯è®¡æ•°å™¨ # æŸ¥æ‰¾å‡½æ•°ï¼Œå¸¦è·¯å¾„å‹ç¼©å’Œå…³ç³»æ›´æ–° def find(x): if parent[x] != x: original_parent = parent[x] # è®°å½•åŸæ¥çš„çˆ¶èŠ‚ç‚¹ parent[x] = find(parent[x]) # é€’å½’æ‰¾åˆ°æ ¹èŠ‚ç‚¹ # æ›´æ–°å…³ç³»ï¼šå½“å‰èŠ‚ç‚¹çš„å…³ç³» = (å½“å‰èŠ‚ç‚¹ä¸åŸæ¥çˆ¶èŠ‚ç‚¹çš„å…³ç³» + åŸæ¥çˆ¶èŠ‚ç‚¹ä¸æ ¹èŠ‚ç‚¹çš„å…³ç³») % 3 relation[x] = (relation[x] + relation[original_parent]) % 3 return parent[x] # åˆå¹¶å‡½æ•°ï¼Œå¤„ç†ä¸¤ç§å…³ç³»ï¼ˆåŒç±»æˆ–æ•é£Ÿï¼‰ def union(x, y, d): root_x = find(x) # æ‰¾åˆ° x çš„æ ¹èŠ‚ç‚¹ root_y = find(y) # æ‰¾åˆ° y çš„æ ¹èŠ‚ç‚¹ if root_x == root_y: # å¦‚æœ x å’Œ y å·²ç»åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼Œæ£€æŸ¥å…³ç³»æ˜¯å¦å†²çª if (relation[x] - relation[y] + 3) % 3 != d - 1: return False # å†²çªï¼Œè¿”å› False else: return True # ä¸å†²çªï¼Œè¿”å› True else: # å¦‚æœ x å’Œ y ä¸åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼Œåˆå¹¶å®ƒä»¬ parent[root_x] = root_y # å°† root_x çš„çˆ¶èŠ‚ç‚¹è®¾ä¸º root_y # æ›´æ–° root_x ä¸ root_y çš„å…³ç³» # å…³ç³»å…¬å¼ï¼š(relation[y] - relation[x] + d - 1 + 3) % 3 relation[root_x] = (relation[y] - relation[x] + d - 1 + 3) % 3 return True # å¤„ç†æ¯ä¸€æ¡å£°æ˜ for _ in range(k): d, x, y = map(int, input().split()) # æ£€æŸ¥æ˜¯å¦è¶…å‡ºèŒƒå›´ if x &gt; n or y &gt; n: false_count += 1 # è¶…å‡ºèŒƒå›´ï¼Œå‡è¯ continue # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±åƒè‡ªå·± if d == 2 and x == y: false_count += 1 # è‡ªå·±åƒè‡ªå·±ï¼Œå‡è¯ continue # å°è¯•åˆå¹¶ x å’Œ y çš„é›†åˆï¼Œå¦‚æœè¿”å› False åˆ™è¡¨ç¤ºå†²çª if not union(x, y, d): false_count += 1 # å†²çªï¼Œå‡è¯ # è¾“å‡ºå‡è¯çš„æ€»æ•° print(false_count)if __name__ == &quot;__main__&quot;: main() æ•´ç†ä¸€ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940N = 50010p = [0] * Nr = [0] * Ndef find(x): if p[x] != x: p_x = p[x] p[x] = find(p[x]) r[x] = (r[x] + r[p_x] + 3) % 3 return p[x]def union(op, a, b): ra = find(a) rb = find(b) if ra == rb: if (r[a] - r[b] + 3) % 3 != op - 1: return False else: return True else: p[ra] = rb r[ra] = (r[b] - r[a] + op - 1 + 3) % 3 return Truedef main(): n, k = map(int, input().split()) res = 0 for i in range(1, n + 1): p[i] = i for i in range(k): op, a, b = map(int, input().split()) if a &gt; n or b &gt; n: res += 1 elif op == 2 and a == b: res += 1 elif not union(op, a, b): res += 1 print(res)main() å †å¦‚ä½•æ‰‹å†™ä¸€ä¸ªå †ï¼Ÿ æ’å…¥ä¸€ä¸ªæ•° æ±‚é›†åˆå½“ä¸­çš„æœ€å°å€¼ åˆ é™¤æœ€å°å€¼ åˆ é™¤ä»»æ„ä¸€ä¸ªå…ƒç´  ä¿®æ”¹ä»»æ„ä¸€ä¸ªå…ƒç´  å †â€”â€”å®Œå…¨äºŒå‰æ ‘ï¼Œé™¤äº†æœ€åä¸€æ’èŠ‚ç‚¹éƒ½æ˜¯éç©ºçš„ï¼Œæœ€åä¸€æ’èŠ‚ç‚¹ä»å·¦åˆ°å³æ’åˆ— å°æ ¹å †â€”â€”æ¯ä¸ªç‚¹éƒ½æ˜¯å°äºå·¦å³å„¿å­çš„ï¼ˆå¯çŸ¥æ ¹èŠ‚ç‚¹æ˜¯å †é‡Œé¢çš„æœ€å°å€¼ï¼‰ å­˜å‚¨æ–¹å¼ï¼š 1(æ ¹èŠ‚ç‚¹) 2(æ ¹èŠ‚ç‚¹å·¦å„¿å­) 3(æ ¹èŠ‚ç‚¹å³å„¿å­) 4 5 èŠ‚ç‚¹xçš„å·¦å„¿å­ï¼š2x èŠ‚ç‚¹xçš„å³å„¿å­ï¼š2x+1 å †æ’åº1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//å¦‚ä½•æ‰‹å†™ä¸€ä¸ªå †ï¼Ÿå®Œå…¨äºŒå‰æ ‘ 5ä¸ªæ“ä½œ//1. æ’å…¥ä¸€ä¸ªæ•° heap[ ++ size] = x; up(size);//2. æ±‚é›†åˆä¸­çš„æœ€å°å€¼ heap[1]//3. åˆ é™¤æœ€å°å€¼ heap[1] = heap[size]; size -- ;down(1);//4. åˆ é™¤ä»»æ„ä¸€ä¸ªå…ƒç´  heap[k] = heap[size]; size -- ;up(k); down(k);//5. ä¿®æ”¹ä»»æ„ä¸€ä¸ªå…ƒç´  heap[k] = x; up(k); down(k);#include &lt;iostream&gt;using namespace std;int const N = 100010;//h[i] è¡¨ç¤ºç¬¬iä¸ªç»“ç‚¹å­˜å‚¨çš„å€¼ï¼Œiä»1å¼€å§‹ï¼Œ2*iæ˜¯å·¦å­èŠ‚ç‚¹ï¼Œ2*i + 1æ˜¯å³å­èŠ‚ç‚¹//size æ—¢è¡¨ç¤ºå †é‡Œå­˜å‚¨çš„å…ƒç´ ä¸ªæ•°ï¼Œåˆè¡¨ç¤ºæœ€åä¸€ä¸ªç»“ç‚¹çš„ä¸‹æ ‡int h[N], siz; //å †æœ‰ä¸¤ä¸ªå˜é‡h[N]ï¼Œsize; è¿™é‡Œçš„sizeå’Œæ–‡ä»¶é‡Œæœ‰å†²çªï¼Œåªèƒ½æ”¹æˆsizäº†void down(int u)&#123; int t = u;//tå­˜å‚¨ä¸‰ä¸ªç»“ç‚¹ä¸­å­˜åœ¨çš„æœ€å°çš„ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œåˆå§‹åŒ–ä¸ºå½“å‰ç»“ç‚¹u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // å·¦å­èŠ‚ç‚¹å­˜åœ¨å¹¶ä¸”å°äºå½“å‰ç»“ç‚¹ï¼Œæ›´æ–°tçš„ä¸‹æ ‡ if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;//å³å­èŠ‚ç‚¹å­˜åœ¨å¹¶ä¸”å°äºå½“å‰ç»“ç‚¹ï¼Œæ›´æ–°tçš„ä¸‹æ ‡ if (t != u)//å¦‚æœt==uæ„å‘³ç€ä¸ç”¨å˜åŠ¨ï¼Œuå°±æ˜¯ä¸‰ä¸ªç»“ç‚¹ä¸­æ‹¥æœ‰æœ€å°å€¼çš„ç»“ç‚¹ä¸‹æ ‡ï¼Œå¦åˆ™äº¤æ¢æ•°å€¼ &#123; swap(h[t], h[u]); down(t); //äº¤æ¢æ•°å€¼åï¼Œtè¿™ä¸ªç»“ç‚¹å­˜å‚¨åŸæœ¬uçš„å€¼ï¼Œuå­˜å‚¨å­˜å‚¨tçš„å€¼ï¼ˆä¸‰ä¸ªæ•°ä¸­çš„æœ€å°å€¼ï¼‰ã€‚uä¸ç”¨è°ƒæ•´äº†ï¼Œä½†tæƒ…å†µä¸æ˜ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´ã€‚ç›´åˆ°å®ƒæ¯”å·¦å³å­èŠ‚ç‚¹éƒ½å° &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; //åˆå§‹åŒ–size,è¡¨ç¤ºå †é‡Œæœ‰n ä¸ªå…ƒç´  for (int i = n / 2; i; i --) down(i); //æŠŠå †åˆå§‹åŒ–æˆå°æ ¹å †ï¼Œä»äºŒå‰æ ‘çš„å€’æ•°ç¬¬äºŒè¡Œå¼€å§‹ï¼ŒæŠŠæ•°å­—å¤§çš„ä¸‹æ²‰ //è¿™é‡Œæ— éœ€å¯¹æ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œdownæ“ä½œï¼Œåªéœ€è¦å¯¹å‰n/2ä¸ªèŠ‚ç‚¹è¿›è¡Œå³å¯ï¼Œå¶å­èŠ‚ç‚¹æ— éœ€å†è¿›è¡Œdownäº† while (m -- ) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[siz]; siz --; down(1); &#125; return 0;&#125; python 1234567891011121314151617181920212223242526N = 100010h = [0]*Nsiz = 0def down(u): global siz t = u if 2*u&lt;=siz and h[2*u]&lt;h[t]: t = 2*u if 2*u+1&lt;=siz and h[2*u+1]&lt;h[t]: t = 2*u + 1 if t!=u: h[t],h[u] = h[u],h[t] down(t)def main(): global siz n,m = map(int,input().split()) siz = n h[1:n+1] = list(map(int,input().split())) for i in range(n//2,0,-1): down(i) for i in range(m): print(h[1],end =&#x27; &#x27;) h[1] = h[siz] siz -= 1 down(1)main() æ¨¡æ‹Ÿå †ç”±äºé¢˜ç›®è¦æ±‚ä¿®æ”¹å’Œåˆ é™¤ç¬¬kä¸ªæ’å…¥çš„ï¼Œæ‰€ä»¥è¦åŠ å…¥å­˜å‚¨æ˜ å°„ï¼Œä¸ºäº†ä¾¿äºåœ¨upã€downè¿‡ç¨‹ä¸­ä¿®æ”¹æ˜ å°„ï¼Œéœ€è¦ä¸¤ä¸ªæ•°ç»„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int h[N],ph[N],hp[N],cnt;//ph[i]=jè¡¨ç¤ºç¬¬iä¸ªæ’å…¥çš„æ•°åœ¨å †ä¸­ä¸‹æ ‡ä¸ºj//hp[i]=jè¡¨ç¤ºå †ä¸­ä¸‹æ ‡ä¸ºiçš„æ•°æ˜¯ç¬¬jä¸ªæ’å…¥çš„void heap_swap(int a,int b)&#123; swap(ph[hp[a]],ph[hp[b]]);//äº¤æ¢aã€bä¸‹æ ‡ï¼Œéœ€è¦ä¿®æ”¹ph swap(hp[a],hp[b]);//å› ä¸ºä¸‹æ ‡æ”¹äº†ï¼Œä¹Ÿéœ€è¦ä¿®æ”¹hp swap(h[a],h[b]);&#125;void down(int u)&#123; int t=u; if(u*2&lt;=cnt&amp;&amp;h[u*2]&lt;h[t]) t=u*2; if(u*2+1&lt;=cnt&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1; if(u!=t) &#123; heap_swap(u,t); down(t); &#125;&#125;void up(int u)&#123; while(u/2&amp;&amp;h[u]&lt;h[u/2])//æœ‰æ ¹èŠ‚ç‚¹ä¸”æ ¹èŠ‚ç‚¹å€¼æ²¡æœ‰æ»¡è¶³æœ€å°å †è¦æ±‚ &#123; heap_swap(u,u/2); u&gt;&gt;=1;//u=u/2; &#125;&#125;int main()&#123; int n,m=0; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; char op[5]; int k,x; scanf(&quot;%s&quot;,op); if(!strcmp(op,&quot;I&quot;)) &#123; scanf(&quot;%d&quot;,&amp;x); cnt++; m++;//ç”¨mä½œä¸ºä¸‹æ ‡ï¼Œå› ä¸ºcntä¼šå‡å°‘è€Œmä¸ä¼šå‡å°‘ ph[m]=cnt,hp[cnt]=m;//cntä¸ºåœ¨å †ä¸­ä¸‹æ ‡ï¼Œè€Œmä¸ºç¬¬å‡ ä¸ªæ’å…¥çš„æ•° h[cnt]=x;//æ’åœ¨æœ€åçš„ä½ç½®ï¼Œç„¶åå‘ä¸Šup up(cnt); &#125; else if(!strcmp(op,&quot;PM&quot;)) printf(&quot;%d\\n&quot;,h[1]); else if(!strcmp(op,&quot;DM&quot;)) &#123; heap_swap(1,cnt); cnt--; down(1); &#125;else if(!strcmp(op,&quot;D&quot;)) &#123; scanf(&quot;%d&quot;,&amp;k); k=ph[k]; heap_swap(k,cnt); cnt--; up(k); down(k); &#125; else&#123; scanf(&quot;%d%d&quot;,&amp;k,&amp;x); k=ph[k]; h[k]=x; up(k); down(k); &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657N = 100010h = [0]*Nhp = [0]*Nph = [0]*Ncnt = 0def swap(a,b): ph[hp[a]],ph[hp[b]] = ph[hp[b]],ph[hp[a]] hp[a],hp[b] = hp[b],hp[a] h[a],h[b] = h[b],h[a]def up(u): while u//2 and h[u]&lt;h[u//2]: swap(u,u//2) u = u//2def down(u): global cnt t = u if u*2&lt;=cnt and h[u*2]&lt;h[t]: t = u*2 if u*2+1&lt;=cnt and h[u*2+1]&lt;h[t]: t = u*2+1 if t!=u: swap(u,t) down(t)def main(): global cnt n = int(input()) m = 0 for i in range(n): op = input().split() if op[0] == &#x27;I&#x27;: x = int(op[1]) cnt += 1 m += 1 h[cnt] = x ph[m] = cnt hp[cnt] = m up(cnt) elif op[0] == &#x27;PM&#x27;: print(h[1]) elif op[0] == &#x27;DM&#x27;: swap(1,cnt) cnt -= 1 down(1) elif op[0] ==&#x27;D&#x27;: k = int(op[1]) idx = ph[k] swap(idx,cnt) cnt -= 1 down(idx) up(idx) else: k,x = map(int,op[1:]) idx = ph[k] h[idx] = x down(idx) up(idx)main() å“ˆå¸Œè¡¨æ¨¡æ‹Ÿæ•£åˆ—è¡¨æ±‚è´¨æ•°çš„æ–¹æ³•ï¼š å…³äºå“ˆå¸Œå‡½æ•°å¯¹åº”çš„æ•°ç»„çš„å¤§å°ï¼šå¦‚æœç”¨æ‹‰é“¾æ³•ï¼Œåˆ™å’Œæ•°å¤šå°‘å·®ä¸å¤šå³å¯ï¼Œå¦‚æœç”¨å¼€æ”¾å¯»å€æ³•ï¼Œåˆ™è®¾ç½®ä¸ºè¯¥æ•°çš„ä¸¤å€ å¼€æ”¾å¯»å€æ³•ï¼š 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=200003,null=0x3f3f3f3f;//è®¾ç½®é•¿åº¦ä¸ºä¸¤å€ï¼Œè®¾ç½®ç©ºæ ‡å¿—//æ³¨æ„nullå››ä¸ª3fï¼Œmemsetå¯¹å­—èŠ‚åšçš„int h[N];//å¼€æ”¾å¯»å€æ³•ç±»ä¼¼äºæ‰¾å‘ä½int find(int x)//å¯»æ‰¾&#123; int t=(x%N+N)%N; while(h[t]!=null&amp;&amp;h[t]!=x)//å½“å‰å‘ä½è¢«å ï¼Œéœ€è¦å‘åå¯»æ‰¾ &#123; t++; if(t==N) t=0;//å¾ªç¯æŸ¥æ‰¾ &#125; return t;//ä¸ä¸€å®šæ‰¾å¯¹ï¼&#125;int main()&#123; memset(h,0x3f,sizeof h);//è®¾ç½®ç©ºæ ‡å¿—ä½ int n; scanf(&quot;%d&quot;,&amp;n); string op; int x; while(n--) &#123; cin&gt;&gt;op&gt;&gt;x; if(op==&quot;I&quot;) h[find(x)]=x; else &#123; if(h[find(x)]==null) puts(&quot;No&quot;); else puts(&quot;Yes&quot;); &#125; &#125; return 0;&#125; æ‹‰é“¾æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=100003;int h[N],e[N],ne[N],idx;void insert(int x)//hæ•°ç»„ç±»ä¼¼äºheadæŒ‡é’ˆçš„æ•°ç»„&#123;//å¤´æ’æ³• int k=(x%N+N)%N;//å“ˆå¸Œå‡½æ•°å€¼,éœ€è¦å¤„ç†è´Ÿæ•° e[idx]=x; ne[idx]=h[k]; h[k]=idx++;&#125;bool find(int x)&#123; int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]) &#123; if(e[i]==x) return true; &#125; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); memset(h,-1,sizeof h);//ç±»ä¼¼äºå•é“¾è¡¨initçš„æ—¶å€™è¦å°†headåˆå§‹åŒ–ä¸º-1 while(n--) &#123; string op; int x; cin&gt;&gt;op&gt;&gt;x; if(op==&quot;I&quot;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; pythonçš„defaultdict 12345678910111213141516from collections import defaultdictdef main(): d = defaultdict(int) n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: d[num] += 1 else: if d[num] == 0: print(&#x27;No&#x27;) else: print(&#x27;Yes&#x27;)main() æ‹‰é“¾æ³• 12345678910111213141516171819202122232425262728293031323334N = 100003h = [-1]*Ne = [0]*Nne = [0]*Nidx = 0def insert(num): global idx k = num%N e[idx] = num ne[idx] = h[k] h[k] = idx idx += 1def find(num): k = num%N i = h[k] while i!=-1: if e[i] == num: return True i = ne[i] return False def main(): n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: insert(num) else: if find(num): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() å¯»å€æ³• 1234567891011121314151617181920212223242526N = 200003null = 0x3f3f3f3fh = [null]*Ndef find(x): k = x % N while h[k]!=null and h[k]!=x: k += 1 if k == N: k = 0 return kdef main(): n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: k = find(num) h[k] = num else: k = find(num) if h[k]!=null: print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() å­—ç¬¦ä¸²å“ˆå¸Œå‰æ±‚å­—ç¬¦ä¸²çš„å‰ç¼€å“ˆå¸Œå€¼ h[i]å­—ç¬¦ä¸²å‰iä½å­—ç¬¦ä¸²å¯¹åº”çš„å“ˆå¸Œå€¼ æˆ‘ä»¬å°†å­—ç¬¦ä¸²å½“åšä¸€ä¸ªpè¿›åˆ¶çš„æ•°æ¥çœ‹å¾… åœ¨å­—ç¬¦ä¸²å“ˆå¸Œä¸­ï¼Œæˆ‘ä»¬æ²¡æœ‰å¤„ç†å†²çªï¼Œé ç»éªŒå®šç†æ¥ä¿è¯ä¸å†²çªï¼Œå°†å­—ç¬¦ä¸²çœ‹åšæ˜¯pè¿›åˆ¶çš„æ•° æ ¹æ®ç»éªŒå®šç†ï¼Œpå–131æˆ–è€…1331ï¼Œå¾—åˆ°çš„æ•°æ¨¡ä¸Š2çš„64æ¬¡æ–¹ï¼Œå¯ä¿è¯å®Œå…¨æ•£åˆ—ï¼Œç”±äºæ•°æ®ç±»å‹unsigned intçš„å€¼åŸŸæ°å¥½ä¸º2çš„64æ¬¡æ–¹ï¼Œæ•…å¯ä»¥ç›´æ¥ä½¿ç”¨unsigned intå­˜å‚¨ï¼Œæº¢å‡ºå³ä¸ºå–æ¨¡ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N=100010,P=131;int n,m;char str[N];ULL h[N],p[N];//pæ•°ç»„å­˜å‚¨æ¯ä¸€ä½ä¸Šçš„åŸºæœ¬å•å…ƒULL get(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,str+1); p[0]=1; for(int i=1;i&lt;=n;i++) &#123; h[i]=h[i-1]*P+str[i];//ç›´æ¥ç”¨çš„ASCIIç  p[i]=p[i-1]*P; &#125; while(m--) &#123; int l1,r1,l2,r2; scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2); if(get(l1,r1)==get(l2,r2)) &#123; puts(&quot;Yes&quot;); &#125;else puts(&quot;No&quot;); &#125; return 0;&#125; python 1234567891011121314151617181920212223N = 100010P = 131Q = 1&lt;&lt;64h = [0]*Np = [0]*Ndef find(l,r): return (h[r] - h[l-1]*p[r-l+1])%Qdef main(): global P global Q p[0] = 1 n,m = map(int,input().split()) s = &#x27; &#x27; + input() for i in range(1,n+1): h[i] = (h[i-1]*P + ord(s[i]))%Q p[i] = p[i-1]*P % Q for i in range(m): l1,r1,l2,r2 = map(int,input().split()) if find(l1,r1) == find(l2,r2): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() æœç´¢ä¸å›¾è®º1.DFSï¼šé€’å½’ç»“æŸæ¡ä»¶çš„é€‰æ‹©+çŠ¶æ€æ ‡è®°+é€’å½’åçš„æ¢å¤2.BFSï¼šæ¨¡æ‹Ÿé˜Ÿåˆ— q[N], d[N] ä½¿ç”¨dæ•°ç»„æ ‡è®°çŠ¶æ€3.æœç´¢ï¼šè§£ç©ºé—´çš„æœç´¢å¾€å¾€éœ€è¦dfs+å‰ªæï¼Œbfsç”¨æ¥æ‰¾æœ€çŸ­è·¯4.æ ‘å’Œå›¾çš„å­˜å‚¨ï¼šé‚»æ¥è¡¨ h[N], e[N], ne[N], idx5.æ ‘å’Œå›¾çš„éå†ï¼šéå†ä¸ç”¨åƒæœç´¢è§£ç©ºé—´ä¸€æ ·é€’å½’åæ¢å¤ï¼Œåªç”¨éå†ä¸€æ¬¡å³å¯ ç‚¹çš„æ•°é‡å’Œè¾¹çš„æ•°é‡ï¼Œè‹¥ç‚¹çš„æ•°é‡çš„å¹³æ–¹ä¸è¾¹çš„æ•°é‡å¤§è‡´ç›¸åŒï¼Œåˆ™ä¸ºç¨ å¯†å›¾ é‚»æ¥çŸ©é˜µå»é‡è¾¹ç”¨minï¼Œé‚»æ¥è¡¨é‡Œé¢æ— éœ€å»é‡è¾¹ æ— å‘å›¾å­˜å‚¨çš„æ—¶å€™è¾¹çš„æ•°é‡è¦å¼€æˆç»™å®šè¾¹æ•°é‡çš„ä¸€å€å¤§å° DFSæ’åˆ—æ•°å­—å…¸å‹æ’åˆ—æ ‘ï¼Œä½†æ˜¯éœ€è¦æŒ‰ç…§å­—å…¸åºæ¥åšï¼Œä¸‹é¢è¿™ç§åšæ³•ä¼šæœ‰äº›ä¸åŒ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=10;int x[N];int n;void DFS(int t)&#123; if(t==n) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); DFS(t+1); swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) x[i]=i; DFS(1); return 0;&#125; acwingæä¾›çš„åšæ³•ï¼š 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=10;int n;int path[N];void dfs(int u,int state)//ç”¨æ•´å‹æ•°stateè®°å½•æ¯ä¸ªæ•°çš„ä½¿ç”¨æƒ…å†µ&#123; if(u==n) &#123; for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,path[i]); puts(&quot;&quot;); return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!(state&gt;&gt;i&amp;1))//æ£€æŸ¥æŸä¸ªæ•°æ˜¯å¦è¢«ç”¨è¿‡ &#123; path[u]=i+1; dfs(u+1,state+(1&lt;&lt;i));//æ³¨æ„è¿™é‡Œå¹¶æ²¡æœ‰æ”¹å˜æºstate &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(0,0); return 0;&#125; nçš‡åé—®é¢˜æ’åˆ—æ ‘ï¼Œdgå’Œudgç”¨æ¥åˆ¤æ–­æ˜¯å¦åœ¨å¯¹è§’çº¿ä¸Šæœ‰å†²çªï¼Œä¸»å¯¹è§’çº¿æ£€æŸ¥ä¸‹æ ‡y-x+næ˜¯å¦å†²çªï¼Œå‰¯å¯¹è§’çº¿æ£€æŸ¥x+yæ˜¯å¦å†²çª åŒæ—¶ç”±äºå¯¹è§’çº¿æ•°é‡æ˜¯nçš„ä¸¤å€å·¦å³ï¼ŒNæ•°é‡è¦å¼€ä¸¤å€ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=20;int x[N],dg[N],udg[N],n;void backtrack(int t)&#123; if(t&gt;n) &#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(j==x[i]) printf(&quot;Q&quot;); else printf(&quot;.&quot;); &#125; puts(&quot;&quot;); &#125; puts(&quot;&quot;); return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); if(!dg[t+x[t]]&amp;&amp;!udg[n+x[t]-t]) &#123; dg[t+x[t]]=udg[n+x[t]-t]=1; backtrack(t+1); dg[t+x[t]]=udg[n+x[t]-t]=0; &#125; swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; x[i]=i; &#125; backtrack(1); return 0;&#125; acwingè§£æ³•ï¼Œå·®ä¸å¤š BFSåˆ†æ”¯é™ç•Œæ¡†æ¶ 1234567891011121314151617181920212223queue Q;int bestw;Node k=new node();//åˆå§‹åŒ–æ ¹èŠ‚ç‚¹set k;//è®¾ç½®k,å‡è®¾kæœ‰å±æ€§cw,levelQ.push(k);while(!Q.empty())&#123; Node cn = Q.pop(); int level=cn.level; if(level&gt;n)&#123; print(); break; &#125; for(auto node:cnçš„åç»§) &#123; if(çº¦æŸå‡½æ•°/é™ç•Œå‡½æ•°) &#123; Node tmp = new Node(); set tmp;//è®¾ç½®tmpå‚æ•° Q.push() &#125; &#125;&#125; BFSç›¸å¯¹è€Œè¨€æ›´ç®€å•ï¼Œé€šå¸¸æ— éœ€è€ƒè™‘levelå’Œä¸€äº›å‰ªæ èµ°è¿·å®«é¦–å…ˆç”¨å›æº¯æ³•åšäº†ä¸€éï¼Œæœç„¶è¶…æ—¶äº†ï¼Œå›æº¯å‰ªæä¸å¤Ÿå¼ºå¤§ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=105;int a[N][N];int n,m;int cw,cbest=10000;void dfs(int x,int y)&#123; if(x==n&amp;&amp;y==m) &#123; if(cw&lt;cbest) cbest=cw; return; &#125; if(cw&gt;cbest) return; a[x][y]=1; cw++; if(!a[x][y-1]) dfs(x,y-1); if(!a[x][y+1]) dfs(x,y+1); if(!a[x+1][y]) dfs(x+1,y); if(!a[x-1][y]) dfs(x-1,y); a[x][y]=0; cw--;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(a,1,sizeof a); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; dfs(1,1); cout&lt;&lt;cbest; return 0;&#125; é‚ä½¿ç”¨å¯çˆ±çš„BFSï¼ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=110;typedef pair&lt;int,int&gt; PII;int n,m;int g[N][N],d[N][N];//gæ•°ç»„è®°å½•åœ°å›¾,dæ•°ç»„è®°å½•èµ°åˆ°æ­¤å¤„çš„è·ç¦»int bfs()&#123; queue&lt;PII&gt; q; memset(d,-1,sizeof(d)); d[0][0]=0;//åˆå§‹åŒ–æ ¹èŠ‚ç‚¹ q.push(&#123;0,0&#125;); int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;//å°æŠ€å·§ while(q.size())//è‹¥é˜Ÿåˆ—ä¸ä¸ºç©º &#123; auto t=q.front();//å–é˜Ÿåˆ—å…ƒç´  q.pop(); for(int i=0;i&lt;4;i++)//æ‰©å±• &#123; int x=t.first+dx[i]; int y=t.second+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]==-1) &#123; d[x][y]=d[t.first][t.second]+1;//é…ç½®æ‰©å±•èŠ‚ç‚¹ q.push(&#123;x,y&#125;);//åŠ å…¥é˜Ÿåˆ— &#125; &#125; &#125; return d[n-1][m-1];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;g[i][j]; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; return 0;&#125; å…«æ•°ç ä¸»è¦éš¾ç‚¹åœ¨äºçŠ¶æ€çš„è¡¨ç¤ºå’Œè½¬æ¢ä¸Š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;int bfs(string state)&#123; queue&lt;string&gt; q; unordered_map&lt;string,int&gt; d; q.push(state);//åˆå§‹æ ¹èŠ‚ç‚¹ d[state]=0; int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,-1,0,1&#125;;//ç§»åŠ¨çš„å°tip string end=&quot;12345678x&quot;;//ç»ˆç»“çŠ¶æ€ while(q.size())//è‹¥é˜Ÿåˆ—ä¸ä¸ºç©º &#123; auto t=q.front(); q.pop(); if(t==end) return d[t];//å–å‡ºåè¿›è¡Œåˆ¤æ–­ int distance=d[t];//å–èŠ‚ç‚¹è·ç¦»æ–¹ä¾¿åé¢æ‰©å±• int k=t.find(&#x27;x&#x27;);//æ–¹ä¾¿ä¿®æ”¹å’Œè¡¨ç¤ºçŠ¶æ€ int x=k/3,y=k%3; for(int i=0;i&lt;4;i++) &#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;=0&amp;&amp;a&lt;3&amp;&amp;b&gt;=0&amp;&amp;b&lt;3) &#123; swap(t[a*3+b],t[k]); if(!d.count(t)) &#123; d[t]=distance+1; q.push(t); &#125; swap(t[3*a+b],t[k]); &#125; &#125; &#125; return -1;&#125;int main()&#123; char s[2]; string state; for(int i=0;i&lt;9;i++) &#123; cin&gt;&gt;s; state+=*s; &#125; cout&lt;&lt;bfs(state)&lt;&lt;endl; return 0;&#125; æ ‘ä¸å›¾çš„æ·±åº¦ä¼˜å…ˆéå†æ ‘å’Œå›¾çš„å­˜å‚¨æ–¹å¼ï¼Œæ ‘æ˜¯ç‰¹æ®Šçš„å›¾ï¼Œæ•…ä»‹ç»å›¾çš„å­˜å‚¨æ–¹å¼ å›¾ï¼šæœ‰å‘å›¾ã€æ— å‘å›¾ æœ‰å‘å›¾ï¼ša-&gt;b æ— å‘å›¾ï¼ša-&gt;b,b-&gt;a æ•…åªéœ€è¦è€ƒè™‘æœ‰å‘å›¾çš„å­˜å‚¨æ–¹å¼ é¢†æ¥çŸ©é˜µï¼ša-&gt;bï¼Œg[a][b]=wï¼Œè®°å½•è¾¹æƒï¼Œä¸èƒ½å­˜å‚¨é‡è¾¹ï¼ˆa-&gt;bæœ‰å¤šæ¡è¾¹ï¼Œä½†ä¹Ÿå¯ä»¥ç›´æ¥é€‰ä¸€æ¡ï¼‰ é‚»æ¥è¡¨ï¼š ï¼ˆæ•°ç»„å»ºç«‹é‚»æ¥è¡¨ï¼‰ æ ‘/å›¾çš„dfs//é‚»æ¥è¡¨ 123456789int h[N], e[N * 2], ne[N * 2], idx;void add(int a, int b) &#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int main()&#123; memset(h,-1,sizeof h);&#125; æ ‘/å›¾çš„bfsæ¨¡æ¿ 12345678910// éœ€è¦æ ‡è®°æ•°ç»„st[N], éå†èŠ‚ç‚¹çš„æ¯ä¸ªç›¸é‚»çš„ä¾¿void dfs(int u) &#123;//æœç´¢èŠ‚ç‚¹uå¯¹åº”çš„èŠ‚ç‚¹ st[u] = true; // æ ‡è®°ä¸€ä¸‹ï¼Œè®°å½•ä¸ºå·²ç»è¢«æœç´¢è¿‡äº†ï¼Œä¸‹é¢è¿›è¡Œæœç´¢è¿‡ç¨‹ for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; dfs(j); &#125; &#125;&#125; æ ‘çš„é‡å¿ƒæœ¬é¢˜çš„æœ¬è´¨æ˜¯æ ‘çš„dfsï¼Œ æ¯æ¬¡dfså¯ä»¥ç¡®å®šä»¥uä¸ºé‡å¿ƒçš„æœ€å¤§è¿é€šå—çš„èŠ‚ç‚¹æ•°ï¼Œå¹¶ä¸”æ›´æ–°ä¸€ä¸‹ansã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œdfså¹¶ä¸ç›´æ¥è¿”å›ç­”æ¡ˆï¼Œè€Œæ˜¯åœ¨æ¯æ¬¡æ›´æ–°ä¸­è¿­ä»£ä¸€æ¬¡ç­”æ¡ˆã€‚ è¿™æ ·çš„å¥—è·¯ä¼šç»å¸¸ç”¨åˆ°ï¼Œåœ¨ æ ‘çš„dfs é¢˜ç›®ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100010,M=2*N;int n;int h[N],e[M],ne[M],idx;int ans=N;bool st[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;int dfs(int u)&#123; st[u]=true;//æ ‡è®°å·²ç»éå†å®Œ int size=0,sum=0; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(st[j]) continue;//å¦‚æœéå†è¿‡ï¼Œåˆ™ç»§ç»­éå†ä¸‹ä¸€ä¸ªå­èŠ‚ç‚¹ int s=dfs(j);//å­èŠ‚ç‚¹çš„å­æ ‘çš„èŠ‚ç‚¹æ•°é‡ size=max(size,s);//è®¡ç®—å­æ ‘èŠ‚ç‚¹çš„æœ€å¤§å€¼ sum+=s;//ä¸ºäº†è®¡ç®—å½“å‰èŠ‚ç‚¹æ‰€åœ¨å­æ ‘ &#125; size=max(size,n-sum-1);//å»æ‰å½“å‰èŠ‚ç‚¹åè¿é€šå—çš„æœ€å¤§èŠ‚ç‚¹æ•° ans=min(ans,size);//é€‰æ‹©æœ€å°å€¼ return sum+1;//è¿”å›çš„åº”è¯¥æ˜¯å½“å‰èŠ‚ç‚¹å’Œä»¥å…¶ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘çš„å…¨éƒ¨èŠ‚ç‚¹çš„ä¸ªæ•° &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); memset(h,-1,sizeof h); for(int i=0;i&lt;n-1;i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); &#125; dfs(1); printf(&quot;%d\\n&quot;,ans); return 0;&#125; æ ‘ä¸å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†å›¾ä¸­ç‚¹çš„å±‚æ¬¡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 100010;int n, m;int h[N], e[N], ne[N], idx;int d[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;int bfs()&#123; memset(d, -1, sizeof d); queue&lt;int&gt; q; d[1] = 0; q.push(1); while (q.size()) &#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (d[j] == -1) &#123; d[j] = d[t] + 1; q.push(j); &#125; &#125; &#125; return d[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i ++ ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; æ‹“æ‰‘æ’åºæœ‰å‘å›¾çš„æ‹“æ‰‘åºåˆ—æœ‰å‘å›¾æ‰æœ‰æ‹“æ‰‘åºï¼Œå¹¶éæ‰€æœ‰å›¾éƒ½æœ‰æ‹“æ‰‘åºåˆ—ï¼Œæœ‰å‘æ— ç¯å›¾ä¸€å®šå­˜åœ¨ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹ï¼Œä¸€å®šå­˜åœ¨æ‹“æ‰‘åºåˆ— æ‰€è°“æ‹“æ‰‘åºåˆ—ï¼Œè¦æ±‚A-&gt;Bï¼ŒAåœ¨æ‹“æ‰‘åºåˆ—ä¸­è¦æ±‚æ’åˆ—åœ¨Bå‰é¢ï¼Œæ‰€æœ‰çš„è¾¹éƒ½ç”±å‰æŒ‡å‘å å¯æ‰€æœ‰çŸ¥å…¥åº¦ä¸º0çš„èŠ‚ç‚¹å¯ä½œä¸ºæ‹“æ‰‘åºåˆ—çš„æœ€å‰ä½ç½®ï¼Œæ€è·¯å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100010;int n,m;int h[N],e[N],ne[N],idx;int d[N];//è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦int q[N];//é˜Ÿåˆ—void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool topsort()&#123; int hh=0,tt=-1;//é˜Ÿå¤´ï¼Œé˜Ÿå°¾ for(int i=1;i&lt;=n;i++)//é¦–å…ˆå°†æ‰€æœ‰å…¥åº¦ä¸º0çš„ç‚¹åŠ å…¥é˜Ÿåˆ— &#123; if(!d[i]) q[++tt]=i; &#125; while(hh&lt;=tt) &#123; int t=q[hh++];//å¼¹å‡ºé˜Ÿé¦–å…ƒç´  for(int i=h[t];i!=-1;i=ne[i])//éå†å…¶åœ¨å›¾ä¸­ç›¸é‚»èŠ‚ç‚¹ &#123; int j=e[i]; if(--d[j]==0)//å¦‚æœå…¥åº¦ä¸º0ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ—ä¸­ &#123; q[++tt]=j; &#125; &#125; &#125; return tt==n-1;//æ‰€æœ‰èŠ‚ç‚¹éƒ½å…¥é˜Ÿè¿‡&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); int a,b; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a&gt;&gt;b; add(a,b); d[b]++; &#125; if(!topsort()) puts(&quot;-1&quot;); else &#123; for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); puts(&quot;&quot;); &#125; return 0;&#125; Dijkstraç¨ å¯†å›¾ç”¨é¢†æ¥çŸ©é˜µï¼Œç¨€ç–å›¾ç”¨é‚»æ¥é“¾è¡¨ æœ´ç´ ç‰ˆæœ¬12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];bool st[N];int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) &#123; int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m -- ) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); &#125; printf(&quot;%d\\n&quot;, dijkstra()); return 0;&#125; æœ€å°å †ä¼˜åŒ–priority_queueçš„å®šä¹‰æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š 1234priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;//æœ¬é¢˜ä½¿ç”¨pairæ¥åšï¼Œpairçš„firstå«ä¹‰ä¸ºè·ç¦»ï¼Œsecondå«ä¹‰ä¸ºç¼–å·priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1e6+10;int n,m;int h[N],w[N],e[N],ne[N],idx;int dist[N];bool st[N];void add(int a,int b,int c)&#123; e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;&#125;int dijkstra()&#123; memset(dist,0x3f,sizeof dist);//å…ˆè®¾ç½®ä¸ºæ— ç©·å¤§ dist[1]=0;//èµ·ç‚¹è®¾ç½®ä¸º0 priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//å®šä¹‰æœ€å°å † heap.push(&#123;0,1&#125;);//åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„è·ç¦»æ—¶0 while(heap.size()) &#123; auto t=heap.top();//å–å †é¡¶èŠ‚ç‚¹ heap.pop(); int ver=t.second,distance=t.first;//å–èŠ‚ç‚¹å¯¹åº”çš„èŠ‚ç‚¹ç¼–å·å’Œè·ç¦» if(st[ver]) continue;//è‹¥å·²ç»æ‰©å±•è¿‡ï¼Œåˆ™æ— éœ€æ‰©å±• st[ver]=true;//æ‰©å±•è¯¥èŠ‚ç‚¹ for(int i=h[ver];i!=-1;i=ne[i]) &#123; int j=e[i];//å–èŠ‚ç‚¹ç¼–å· if(dist[j]&gt;dist[ver]+w[i])//æ›´æ–°å…¶åç»§èŠ‚ç‚¹ &#123; dist[j]=dist[ver]+w[i]; heap.push(&#123;dist[j],j&#125;);//åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ //æ³¨æ„è¿™é‡Œæ²¡æœ‰åˆ æ‰ä»¥å‰è¿™ä¸ªèŠ‚ç‚¹åœ¨é˜Ÿåˆ—ä¸­çš„ä¿¡æ¯ï¼Œå› ä¸ºæ˜¯ä¼˜å…ˆé˜Ÿåˆ— //ä¸”æ¯ä¸ªèŠ‚ç‚¹ä¹Ÿåªèƒ½æ‰©å±•ä¸€æ¬¡ &#125; &#125; &#125; if(dist[n]==0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(h,-1,sizeof h); int a,b,c; while(m--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; printf(&quot;%d&quot;,dijkstra()); return 0;&#125; bellman-fordå¯ä»¥å¤„ç†è´Ÿæƒé‡çš„æƒ…å†µï¼Œå¯ä»¥æ£€æµ‹è´Ÿç¯ä½†æ˜¯æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ ä¸²è”ï¼šç”±äºè¿™ä¸ªç®—æ³•çš„ç‰¹æ€§å†³å®šï¼Œæ¯æ¬¡æ›´æ–°å¾—åˆ°çš„å¿…ç„¶æ˜¯åœ¨å¤šè€ƒè™‘ 1 æ¡è¾¹ä¹‹åèƒ½å¾—åˆ°çš„å…¨å±€çš„æœ€çŸ­è·¯ã€‚è€Œä¸²è”æŒ‡çš„æ˜¯ä¸€æ¬¡æ›´æ–°ä¹‹åè€ƒè™‘äº†ä¸æ­¢ä¸€æ¡è¾¹ï¼šç”±äºä½¿ç”¨äº†æ¾å¼›ï¼ŒæŸèŠ‚ç‚¹çš„å½“å‰æœ€çŸ­è·¯ä¾èµ–äºå…¶æ‰€æœ‰å…¥åº¦çš„èŠ‚ç‚¹çš„æœ€çŸ­è·¯ï¼›å‡å¦‚åœ¨ä»£ç ä¸­ä½¿ç”¨dist[e.b]=min(dist[e.b],dist[e.a] + e.c);ï¼Œæˆ‘ä»¬æ— æ³•ä¿è¯dist[e.a]æ˜¯å¦ä¹Ÿåœ¨æœ¬æ¬¡å¾ªç¯ä¸­è¢«æ›´æ–°ï¼Œå¦‚æœè¢«æ›´æ–°äº†ï¼Œå¹¶ä¸”dist[e.b] &gt; dist[e.a] + e.cï¼Œé‚£ä¹ˆä¼šé€ æˆå½“å‰èŠ‚ç‚¹åœ¨äº‹å®ä¸Šâ€œå³è€ƒè™‘äº†ä¸€æ¡ä»æŸä¸ªèŠ‚ç‚¹æŒ‡å‘açš„è¾¹ï¼Œä¹Ÿè€ƒè™‘äº†a-&gt;bâ€ï¼Œå…±ä¸¤æ¡è¾¹ã€‚è€Œä½¿ç”¨dist[e.b]=min(dist[e.b],last[e.a] + e.c);ï¼Œå¯ä»¥ä¿è¯aåœ¨distæ›´æ–°åä¸å½±å“å¯¹bçš„åˆ¤å®šï¼Œå› ä¸ºåè€…ä½¿ç”¨lastæ•°ç»„ï¼Œä¿å­˜ç€ä¸Šä¸€æ¬¡å¾ªç¯ä¸­çš„distçš„å€¼ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=510,M=10010;struct Edge&#123; int a,b,c;&#125;edges[M];int n,m,k;int dist[N];int last[N];//æ˜¯ç”¨æ¥é¿å…ä¸²è”å½±å“çš„void bellman_ford()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;k;i++) &#123; memcpy(last,dist,sizeof dist); for(int j=0;j&lt;m;j++) &#123; auto e=edges[j]; dist[e.b]=min(dist[e.b],last[e.a]+e.c); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);//nä¸ªç‚¹mæ¡è¾¹kæ­¥ int a,b,c; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); edges[i]=&#123;a,b,c&#125;; &#125; bellman_ford(); if(dist[n]&gt;0x3f3f3f3f/2) puts(&quot;impossible&quot;); else printf(&quot;%d&quot;,dist[n]); return 0;&#125; spfaæ”¹è¿›bellman_fordç®—æ³•ï¼Œdist[v]=dist[w]+wä»…å½“å‰é¢çš„èŠ‚ç‚¹wçš„distå‘ç”Ÿå˜åŒ–æ‰æ›´æ–°ï¼Œå…·ä½“è€Œè¨€éœ€è¦ç”¨å¹¿æœæ¥åš è¿˜æ˜¯åŸºäºbellmanæ–¹ç¨‹æ¥åšçš„ï¼Œä½†æ˜¯åªåŠ¨æ€åŠ å…¥å‰ç»§èŠ‚ç‚¹æ”¹å˜çš„åç»§ï¼šdist[x]=dist[t]+w[i] spfaæ±‚æœ€çŸ­è·¯AcWing 851. SPFAç®—æ³• - AcWing 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N=1e6+10;int n,m;int h[N],ne[N],w[N],e[N],idx;int dist[N];bool st[N];void add(int a,int b,int c)&#123; e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;&#125;int spfa()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; queue&lt;int&gt; q; q.push(1); st[1]=true; while(q.size()) &#123; int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]) &#123; int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) &#123; dist[j]=dist[t]+w[i]; if(!st[j]) &#123; q.push(j); st[j]=true; &#125; &#125; &#125; &#125; return dist[n];&#125;int main()&#123; memset(h,-1,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t=spfa(); if(t==0x3f3f3f3f) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,t); return 0;&#125; spfaåˆ¤æ–­è´Ÿç¯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N=2010,M=10010;int n,m;int h[N],ne[M],w[M],e[M],idx;bool st[N];int dist[N],cnt[N];void add(int a,int b,int c)&#123; e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) &#123; st[i]=true; q.push(i); &#125; while(q.size()) &#123; int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]) &#123; int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) &#123; dist[j]=dist[t]+w[i]; cnt[j]=cnt[t]+1; if(cnt[j]&gt;=n) return true; if(!st[j]) &#123; st[j]=true; q.push(j); &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; if(spfa()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; é—®é¢˜ä¸€ï¼šä¸ºä»€ä¹ˆdtæ•°ç»„ä¸ç”¨åˆå§‹åŒ–ä¸º0x3f3f3f3fï¼Œä»¥åŠä¸ºä»€ä¹ˆåˆå§‹åŒ–è¦æŠŠæ‰€æœ‰ç‚¹å…¥é˜Ÿï¼Ÿç­”ï¼šdtæ•°ç»„çš„åˆå§‹å€¼æ˜¯å¤šå°‘éƒ½ä¸å½±å“ï¼Œå› ä¸ºdtæ•°ç»„åœ¨è¿™é‡Œè®°å½•çš„ä¸æ˜¯æœ€çŸ­è·¯å¾„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬ç†è§£åˆå§‹åŒ–æ—¶ä¸ºä»€ä¹ˆæŠŠæ‰€æœ‰ç‚¹éƒ½åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œåœ¨æ±‚1å¼€å§‹åˆ°nçš„æœ€çŸ­è·¯æ—¶ï¼Œæˆ‘ä»¬åªæŠŠ1å…¥é˜Ÿäº†ä¸”è®©dt[1] = 0ï¼Œç›®çš„æ˜¯è®©1æˆä¸ºå¼€å§‹æ—¶å”¯ä¸€ä¸€ä¸ªæ›´æ–°äº†dtæ•°ç»„çš„ç‚¹ï¼Œç„¶ååœ¨æ ¹æ®å·²æ›´æ–°dtæ•°ç»„çš„è¿™äº›ç‚¹å»æ›´æ–°ä»–çš„å‡ºè¾¹ï¼ˆè¿™å°±æ˜¯spfaæ”¹è‰¯bellmançš„ç²¾é«“ï¼‰ã€‚ä½†æ˜¯è´Ÿç¯å¯èƒ½ä¸åœ¨ç‚¹1çš„åç»§ä¸Šï¼ˆå¯ä»¥è‡ªè¡Œæ„é€ ï¼ŒæŠŠ1æ”¾åœ¨æ‹“æ‰‘å›¾çš„ä¸­æ–­ä½ç½®ï¼Œè´Ÿç¯åœ¨ç‚¹1çš„å‰é¢ï¼‰ï¼Œæ‰€ä»¥è¦æŠŠæ‰€æœ‰ç‚¹å…¥é˜Ÿã€‚æ‰€æœ‰çœ‹åˆ°è¿™å°±æ‡‚äº†ï¼Œdtæ•°ç»„çš„æ„ä¹‰ä¸æ˜¯è®°å½•æœ€çŸ­è·¯å¾„ï¼Œè€Œä¸”æ¥æ›´æ–°åç»§èŠ‚ç‚¹çš„ï¼Œå¦‚æœæŸä¸ªç‚¹çš„dtæ›´æ–°è¿‡äº†ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨è¿™ä¸ªç‚¹æ¥æ›´æ–°ä»–çš„åç»§èŠ‚ç‚¹ï¼ˆåœ¨æ±‚æœ€çŸ­è·¯é—®é¢˜é‡Œï¼Œä¸€ä¸ªç‚¹è·ç¦»åˆå§‹ç‚¹çš„è·ç¦»è¾¹çŸ­äº†ï¼Œæ˜¯ä¸æ˜¯å°è¯•ç”¨è¿™ä¸ªç‚¹å»æ›´æ–°ä»–çš„åç»§èŠ‚ç‚¹ï¼Œå¯èƒ½ä½¿å¾—åç»§èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ä¹Ÿå˜å°ï¼‰ã€‚ FloydFloydæ±‚æœ€çŸ­è·¯ä¸‰é‡å¾ªç¯ï¼ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=210,INF=1e9;int n,m,Q;int d[N][N];void floyd()&#123; for(int k=1;k&lt;=n;k++) &#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125;int main()&#123; //åˆå§‹åŒ–å›¾ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) d[i][j]=0; else d[i][j]=INF; &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); d[a][b]=min(d[a][b],c); &#125; //floyd floyd(); //è½®è¯¢ while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); int t=d[a][b]; if(t&gt;INF/2) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); &#125; return 0;&#125; Primç®—æ³•Primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ•°æœ´ç´ ç‰ˆæœ¬ï¼šç±»ä¼¼äºdijkstraç®—æ³• æ€è·¯ï¼š ä¸dijkstraä¸åŒï¼Œpriméœ€è¦è¿­ä»£næ¬¡ æœ€å°ç”Ÿæˆæ ‘æ˜¯é’ˆå¯¹æ— å‘å›¾çš„ï¼Œæ‰€ä»¥åœ¨è¯»å…¥è¾¹çš„æ—¶å€™ï¼Œéœ€è¦èµ‹å€¼ä¸¤æ¬¡ è¦å…ˆç´¯åŠ å†æ›´æ–°ï¼Œé¿å…tæœ‰è‡ªç¯ï¼Œå½±å“ç­”æ¡ˆçš„æ­£ç¡®æ€§ã€‚åæ›´æ–°ä¸ä¼šå½±å“åé¢çš„ç»“æœä¹ˆï¼Ÿä¸ä¼šçš„ï¼Œå› ä¸ºdist[i]ä¸ºiåˆ°é›†åˆSçš„è·ç¦»ï¼Œå½“tæ”¾å…¥é›†åˆåï¼Œå…¶dist[t]å°±å·²ç»æ²¡æœ‰æ„ä¹‰äº†ï¼Œå†æ›´æ–°ä¹Ÿä¸ä¼šå½±å“ç­”æ¡ˆçš„æ­£ç¡®æ€§ã€‚ éœ€è¦ç‰¹åˆ¤ä¸€ä¸‹ç¬¬ä¸€æ¬¡è¿­ä»£ï¼Œåœ¨æˆ‘ä»¬æ²¡æœ‰åšç‰¹æ®Šå¤„ç†æ—¶ï¼Œç¬¬ä¸€æ¬¡è¿­ä»£ä¸­æ‰€æœ‰ç‚¹åˆ°é›†åˆSçš„è·ç¦»å¿…ç„¶ä¸ºæ— ç©·å¤§ï¼Œè€Œä¸”ä¸ä¼šè¿›è¡Œæ›´æ–°(ä¹Ÿæ²¡æœ‰å¿…è¦)ï¼Œæ‰€ä»¥ä¸éœ€è¦å°†è¿™æ¡è¾¹(ç¬¬ä¸€æ¬¡è¿­ä»£æ—¶ï¼Œæ‰¾åˆ°çš„è·ç¦»é›†åˆSæœ€çŸ­çš„è¾¹)ç´¯åŠ åˆ°ç­”æ¡ˆä¸­ï¼Œä¹Ÿä¸èƒ½è®¤å®šä¸ºå›¾ä¸è¿é€šã€‚ å¦‚æœéœ€è¦è®¾ç½®èµ·ç‚¹ä¸ºiçš„è¯ï¼Œåœ¨åˆå§‹åŒ–distæ•°ç»„ä¹‹åï¼Œdist[i] = 0å³å¯ï¼Œè¿™æ ·ä¹Ÿå¯ä»¥çœå»æ¯è½®è¿­ä»£ä¸­çš„ä¸¤ä¸ªifåˆ¤æ–­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=510,INF=0x3f3f3f3f;int g[N][N],dist[N],n,m;bool st[N];int prim()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; int res=0; for(int i=0;i&lt;n;i++) &#123; int t=-1; for(int j=1;j&lt;=n;j++) &#123; if(!st[j]&amp;&amp;(t==-1||dist[j]&lt;dist[t])) &#123; t=j; &#125; &#125; if(dist[t]==0x3f3f3f3f) return 0x3f3f3f3f; res+=dist[t]; st[t]=true; for(int i=1;i&lt;=n;i++) dist[i]=min(dist[i],g[t][i]); &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(g,0x3f,sizeof g); int a,b,c; while(m--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=g[b][a]=min(g[a][b],c); &#125; int t=prim(); if(t==0x3f3f3f3f) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); return 0;&#125; Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ•° å°†æ‰€æœ‰è¾¹æŒ‰æƒé‡ä»å°åˆ°å¤§æ’åº $O(nlogn)$ æšä¸¾æ¯æ¡è¾¹a,bï¼Œæƒé‡cï¼›ifa,bä¸è¿é€šï¼Œå°†è¿™æ¡è¾¹ä¹ŸåŠ å…¥é›†åˆï¼ˆå¹¶æŸ¥é›†çš„ä½¿ç”¨ï¼‰ $(1)$ ç¨€ç–å›¾é‡Œç”¨kruskal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010,M=200010,INF=0x3f3f3f3f;int n,m;int p[N];//æ¯ä¸ªèŠ‚ç‚¹çš„çˆ·struct Edge&#123; int a,b,w; bool operator &lt;(const Edge&amp;W) const &#123; return w&lt;W.w;//é‡è½½æ–¹ä¾¿æ’åº &#125;&#125;edges[M];int find(int x)//å¹¶æŸ¥é›†æ‰¾çˆ·&#123; if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int kruskal()&#123; sort(edges,edges+m); for(int i=1;i&lt;=n;i++) p[i]=i;//ä½ æˆ‘éƒ½æ˜¯çˆ· int res=0,cnt=0; for(int i=0;i&lt;m;i++) &#123; int a=edges[i].a,b=edges[i].b,w=edges[i].w; a=find(a),b=find(b); if(a!=b) &#123; p[a]=b;//è¿é€š res+=w;//åŠ ä¸Šè¿™æ¡è¾¹ cnt++;//åˆè¿é€šäº†ä¸€ä¸ªèŠ‚ç‚¹ &#125; &#125; if(cnt&lt;n-1) return INF;//æœ‰èŠ‚ç‚¹æ²¡æœ‰åŠ è¿›æ¥ï¼Œè¯´æ˜å›¾ä¸è¿é€š return res;//è¿”å›ç»“æœ&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) &#123; int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); edges[i]=&#123;a,b,w&#125;; &#125; int t=kruskal(); if(t==INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); return 0;&#125; æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾ä¸€ä¸ªå›¾æ˜¯äºŒåˆ†å›¾ï¼Œå½“å‰ä»…å½“å›¾ä¸­ä¸å«å¥‡æ•°ç¯ï¼ˆç”±äºå›¾ä¸­ä¸å«å¥‡æ•°ç¯ï¼Œæ‰€ä»¥æŸ“è‰²è¿‡ç¨‹ä¸€å®šæ²¡æœ‰çŸ›ç›¾ï¼‰ äºŒåˆ†å›¾æŒ‡å›¾èƒ½åˆ†ä¸ºä¸¤ä¸ªé›†åˆï¼Œæ¯ä¸ªé›†åˆå†…éƒ¨æ²¡æœ‰è¾¹ï¼Œè¾¹éƒ½åœ¨é›†åˆä¹‹é—´ï¼ˆç”¨ä¸¤ç§é¢œè‰²æŸ“è‰²ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010,M=200010;int n,m;int h[N],e[M],ne[M],idx;int colour[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool dfs(int u,int c)&#123; colour[u]=c; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(!colour[j])//è‹¥æ²¡æœ‰æŸ“è‰² &#123; if(!dfs(j,3-c)) return false;//å› ä¸ºiæŸ“äº†cï¼Œæ‰€ä»¥åç»§è¦æŸ“ç›¸åçš„é¢œè‰² &#125; else if(colour[j]==c) return false;//å¦‚æœæŸ“äº†å’Œiç›¸åŒçš„é¢œè‰²ï¼Œåˆ™å†²çª &#125; return true;//å¦‚æœæœªå‘ç”Ÿå†²çªï¼Œåˆ™è¿”å›true&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); &#125; bool flag=true; for(int i=1;i&lt;=n;i++) &#123; if(!colour[i]) &#123; if(!dfs(i,1)) &#123; flag=false; break; &#125; &#125; &#125; if(flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; åŒˆç‰™åˆ©ç®—æ³•äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…å§‘å¨˜ j é‡åˆ°æ–°çš„è¿½æ±‚è€…çš„å¿ƒç†æ´»åŠ¨ï¼šå¦‚æœåŸæ¥çš„ç”·æœ‹å‹æœ‰å¤‡èƒï¼Œæˆ‘å°±ç»¿ä»–ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‚£æˆ‘çœ‹ä»–å¤ªå¯æ€œäº†ï¼Œå°±ä¸€ç›´è·Ÿä»–åœ¨ä¸€èµ·å§ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=510,M=100010;int n1,n2,m;int h[N],e[M],ne[M],idx;int match[N];bool st[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool find(int x)//ä¸ºç”·ç”Ÿxæ‰¾å¥³ç”Ÿ&#123; for(int i=h[x];i!=-1;i=ne[i]) &#123; int j=e[i];//å¥³ç”Ÿçš„ç¼–å· if(!st[j])//è¿™ä¸ªå¥³ç”Ÿä¹‹å‰æ²¡æœ‰å°è¯•åŒ¹é…è¿‡ &#123; st[j]=true;//ç°åœ¨å°è¯•è¿‡äº† if(match[j]==0||find(match[j]))//å¦‚æœå–œæ¬¢çš„å¥³ç”Ÿå•èº«,æˆ–è€…èƒ½å˜æˆå‰ä»» &#123; match[j]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b); &#125; int res=0; for(int i=1;i&lt;=n1;i++) &#123; memset(st,false,sizeof st); if(find(i)) res++;//ä¸ºç”·ç”Ÿæ‰¾åˆ°å¥³ç”Ÿ &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; æ•°è®º æ•°è®º ç»„åˆè®¡æ•° é«˜æ–¯æ¶ˆå…ƒ ç®€å•åšå¼ˆè®º è´¨æ•°å®šä¹‰ï¼šåœ¨å¤§äº1çš„æ•´æ•°ä¸­ï¼Œå¦‚æœå€¼åŒ…å«1å’Œæœ¬èº«è¿™ä¸¤ä¸ªçº¦æ•°ï¼Œå°±è¢«ç§°ä¹‹ä¸ºè´¨æ•°ï¼Œæˆ–è€…å«ç´ æ•° æ‰€æœ‰å°äºç­‰äº1çš„æ•°æ—¢ä¸æ˜¯è´¨æ•°ä¹Ÿä¸æ˜¯åˆæ•° ï¼ˆ1ï¼‰è´¨æ•°çš„åˆ¤å®šâ€”â€”è¯•é™¤æ³• ï¼ˆ2ï¼‰åˆ†è§£è´¨å› æ•°â€”â€”è¯•é™¤æ³•ï¼šä»å°åˆ°è¾¾æšä¸¾æ‰€æœ‰æ•°ï¼Œ è¯•é™¤æ³•åˆ¤å®šè´¨æ•°åªæšä¸¾è¾ƒå°çš„çº¦æ•°ä»¥å‡å°æ—¶é—´å¤æ‚åº¦ï¼Œæ—¶é—´å¤æ‚åº¦$O(sqrt(n))$ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;bool is_prime(int x)&#123; if(x&lt;2) return false; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) return false; &#125; return true;&#125;int main()&#123; int n; cin&gt;&gt;n; int m; while(n--) &#123; cin&gt;&gt;m; if(is_prime(m)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125; åˆ†è§£è´¨å› å­è´¨å› æ•°æ˜¯æŒ‡ï¼Œèƒ½å¤Ÿè¢«n æ•´é™¤ï¼ˆä¹Ÿå°±æ˜¯ä»–çš„çº¦æ•°æˆ–è€…å«å› å­ï¼‰ï¼Œå¹¶ä¸”æœ¬èº«æ˜¯è´¨æ•°çš„æ•°ã€‚ æˆ‘ä»¬å¯ä»¥ä»å‰å¾€åå»ç­›ï¼Œè€Œä¸éœ€è¦åˆ¤æ–­è¿™ä¸ªæ•°æ˜¯å¦æ˜¯è´¨æ•°ï¼Œä¸¾ä¸ªä¾‹å­n=12,é‚£ä¹ˆ2åˆ°12ä¹‹é—´ä¸€å…±æœ‰2,3,4,5,6,7,8,9,10,11 è¿™å‡ ä¸ªæ•°ï¼Œå½“i=2æ—¶ï¼Œä¼šç­›æ‰2,4,6è¿™å‡ ä¸ªæ•°ï¼ˆå‰ææ˜¯è¿™å‡ ä¸ªæ•°æ˜¯taçš„çº¦æ•°ï¼‰ï¼Œ4è¿™ä¸ªåˆæ•°å°±æ˜¯ 2*2 è¢«ç­›æ‰äº† ï¼Œ6åŒç†ï¼Œä¹Ÿå°±æ˜¯åˆæ•°ç­‰äºè´¨æ•°å’Œè´¨æ•°çš„ä¹˜ç§¯,ä¸ç”¨æ‹…å¿ƒè¯¥å› å­ä¸æ˜¯è´¨æ•° 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int divide(int x)&#123; for(int i=2;i&lt;=n;i++) &#123; if(n%i==0) &#123; int s=0; while(n%i==0) &#123; n/=i; s++; &#125; printf(&quot;%d %d\\n&quot;,i,s); &#125; &#125;&#125; nä¸­è‡³å¤šåªåŒ…å«ä¸€ä¸ªå¤§äºsqrt(n)çš„è´¨å› å­ï¼Œæ•…å¯ä»¥å…ˆæšä¸¾å°äºsqrt(n)çš„è´¨å› å­ï¼Œç„¶åå•ç‹¬è€ƒè™‘é‚£ä¸ªå¤§äºsqrt(n)çš„è´¨å› å­ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void divide(int x)&#123; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) &#123; int s=0; while(x%i==0) x/=i,s++; cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;s&lt;&lt;endl; &#125; &#125; if(x&gt;1) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;1&lt;&lt;endl;//å‰©ä¸‹ä¸€ä¸ªå¤§äºæ ¹å·xçš„è´¨å› å­ï¼ˆè¯¥æ•°å¾—æ˜¯å¤§äº1çš„ï¼‰ puts(&quot;&quot;);&#125;int main()&#123; int n,m; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;m; divide(m); &#125; return 0;&#125; ç­›è´¨æ•°åŸƒå¼ç­›æ³•ï¼šå½“ä¸€ä¸ªæ•°æ˜¯è´¨æ•°æ—¶ï¼ˆå› ä¸ºåˆæ•°ç­‰ä»·äºç”¨å…¶è´¨å› å­ç­›ï¼Œå¯¹äºåˆæ•°æˆ‘ä»¬å¯ä»¥ç›´æ¥è·³è¿‡ï¼‰ï¼Œå³æœªè¢«ç­›ï¼Œåˆ™åŠ å…¥ï¼ŒåŒæ—¶ç”¨ä»–å‘åç­›ä»–çš„å€æ•°ï¼Œå¯ä»¥æƒ³è±¡ï¼Œä»¥ä»–ä¸ºå› æ•°çš„åˆæ•°ä¼šè¢«ç­›æ‰ï¼Œå¦‚æœåé¢çš„æŸä¸ªæ•°æœªè¢«ç­›ï¼Œè¯´æ˜ä»–å‰é¢çš„æ•°éƒ½ä¸æ˜¯ä»–çš„å› æ•°ï¼Œæ»¡è¶³è´¨æ•°å®šä¹‰ï¼Œæ•…æœ‰æ•ˆã€‚åŸƒæ°ç­›æ³•å¤æ‚åº¦å·®ä¸å¤šnï¼Œä½†æ˜¯è¿˜æ˜¯æ¯”nå¤§ä¸€ç‚¹ çº¿æ€§ç­›æ³•ï¼šå¤æ‚åº¦å°±æ˜¯n åŸƒå¼ç­›æ³•ï¼š 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;int primes[N],cnt;bool st[N];void get_primes(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(st[i]) continue;//è‹¥ä¸ºåˆæ•° primes[cnt++]=i;//è‹¥ä¸ºè´¨æ•° for(int j=i+i;j&lt;=n;j+=i)//ç­›æ‰è´¨æ•°çš„å€æ•°ï¼Œå¦‚i=2,ç­›æ‰4,6ç­‰ç­‰ &#123; st[j]=true; &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; get_primes(n); cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; çº¿æ€§ç­›æ³•ï¼š çº¿æ€§ç­›æ³•çš„åŸç†ï¼šnåªä¼šè¢«æœ€å°è´¨å› å­ç­›æ‰ æœ¬æ¥æˆ‘ä»¬åº”è¯¥å¯¹æ¯ä¸ªè´¨æ•°åƒåŸƒæ°ç­›æ³•ä¸€æ ·å»ç­›ï¼Œå»æŠŠä»–çš„æ‰€æœ‰å€æ•°æ‰¾å‡ºæ¥ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸è¿™æ ·ï¼Œå¯ä»¥å¹¶è¡Œåœ°åšï¼Œè®©ç›¸åŒçš„iä¹˜ä»¥primes[j]æ¥ç­›ï¼Œä½†æ˜¯æ˜¯å¦éœ€è¦è®©iä¹˜ä»¥æ¯ä¸ªprimes[j]æ¥ç­›å‘¢ï¼Œå¦‚æœi%primes[j]æˆç«‹ï¼Œè¯´æ˜primesjæ˜¯içš„æœ€å°è´¨å› å­ï¼Œæˆ‘ä»¬å¸Œæœ›æ¯ä¸ªæ•°éƒ½è¢«å…¶æœ€å°è´¨å› å­ç­›ï¼Œæ‰€ä»¥i*primes[j+1]ç­›æ‰è¿™ä¸ªä»»åŠ¡åº”è¯¥äº¤ç»™k*primes[j]æ¥å®Œæˆï¼ŒåŒç†æ¥ä¸‹æ¥çš„i*primes[j+x]â€¦ï¼Œæ‰€ä»¥å°±ä¸éœ€è¦å†å¾ªç¯ä¸‹å»äº†ï¼Œbreak é‚£ä¸€ä¸Šæ¥æŠŠprimes[j]iç­›äº†åˆé€‚å—ï¼Œè¿™ä¸ªæ˜¯èƒ½ä¿è¯æœ€å°ç­›å—ï¼Œå¦‚æœjå¤§äº0ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¯ç¬¬ä¸€æ¬¡å¾ªç¯ï¼Œå‡è®¾ç°åœ¨æ˜¯c+1æ¬¡å¾ªç¯ï¼Œé‚£ä¹ˆåœ¨ç¬¬cæ¬¡åˆ¤æ–­çš„æ—¶å€™é€šè¿‡åˆ¤æ–­å¯çŸ¥i%primes[c]!=0,æ•…å¯çŸ¥içš„æœ€å°è´¨å› æ•°å¤§äºprimes[c]ï¼Œæ•°i\\primes[c+1]çš„æœ€å°è´¨å› æ•°è¦ä¹ˆæ˜¯iè¦ä¹ˆæ˜¯primes[c+1]ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å¾ªç¯ï¼Œé‚£ä¹ˆprimes[j]ä¸º2ï¼Œå…¶ä¸ºæœ€å°çš„è´¨æ•°ï¼Œç”¨å…¶ç­›æ‰çš„æ•°ä¸€å®šèƒ½ä¿è¯åŸåˆ™ç”¨æœ€å°è´¨å› æ•°ç­› æˆ‘ä»¬ç­›çš„æ—¶å€™æ€»æ˜¯ç”¨æœ€å°è´¨å› æ•°æ¥ç­›ï¼Œå¹¶ä¸”ç­›çš„æ˜¯i*primes[j]ï¼Œè¿™ä¸ªæ•°ç­›çš„æ—¶å€™æ˜¯å½’ä¸ºç”¨primes[j]ä½œä¸ºæœ€å°è´¨å› æ•°æ¥ç­›çš„ï¼Œå› ä¸ºå¦‚æœå½’ä¸ºiï¼Œiå¦‚æœæ˜¯åˆæ•°çš„è¯ï¼Œé‚£ä¹ˆåº”è¯¥ç”±içš„æœ€å°è´¨å› æ•°æ¥ç­›ï¼Œå¦‚æœæ˜¯è´¨æ•°çš„è¯ï¼Œé‚£ä¹ˆiåˆšåˆšåŠ å…¥primesæ•°ç»„ä¸­ï¼ŒæŒ‰ç…§é¡ºåº(iè¿™ä¸ªè´¨æ•°)(primesè¿™ä¸ªè´¨æ•°)ï¼Œæ˜¾ç„¶primesè¿™ä¸ªè´¨æ•°æ›´å°ï¼Œæ‰€ä»¥ä¹Ÿæ˜¯å½’ä¸ºprimesè¿™ä¸ªè´¨æ•°æ¥ç­›çš„ï¼Œæ‰€ä»¥i\\primes[j]æ¥ç­›æ€»æ˜¯å½’ä¸ºprimes[j]ä½œä¸ºæœ€å°è´¨å› æ•°æ¥ç­› æ‰€ä»¥å½“ä¸æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„æ—¶å€™ï¼Œä¹Ÿå°±æ˜¯i*primes[j]ä¸èƒ½å½’ä¸ºprimes[j]æ—¶ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯iä¸ºåˆæ•°ï¼Œå³ç”±içš„æœ€å°è´¨å› å­æ¥ç­›ï¼Œå› ä¸ºå¦‚æœæ˜¯è´¨æ•°çš„è¯æŒ‰ç…§ä¸Šä¸€æ¡ï¼Œä»ç„¶å½’ç»“ä¸ºprimes[j]ï¼Œä¹Ÿå°±æ˜¯è¯´içš„æœ€å°è´¨å› å­å°äºç­‰äºprimes[j]å§ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ºäº†æ»¡è¶³é»‘ä½“åŠ ç²—çš„è§„åˆ™ï¼Œåœ¨ç­‰äºçš„æ—¶å€™å°±è·³å‡ºå¾ªç¯ 1234567891011121314151617void get_primes(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; // å­˜è´¨æ•° for (int j = 0; primes[j] &lt;= n / i; j ++ ) // ç»“æŸçš„æ¡ä»¶æ˜¯ï¼šprimes[j] * i &lt;= n, æœ€å¤šç­›åˆ°n &#123; st[primes[j] * i] = true; // æŠŠåˆæ•° primes[j] * i ç­›äº† if (i % primes[j] == 0) break;//éå†çš„è¿‡ç¨‹ä¸­æŠŠå½’ç»“ä¸ºä»¥içš„æœ€å°è´¨å› å­çš„å¯èƒ½å»æ‰ // è‹¥ i ä¸º primes[j] çš„åˆæ•°, åœ¨ç­›prime[j] * iä¹‹å‰å°±å·²ç»æŠŠiç­›æ‰äº† // iéƒ½è¢«ç­›äº†ï¼Œæ¯”iå¤§çš„ primes[j]çš„å€æ•°ä¹Ÿåœ¨ä¹‹å‰è¢«ç­›äº† // å› ä¸º i = primes[j] * k, primes[j] &lt; i, k &lt; i. // è€Œ i &lt; n, è‹¥ i - nä¹‹é—´è¿˜å­˜åœ¨prims[j]* (k + 1) == x &lt; n çš„è¯ // i &lt; x &lt; nï¼Œå¾ªç¯ç»“æŸæ—¶å¯ä»¥ç­›åˆ°nï¼Œæ•…primes[j]çš„k + 1å€ xä¼šè¢«ç­›æ‰ &#125; &#125;&#125; çº¦æ•°ï¼ˆ1ï¼‰è¯•é™¤æ³•æ±‚ä¸€ä¸ªæ•°çš„æ‰€æœ‰çº¦æ•° åªéœ€è¦æšä¸¾è¾ƒå°çš„çº¦æŸï¼Œè¾ƒå¤§çš„é‚£ä¸ªå¯ä»¥ç›´æ¥è®¡ç®—å‡ºæ¥ ï¼ˆ2ï¼‰çº¦æŸä¸ªæ•° intèŒƒå›´å†…çº¦æ•°æœ€å¤šçš„æ˜¯1500å·¦å³ ï¼ˆ3ï¼‰çº¦æŸä¹‹å’Œ çº¦æŸä¹‹å’Œå±•å¼€å³å¯å‘€ï¼Œæ¯ä¸ªæ‹¬å·é‡Œé€‰ä¸€ä¸ªå°±è¡Œäº†~ ï¼ˆ4ï¼‰æœ€å¤§å…¬çº¦æ•° æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼ˆè¾—è½¬ç›¸é™¤æ³•ï¼‰ çº¦æŸä¸ªæ•°å…ˆæŠŠæ¯ä¸ªæ•°åˆ†è§£ä¸ºè´¨å› å­è¡¨è¾¾å¼ï¼Œç„¶åç”¨ä¸Šé¢çš„å…¬å¼ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N=110,mode=1e9+7;int main()&#123; int n; cin&gt;&gt;n; unordered_map&lt;int,int&gt;primes; while(n--) &#123; int x; cin&gt;&gt;x; for(int i=2;i&lt;=x/i;i++)//æŠŠæ¯ä¸ªæ•°åˆ†è§£æˆè´¨å› å­è¡¨è¾¾å¼ &#123; while(x%i==0)&#123; x/=i; primes[i]++; &#125; &#125; if(x&gt;1) primes[x]++; &#125; LL res=1;//æ³¨æ„æ˜¯1 for(auto p:primes) res=res*(p.second+1)%mode; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; çº¦æŸä¹‹å’Œä¸»è¦æ˜¯$1+P+P^2â€¦$çš„å¤„ç†é‡‡ç”¨t=t*p+1çš„æ–¹å¼å®Œæˆ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 110, mod = 1e9 + 7;int main()&#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) &#123; x /= i; primes[i] ++ ; &#125; if (x &gt; 1) primes[x] ++ ; &#125; LL res = 1; for (auto p : primes) &#123; LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; è¯•é™¤æ³•æ±‚çº¦æ•°1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; get_divisors(int x)&#123; vector&lt;int&gt; res; for(int i=1;i&lt;=x/i;i++)//æšä¸¾è¾ƒå°è€…å³å¯ &#123; if(x%i==0) &#123; res.push_back(i); if(i!=x/i) res.push_back(x/i);//é¿å…ä¸¤ä¸ªç›¸åŒ &#125; &#125; sort(res.begin(),res.end()); return res;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int x; cin&gt;&gt;x; auto res=get_divisors(x); for(auto x:res) cout&lt;&lt;x&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; æœ€å¤§å…¬çº¦æ•° æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦$log(n)$ æ³¨æ„: d|açš„å«ä¹‰æ˜¯aèƒ½è¢«dæ•´é™¤ï¼Œå³a/d åŸºäºå¦‚ä¸‹åŸç†ï¼šd|a,d|b,åˆ™æœ‰d|ax+byï¼Œæ‰€ä»¥aå’Œbçš„æœ€å¤§å…¬çº¦æ•°(a,b)ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸º(b,a-c*b)ï¼Œå¯çŸ¥å‡è®¾(a,b)å€¼ä¸ºkï¼Œkä¸€å®šéƒ½æ•´é™¤bå’Œa-c*bï¼Œç‰¹æ®Šçš„ï¼Œè¿™é‡Œçš„cå–[a/b]ï¼Œæ•…æœ‰(a,b)=(b,a%b)ï¼Œå¦‚æœbä¸º0ï¼Œåˆ™ç”±äº0å¯ä»¥è¢«ä»»ä½•æ•°æ•´é™¤ï¼Œ0/k=0,æ‰€ä»¥æœ€å¤§å…¬çº¦æ•°è¿”å›aï¼ˆä¹Ÿå°±æ˜¯è¯´ä»»ä½•çš„æ•°éƒ½æ˜¯0çš„çº¦æ•°ï¼‰ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;//è‹¥bä¸º0ï¼Œåˆ™è¿”å›a(0å¯ä»¥æ•´é™¤ä»»ä½•æ•°),å¦åˆ™è¿”å›(b,a%b)&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;gcd(a,b)&lt;&lt;endl; &#125; return 0;&#125; æ¬§æ‹‰å‡½æ•°æ¬§æ‹‰å‡½æ•°äº’è´¨ï¼šå…¬çº¦æ•°åªæœ‰1çš„ä¸¤ä¸ªæ•´æ•° æ¬§æ‹‰å‡½æ•°å°±æ˜¯æ±‚å‡º1~Nä¸­ä¸Näº’è´¨çš„æ•°çš„ä¸ªæ•°ï¼Œæ¯”å¦‚6ä¸1,5äº’è´¨ï¼Œæ•…æ¬§æ‹‰å‡½æ•°å€¼ä¸º2 æ¬§æ‹‰å…¬å¼åŸç†ï¼šä¸Šé¢çš„å…¬å¼å±•å¼€å°±æ˜¯ä¸‹é¢çš„å®¹æ–¥åŸç†ï¼Œæ¯”å¦‚1/p1è¿™ä¸ªé¡¹å‰é¢æ˜¯è´Ÿå·ï¼Œä¸¤ä¸ªçš„è¯æ˜¯æ­£å·ã€‚ã€‚ã€‚ã€‚ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int phi(int x)&#123; //è¿™é‡Œæ²¡å­˜è´¨å› æ•°ï¼Œå› ä¸ºæ²¡å¿…è¦ int res=x; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) &#123; res=res/i*(i-1);//å…ˆé™¤åä¹˜ï¼Œé¿å…è®¡ç®—è¿‡ç¨‹ä¸­æº¢å‡º while(x%i==0) x/=i;//é™¤å°½ &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int x; cin&gt;&gt;x; cout&lt;&lt;phi(x)&lt;&lt;endl; &#125; return 0;&#125; ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°å¦‚æœè¦æ±‚1~Nä¸­æ¯ä¸€ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°ï¼Œå¦‚æœç”¨å…¬å¼æ¥ç®—ï¼Œåˆ†è§£è´¨å› æ•°næ¬¡å°†å¤æ‚åº¦å˜æˆ$O(n*sqrt(n))$ï¼Œè€Œç­›æ³•æ±‚æ¯ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ åœ¨çº¿æ€§ç­›æ³•çš„è¿‡ç¨‹ä¸­é¡ºä¾¿æŠŠæ¬§æ‹‰å‡½æ•°æ±‚å‡ºæ¥ï¼Œæ³¨æ„æ¬§æ‹‰å‡½æ•°çš„å®šä¹‰ï¼Œ1~Nä¸­ä¸Näº’è´¨çš„æ•°çš„ä¸ªæ•° è‹¥iæ˜¯è´¨æ•°ï¼Œé‚£ä¹ˆiä¸å‰i-1ä¸ªæ•°å‡äº’è´¨ï¼Œè¿™æ˜¯è´¨æ•°çš„å®šä¹‰ï¼ˆè´¨æ•°åªæœ‰ä»–è‡ªå·±å’Œ1ä¸¤ä¸ªå› å­ï¼‰ï¼Œæ•…å…¶phiå€¼ä¸ºi-1 primes[j]*içš„phiå€¼ å¦‚æœi%primes[j]==0ï¼ŒæŒ‰ç…§çº¿æ€§ç­›æ³•ï¼Œæ­¤æ—¶primes[j]æ°å¥½æ˜¯içš„æœ€å°è´¨å› æ•°ï¼Œæ‰€ä»¥æŒ‰ç…§å…¬å¼å¯çŸ¥ï¼šphi[i%primes[j]]=primes[j]*phi[i] å¦‚æœi%primes[j]!=0ï¼ŒæŒ‰ç…§çº¿æ€§ç­›æ³•ï¼Œæ­¤æ—¶içš„æœ€å°è´¨å› å­å¤§äºprimesï¼Œæ•…éœ€è¦åˆ†åˆ«è®¡ç®—iå’Œprimes[j]çš„è´¨å› å­ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=1000010;int primes[N],cnt;int euler[N];bool st[N];void get_euler(int n)&#123; euler[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!st[i])//æ˜¯è´¨æ•° &#123; primes[cnt++]=i; euler[i]=i-1;//è´¨æ•°å’Œå…¶å‰é¢çš„æ•°äº’è´¨ &#125; for(int j=0;primes[j]&lt;=n/i;j++)//å¯¹äºè¯¥æ•°ä¸è´¨æ•°çš„ä¹˜æ•°ï¼Œå‘åç­› &#123; int t=primes[j]*i; st[t]=true; if(i%primes[j]==0)//eulaerä¸­å·²ç»åŒ…å«äº†1/primes[j] &#123; euler[t]=euler[i]*primes[j]; break; &#125;//æœªåŒ…å« euler[t]=euler[i]*(primes[j]-1); &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; get_euler(n); LL res=0; for(int i=1;i&lt;=n;i++) res+=euler[i]; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; æ¬§æ‹‰å‡½æ•°çš„ä¸€ä¸ªè¿ç”¨ï¼Œå› ä¸ºaå’Œnäº’è´¨ï¼Œå‡è®¾1~nä¸­ä¸näº’è´¨çš„æ•°ä¸ºa1,a2,â€¦a_phi(n),å°†è¿™äº›æ•°ä¹˜ä»¥aåä¹Ÿå°†ä¸näº’è´¨ï¼ˆåªæœ‰1è¿™ä¸€ä¸ªå…¬å› å­ï¼‰ï¼Œè€Œåœ¨æ¨¡nçš„æƒ…å†µä¸‹è¿™ä¸¤ç§åº”è¯¥æ˜¯ç­‰ä»·çš„(æ¨¡nä¹‹å)ï¼Œæ‰€ä»¥ä¹˜èµ·æ¥ï¼Œå¯å¾—ä¸Šé¢çš„å…¬å¼,å¦‚5^2^=25%6=1ï¼Œå…¶ä¸­phi(6)=2 å¿«é€Ÿå¹‚åŸç†ï¼š ä¾‹å­ï¼š å¿«é€Ÿå¹‚è‹¥æ±‚Açš„Bæ¬¡æ–¹çš„åå‡ ä½æ•°ï¼Œåˆ™è¿™é‡Œçš„åå‡ ä½æ•°å°±æ˜¯q LL res = 1 % p;æ³¨æ„è¿™ä¸ªå¼å­ï¼ï¼ï¼ï¼Œå½“a=5,b=0,p=1è¿™ç§æƒ…å†µä¸‹æ˜¯ä¼šå‡ºé”™çš„ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a,int b,int q)&#123; LL res=1%q; while(b) &#123; //æŠŠbè½¬æ¢ä¸ºäºŒè¿›åˆ¶ if(b&amp;1) res=res*a%q; a=a*(LL)a%q;//aå˜æˆå…¶å¹³æ–¹ b&gt;&gt;=1; &#125; return res%q;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int a,b,q; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;q); printf(&quot;%lld\\n&quot;,qmi(a,b,q)); &#125; return 0;&#125; å¿«é€Ÿå¹‚æ±‚é€†å…ƒåœ¨æ¬§å‡ é‡Œå¾—ç®—æ³•é‚£èŠ‚æˆ‘ä»¬çŸ¥é“äº†è´¹é©¬å®šç†ï¼šæ³¨æ„æ¡ä»¶æ˜¯aå’Œpäº’è´¨ä¸”pæ˜¯è´¨æ•°ï¼Œå¦‚æœaæ˜¯pçš„å€æ•°ï¼Œå¿«é€Ÿå¹‚æ˜¯æ— æ³•æ±‚çš„ bçš„é€†å…ƒå°±æ˜¯ä¸Šé¢çš„xï¼Œæœ€ç»ˆé€šè¿‡è´¹é©¬å®šç†è½¬æ¢ä¸ºæ±‚b^(n-2)%nï¼Œè½¬å˜ä¸ºå¿«é€Ÿå¹‚ æ³¨æ„è¿™é‡Œaå’Œnè¦æ±‚äº’è´¨ï¼Œå¦åˆ™ç»“æœæ˜¯impossible 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a,int b,int p)&#123; LL res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*(LL)a%p; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n; cin&gt;&gt;n; int a,p; while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;p); if(a%p==0) puts(&quot;impossible&quot;); else printf(&quot;%lld\\n&quot;,qmi(a,p-2,p));//a^(p-2)%p; &#125; return 0;&#125; æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼š åŸºäºå¦‚ä¸‹åŸç†ï¼šd|a,d|b,åˆ™æœ‰d|ax+byï¼Œæ‰€ä»¥aå’Œbçš„æœ€å¤§å…¬çº¦æ•°(a,b)ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸º(b,a-c*b)ï¼Œå¯çŸ¥å‡è®¾(a,b)å€¼ä¸ºkï¼Œkä¸€å®šéƒ½æ•´é™¤bå’Œa-c*bï¼Œç‰¹æ®Šçš„ï¼Œè¿™é‡Œçš„cå–[a/b]ï¼Œæ•…æœ‰(a,b)=(b,a%b)ï¼Œå¦‚æœbä¸º0ï¼Œåˆ™ç”±äº0å¯ä»¥è¢«ä»»ä½•æ•°æ•´é™¤ï¼Œ0/k=0,æ‰€ä»¥æœ€å¤§å…¬çº¦æ•°è¿”å›aï¼ˆä¹Ÿå°±æ˜¯è¯´ä»»ä½•çš„æ•°éƒ½æ˜¯0çš„çº¦æ•°ï¼‰ è£´èœ€å®šç†ï¼šå¯¹äºä»»æ„æ­£æ•´æ•°a,bï¼Œä¸€å®šå­˜åœ¨éé›¶æ•´æ•°xï¼Œyï¼Œä½¿å¾—ax+by=(a,b)çš„æœ€å¤§å…¬çº¦æ•° æœ€å¤§å…¬çº¦æ•°å°±æ˜¯æœ€å¤§å…¬å› æ•°ï¼Œæ‰©å±•æ¬§å‡ é‡Œå¾—å°±æ˜¯æ„é€ xå’Œyï¼Œåˆ©ç”¨çš„æ˜¯é€’å½’çš„æ€æƒ³ å½“bä¸º0æ—¶ï¼Œå¯ä»¥è½»æ˜“å†™å‡ºæ¥ï¼Œå½“bä¸ä¸º0æ—¶ï¼Œæ‰¾åˆ°å‰åä¸¤å±‚çš„é€’å½’å…³ç³» æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³• xã€yå¹¶ä¸å”¯ä¸€ï¼Œç®—æ³•æ±‚å‡ºå…¶ä¸€ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)//å¦‚æœbä¸º0ï¼Œåˆ™æœ€å¤§å…¬çº¦æ•°å°±æ˜¯a &#123; x=1,y=0; return a; &#125; //ä¸‹é¢æ˜¯é€’å½’ä¸¤å±‚é—´çš„å…³ç³» int d=exgcd(b,a%b,y,x);//å·²ç»æ±‚å¾—by+(a%b)x=dçš„è§£y,xï¼Œç°åœ¨æ ¹æ®å·²ç»æ±‚å¾—çš„è§£æ±‚ax+by=dçš„è§£xå’Œy //æ‰©å±•æ¬§å‡ é‡Œå¾— y-=a/b*x; return d;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a,b; while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); int x,y; exgcd(a,b,x,y); printf(&quot;%d %d\\n&quot;,x,y); &#125; return 0;&#125; çº¿æ€§åŒä½™æ–¹ç¨‹ æ ¹æ®æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œå¯¹äºax+my=dï¼Œå…¶ä¸­dæ˜¯aå’Œmçš„æœ€å¤§å…¬çº¦æ•°ï¼Œä¸€å®šåœ¨ä¸€äº›æ¡ä»¶ä¸‹æœ‰è§£ï¼Œä½†æ˜¯é¢˜ç›®ç»™å‡ºçš„æ˜¯bï¼Œæ‰€ä»¥ä¸ä¸€å®šæœ‰è§£ï¼Œæœ‰è§£çš„æ¡ä»¶æ˜¯bèƒ½å¤Ÿè¢«dæ•´é™¤ï¼Œå¹¶ä¸”å¯çŸ¥å®é™…çš„xå€¼ä¼šå› æ­¤è€Œæ‰©å¤§b/då€ çº¿æ€§åŒä½™æ–¹ç¨‹æ±‚çš„æ˜¯è¿™ä¸ªxï¼Œæ€è·¯æ˜¯ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—é¦–å…ˆæ±‚aå’Œmçš„æœ€å¤§å…¬çº¦æ•°dï¼Œç„¶åæŠŠæ±‚å¾—çš„xæ‰©å±•b/då€ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;typedef long long LL;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b) &#123; x=1,y=0; return a; &#125; int t=exgcd(b,a%b,y,x); y-=a/b*x; return t;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a,b,m; while(n--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;m); int x,y; int d=exgcd(a,m,x,y); if(b%d) puts(&quot;impossible&quot;);//è¦æ±‚èƒ½æ•´é™¤æœ€å¤§å…¬çº¦æ•° else printf(&quot;%d\\n&quot;,(LL)b/d*x%m); &#125; return 0;&#125; å‡è®¾æŸä¸ªç‰¹è§£ä¸ºax0+by0=nï¼›é‚£è¿™ä¸ªä¹Ÿç­‰åŒäº aï¼ˆx0+btï¼‰+bï¼ˆy0-atï¼‰=n;xçš„é€šè§£ä¸º x=x0+b*t;æœ€åå–æ¨¡å¯ä»¥æ±‚æœ€å°çš„è§£ ä¸­å›½å‰©ä½™å®šç†è¡¨è¾¾æ•´æ•°çš„å¥‡æ€ªæ–¹å¼ æŒ‰ç…§ä¸Šå›¾çš„æ­¥éª¤æ¥æ±‚ï¼š é¦–å…ˆåŒ–ä¸ºk1a1-k2a2=m2-m1å½¢å¼ï¼Œè¿™ä¸ªå½¢å¼åšä¸¤ä»¶äº‹æƒ…ï¼Œç¬¬ä¸€ä»¶äº‹æƒ…æ˜¯åˆ¤æ–­æ˜¯å¦æœ‰è§£ï¼Œæœ‰è§£ç­‰ä»·äº(m2-m1)æ˜¯(a1,a2)çš„å€æ•°ï¼Œç¬¬äºŒä»¶äº‹æƒ…æ˜¯æ ¹æ®æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚å‡ºk1 ä½†æ˜¯ä¸ºäº†é¢˜ç›®çš„xçš„æœ€å°æ¡ä»¶ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®æ‰©å±•æ¬§å‡ é‡Œå¾—çš„é€šè§£å½¢å¼ç¼©å°k1ï¼Œè¿™ä¹Ÿæ˜¯ä¸€æ­¥ åœ¨æ±‚å‡ºk1ä¹‹åæˆ‘ä»¬å°±å¯ä»¥æ±‚xäº†ï¼Œx=a1k1+m1+ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; LL d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;int main()&#123; int n; cin&gt;&gt;n; LL x=0,m1,a1; cin&gt;&gt;a1&gt;&gt;m1; for(int i=0;i&lt;n-1;i++)&#123; LL m2,a2; cin&gt;&gt;a2&gt;&gt;m2; LL k1,k2; LL d=exgcd(a1,a2,k1,k2); if((m2-m1)%d)&#123; x=-1; break; &#125; //æ›´æ–°çŠ¶æ€ k1*=(m2-m1)/d;//å› ä¸ºç­‰å¼å³è¾¹æ˜¯m2-m1è€Œä¸æ˜¯æœ€å¤§å…¬çº¦æ•°ï¼Œæ‰€ä»¥éœ€è¦æ‰©å±• LL t=a2/d;//ä¸Šå›¾ä¸‹é¢çš„é€šè§£å½¢å¼ //å°†è§£å˜æˆä¸€ä¸ªæœ€å°çš„æ­£æ•´æ•°è§£ k1=(k1%t+t)%t; x=k1*a1+m1;//æ±‚å¾—x //ä¸‹é¢å°±æ˜¯æŠŠä¸¤ä¸ªå¼å­ç»Ÿä¸€ä¸ºä¸€ä¸ªå¼å­ç»§ç»­åˆå¹¶ //æ›´æ–°aå’Œmï¼Œkåªæ˜¯ä¸ªå˜é‡ï¼Œä¸ç”¨ç®¡ï¼Œå–ä½™çš„æ—¶å€™ä¼šè‡ªåŠ¨æ¶ˆå¤± m1=k1*a1+m1; a1=abs(a1/d*a2);//æœ€å°å…¬å€æ•° &#125; if(x!=-1) x=(m1%a1+a1)%a1; cout&lt;&lt;x&lt;&lt;endl; return 0;&#125; é«˜æ–¯æ¶ˆå…ƒé«˜æ–¯æ¶ˆå…ƒè§£çº¿æ€§æ–¹ç¨‹ç»„ çº¿æ€§æ–¹ç¨‹ç»„æœ‰ä¸‰ç§æƒ…å†µçš„è§£ï¼Œå…ˆå°†çŸ©é˜µåŒ–ä¸ºä¸Šä¸‰è§’ å¦‚æœå‡ºç°å·¦ä¾§å’Œå³ä¾§éƒ½æ˜¯0çš„è¡Œï¼Œè¯´æ˜æ–¹ç¨‹ç»„ä¸­è¯¥æ–¹ç¨‹å¯ä»¥è¢«å…¶ä»–æ–¹ç¨‹è¡¨å‡ºï¼Œæ•…æ–¹ç¨‹ç»„æœ‰æ— ç©·è§£ å¦‚æœå‡ºç°å·¦ä¾§å…¨ä¸º0å³ä¾§ä¸ä¸º0çš„è¡Œï¼Œåˆ™æ–¹ç¨‹ç»„æ— è§£ å¦åˆ™å°±æ˜¯æœ‰å”¯ä¸€è§£ï¼Œé€šè¿‡åˆç­‰è¡Œå˜æ¢ï¼Œé«˜æ–¯æ¶ˆå…ƒçš„æ–¹æ³•æ±‚è§£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-8;int n;double a[N][N];int gauss() // é«˜æ–¯æ¶ˆå…ƒï¼Œç­”æ¡ˆå­˜äºa[i][n]ä¸­ï¼Œ0 &lt;= i &lt; n&#123; int c, r; for (c = 0, r = 0; c &lt; n; c ++ )//ä¾æ¬¡å¤„ç†å§å„åˆ— &#123; int t = r; for (int i = r; i &lt; n; i ++ ) // æ‰¾ç»å¯¹å€¼æœ€å¤§çš„è¡Œ if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue;//å¦‚æœæœ€å¤§çš„è¡Œéƒ½æ˜¯0ï¼Œè¯´æ˜å…¨æ˜¯0ï¼Œè¯¥åˆ—æ— æ³•ç”¨äºè¡Œçš„å›ºå®š for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]); // å°†ç»å¯¹å€¼æœ€å¤§çš„è¡Œæ¢åˆ°æœ€é¡¶ç«¯ for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c]; // å°†å½“å‰è¡Œçš„é¦–ä½å˜æˆ1 for (int i = r + 1; i &lt; n; i ++ ) // ç”¨å½“å‰è¡Œå°†ä¸‹é¢æ‰€æœ‰çš„åˆ—æ¶ˆæˆ0 if (fabs(a[i][c]) &gt; eps) for (int j = n; j &gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; &#125; if (r &lt; n)//å¦‚æœå›ºå®šçš„è¡Œæ•°å°äºnï¼Œåˆ™è¯´æ˜æœ‰ä¸€äº›è¡Œå·¦ä¾§å…¨æ˜¯0 &#123; for (int i = r; i &lt; n; i ++ )//æ£€æŸ¥è¿™äº›è¡Œå³è¾¹æ˜¯ä¸æ˜¯0 if (fabs(a[i][n]) &gt; eps) return 2; // æ— è§£ return 1; // æœ‰æ— ç©·å¤šç»„è§£ &#125; //æ±‚å”¯ä¸€è§£ï¼Œéœ€è¦å†åŒ–ä¸ºæœ€ç®€å¼ï¼Œå³ç³»æ•°çŸ©é˜µåŒ–ä¸ºå•ä½çŸ©é˜µ for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n];//ç¬¬iè¡Œéœ€è¦å‡çš„æ•°ä¸ç¬¬iè¡Œçš„éé¦–ä½å’Œè¯¥é¦–ä½å¯¹åº”çš„åˆ—çš„é¦–ä½æœ‰å…³ return 0; // æœ‰å”¯ä¸€è§£&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n + 1; j ++ ) scanf(&quot;%lf&quot;, &amp;a[i][j]); int t = gauss(); if (t == 2) puts(&quot;No solution&quot;); else if (t == 1) puts(&quot;Infinite group solutions&quot;); else &#123; for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\\n&quot;, a[i][n]); &#125; return 0;&#125; æ±‚ç»„åˆæ•°æ±‚ç»„åˆæ•°æœ‰å¤šç§æ–¹å¼ï¼Œéœ€è¦æ ¹æ®é¢˜ç›®æ•°æ®èŒƒå›´æ¥é€‰æ‹©åˆé€‚çš„åšæ³• æ±‚ç»„åˆæ•°æœ‰å¤šç§æ–¹å¼ï¼Œè¦æ ¹æ®æ•°æ®çš„èŒƒå›´é€‰æ‹© æ±‚ç»„åˆæ•°1è€ƒè™‘æ‰“è¡¨çš„æ–¹å¼ç›´æ¥å¼„å‡ºæ¥ï¼Œç›´æ¥é¢„å¤„ç†å‡ºæ¥æ¯ä¸€ä¸ªæ•°ï¼Œå¤æ‚åº¦O(n^2^) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=2010,mod=1e9+7;int c[N][N];//å•ç‹¬æŠŠc_ijå¤„ç†å‡ºæ¥void init()&#123; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(!j) c[i][j]=1;//è¾¹ç•Œæ¡ä»¶ï¼Œå½“jä¸º0æ—¶ else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; &#125; &#125;&#125;int main()&#123; int n; init(); scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,c[a][b]); &#125; return 0;&#125; æ±‚ç»„åˆæ•°2é¢„å¤„ç†å‡ºæ¥é˜¶ä¹˜ï¼Œç”¨å…¬å¼è®¡ç®—ç»„åˆæ•°ï¼Œä½†æ˜¯ä¸å­˜åœ¨é™¤æ³•åˆ†å¼€å–æ¨¡çš„ç‰¹å¾ï¼Œæ‰€ä»¥è¦è®¡ç®—é€†å…ƒæ¥åšï¼Œæ‰€ä»¥é¢„å¤„ç†å‡ºæ¥ä¸€ä¸ªæ•°çš„é˜¶ä¹˜å’Œä»–çš„é€†å…ƒ å¤„ç†å‡ºæ¥æ•°çš„é˜¶ä¹˜ï¼Œå’Œæ•°çš„é€†å…ƒçš„ç›¸ä¹˜ç»“æœ ä¸¤ä¸ªlong longçº§åˆ«çš„æ•°ç›¸ä¹˜å°±è¦modä¸€æ¬¡äº†~ï¼Œå¤æ‚åº¦O(NlogN) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=100010,mod=1e9+7;int fact[N],infact[N];//é˜¶ä¹˜å’Œé€†å…ƒint qmi(int a,int k,int p)//å¿«é€Ÿå¹‚&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; //é¢„å¤„ç†å‡ºé˜¶ä¹˜å’Œé€†å…ƒ fact[0]=infact[0]=1;//1çš„é˜¶ä¹˜å’Œé€†å…ƒéƒ½æ˜¯æœ¬èº« for(int i=1;i&lt;N;i++) &#123; fact[i]=(LL)fact[i-1]*i%mod; infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;//å‰é¢é‚£ä¸ªä¹˜ä¸Šiçš„é€†å…ƒ &#125; int n; int a,b; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod); &#125; return 0;&#125; æ±‚ç»„åˆæ•°3é‡‡ç”¨lucuså®šç†æ¥åšï¼šAcWing 887. æ±‚ç»„åˆæ•° III - AcWing å…³é”®çš„ä¸€æ­¥æ˜¯æ¥å‡‘å‡ºb0+b1*p1+â€¦å‡‘å‡ºæ¥b 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;typedef long long LL;int qmi(int a,int k,int p)&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL) res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int C(int a,int b,int p)//ç›´æ¥æ±‚ç»„åˆæ•°&#123; if(b&gt;a) return 0; int res=1; for(int i=1,j=a;i&lt;=b;i++,j--) &#123; res=(LL)res*j%p;//a~a-b+1 res=(LL)res*qmi(i,p-2,p)%p;//bçš„é˜¶ä¹˜çš„é€†å…ƒ &#125; return res;&#125;int lucas(LL a,LL b,int p)&#123; if(a&lt;p&amp;&amp;b&lt;p) return C(a,b,p);//å‡ä¸æ»¡è¶³åˆ™ç›´æ¥æ±‚ return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//lucaså®šç†æ˜¯ä¸ªé€’å½’çš„è¿‡ç¨‹&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); LL a,b; int p; while(n--) &#123; scanf(&quot;%lld%lld%d&quot;,&amp;a,&amp;b,&amp;p); printf(&quot;%d\\n&quot;,lucas(a,b,p)); &#125; return 0;&#125; æ±‚ç»„åˆæ•°4è¦æ±‚æ±‚å‡†ç¡®çš„è§£ï¼Œè€Œä¸æ˜¯æ¨¡ä¸€ä¸ªæ•°ï¼Œå¯ä»¥ç›´æ¥ç”¨å…¬å¼æ¥è®¡ç®—ï¼Œæ¶‰åŠåˆ°é«˜ç²¾åº¦ä¹˜æ³•å’Œé«˜ç²¾åº¦é™¤æ³•ï¼Œæ•ˆç‡è¾ƒä½ æ–¹æ³•æ˜¯å…ˆå°†C(a,b)åˆ†è§£è´¨å› æ•°a!/((a-b)!*(b!))ï¼Œç„¶ååªç”¨é«˜ç²¾åº¦ä¹˜æ³•æ¥åšå³å¯AcWing 888. æ±‚ç»„åˆæ•° IV(é«˜ç²¾åº¦-ç´ æ•°ç»„åˆ) - AcWing é¦–å…ˆç­›1~aä¹‹é—´çš„æ‰€æœ‰è´¨æ•° å†æ±‚æ¯ä¸ªè´¨æ•°çš„æ¬¡æ•° ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†ä¸Šè¿°è´¨æ•°ä¹˜ä¸Š è¿™é‡Œè®¡ç®—æ¯ä¸ªè´¨æ•°çš„æ¬¡æ•°çš„æ–¹æ³•å¦‚ä¸‹ï¼š ä»¥2ä¸ºä¾‹ï¼š å…¶å®ä»£ç é‡Œé¢æ›´å¥½ç†è§£ï¼Œå°±æ˜¯ä¸æ–­åœ°é™¤p 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N=5010;int primes[N],cnt;int sum[N];bool st[N];void get_primes(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!st[i]) primes[cnt++]=i; for(int j=0;primes[j]&lt;=n/i;j++) &#123; st[primes[j]*i]=true; if(i%primes[j]==0) break; &#125; &#125;&#125;int get(int n,int p)//è®¡ç®—nçš„é˜¶ä¹˜&#123; int res=0; while(n) &#123; res+=n/p; n/=p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a,int b)&#123; vector&lt;int&gt; c; int t=0; for(int i=0;i&lt;a.size();i++) &#123; t+=a[i]*b; c.push_back(t%10); t/=10; &#125; while(t) &#123; c.push_back(t%10); t/=10; &#125; return c;&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; get_primes(a);//æ±‚1~aä¹‹é—´çš„è´¨æ•° for(int i=0;i&lt;cnt;i++) &#123; int p=primes[i];//ç¬¬iä¸ªè´¨æ•° sum[i]=get(a,p)-get(a-b,p)-get(b,p);//æ±‚è¿™ä¸ªè´¨æ•°çš„æ¬¡æ•° &#125; vector&lt;int&gt; res; res.push_back(1); for(int i=0;i&lt;cnt;i++) &#123; for(int j=0;j&lt;sum[i];j++) &#123; res=mul(res,primes[i]); &#125; &#125; for(int i=res.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,res[i]); return 0;&#125; æ»¡è¶³æ¡ä»¶çš„01åºåˆ—å‚è€ƒï¼šAcWing 889. æ»¡è¶³æ¡ä»¶çš„01åºåˆ— - AcWingï¼Œå³æ±‚å¡ç‰¹å…°æ•° æ³¨æ„å¿«é€Ÿå¹‚æ±‚é€†å…ƒçš„æ¡ä»¶ï¼Œè¦æ±‚modä¸ºè´¨æ•° é—®é¢˜è½¬æ¢ä¸ºä»0ï¼Œ0èµ°åˆ°nï¼Œnçš„æ»¡è¶³ä¸€å®šæ¡ä»¶çš„è·¯å¾„ï¼Œå°†åºåˆ—ä¸­0çœ‹æˆå‘å³èµ°ï¼Œ1çœ‹æˆå‘ä¸Šèµ°ï¼Œæœ€ç»ˆèµ°åˆ°(n,n)ä½ç½®ï¼Œä½†æ˜¯é¢˜ç›®è¦æ±‚åºåˆ—å‰ç¼€ä¸­0çš„ä¸ªæ•°è¦ä¸å°‘äº1çš„ä¸ªæ•°ï¼Œæ‰€ä»¥x&gt;=yï¼Œä¹Ÿå°±æ˜¯è¯´ä¸èƒ½ç¢°åˆ°çº¢è‰²çš„çº¿ï¼Œé‚£å¦‚ä½•æ±‚ç¢°åˆ°çº¢è‰²çº¿çš„è·¯å¾„æ•°é‡å‘¢ï¼Œä»»ä½•ä¸€ä¸ªç¢°åˆ°çº¢çº¿ç„¶ååˆ°è¾¾(n,n)çš„è·¯å¾„é€šè¿‡çº¢çº¿è¿›è¡Œé•œåƒå¤„ç†ï¼Œæœ€ç»ˆä¸€å®šä¼šé•œåƒåˆ°è¾¾(n-1,n+1)è¿™ä¸ªç‚¹çš„ä¸€æ¡è·¯å¾„ï¼Œæ‰€ä»¥åªéœ€è¦æ±‚å‡ºä»(0,0)åˆ°è¾¾(n-1,n+1)è¿™ä¸ªç‚¹çš„è·¯å¾„æ•°é‡ï¼Œç„¶åç›¸å‡å³å¯ 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010,mod=1e9+7;int qmi(int a,int k,int p)&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n; cin&gt;&gt;n; int a=n*2,b=n; int res=1; for(int i=a;i&gt;a-b;i--) res=(LL)res*i%mod; for(int i=1;i&lt;=b;i++) res=(LL)res*qmi(i,mod-2,mod)%mod;//é€†å…ƒ res=(LL)res*qmi(n+1,mod-2,mod)%mod; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; å®¹æ–¥åŸç† å®ç°çš„æ—¶å€™ä»¥ä½è¿ç®—çš„æ–¹å¼å®ç°ï¼Œå‡è®¾æœ‰nä¸ªæ•°mä¸ªç±»åˆ«ï¼Œåˆ™ä»1~2^m^-1è¿›è¡Œæšä¸¾ï¼Œæ¯ä¸€ä½ä¸Šè¡¨ç¤ºè¯¥ä½ä¸Šçš„é›†åˆæ˜¯å¦å–ï¼Œåœ¨æšä¸¾çš„è¿‡ç¨‹ä¸­è®¡ç®—ä¸Šè¿°ç­‰å¼ èƒ½è¢«æ•´é™¤çš„æ•°1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=20;int p[N];//mä¸ªè´¨æ•°int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) cin&gt;&gt;p[i]; int res=0; for(int i=1;i&lt;1&lt;&lt;m;i++)//1~2^m,çœ‹åšæ˜¯2è¿›åˆ¶ä¸² &#123; int t=1,s=0; for(int j=0;j&lt;m;j++)//è®¡ç®—å…¶ä¸­1çš„ä¸ªæ•° &#123; if(i&gt;&gt;j&amp;1) &#123; if((LL)t*p[j]&gt;n)//é€‰æ‹©çš„è´¨æ•°ä¸ç¬¦åˆè¦æ±‚ &#123; t=-1;//åšä¸ªæ ‡è®°ç„¶åé€€å‡ºå¾ªç¯ break; &#125; t*=p[j]; s++;//é›†åˆä¸­å…ƒç´ çš„æ•°é‡ &#125; &#125; if(t!=-1) &#123; if(s%2) res+=n/t;//å¥‡æ•°ä¸ªæ•°ä¸ºåŠ  else res-=n/t;//å¶æ•°ä¸ªæ•°ä¸ºå‡ &#125; &#125; cout&lt;&lt;res; return 0;&#125; åšå¼ˆè®ºè‹¥ä¸€ä¸ªæ¸¸æˆæ»¡è¶³ï¼š ç”±ä¸¤åç©å®¶äº¤æ›¿è¡ŒåŠ¨åœ¨æ¸¸æˆè¿›è¡Œçš„ä»»æ„æ—¶åˆ»ï¼Œå¯ä»¥æ‰§è¡Œçš„åˆæ³•è¡ŒåŠ¨ä¸è½®åˆ°å“ªä½ç©å®¶æ— å…³ä¸èƒ½è¡ŒåŠ¨çš„ç©å®¶åˆ¤è´Ÿåˆ™ç§°è¯¥æ¸¸æˆä¸ºä¸€ä¸ªå…¬å¹³ç»„åˆæ¸¸æˆã€‚ å°¼å§†æ¸¸æˆï¼ˆNIMï¼‰å±äºå…¬å¹³ç»„åˆæ¸¸æˆï¼Œä½†å¸¸è§çš„æ£‹ç±»æ¸¸æˆï¼Œæ¯”å¦‚å›´æ£‹å°±ä¸æ˜¯å…¬å¹³ç»„åˆæ¸¸æˆï¼Œå› ä¸ºå›´æ£‹äº¤æˆ˜åŒæ–¹åˆ†åˆ«åªèƒ½è½é»‘å­å’Œç™½å­ï¼Œèƒœè´Ÿåˆ¤å®šä¹Ÿæ¯”è¾ƒè´Ÿè´£ï¼Œä¸æ»¡è¶³æ¡ä»¶2å’Œ3ã€‚ Nimæ¸¸æˆaiæ˜¯æ¯å †ä¸­æ•°é‡ å…ˆæ‰‹å¿…èƒœçŠ¶æ€ï¼šå…ˆæ‰‹æ“ä½œå®Œï¼Œå¯ä»¥èµ°åˆ°æŸä¸€ä¸ªå¿…è´¥çŠ¶æ€ï¼ˆç»™å¯¹æ–¹ç•™ä¸‹å¿…è´¥çŠ¶æ€ï¼‰å…ˆæ‰‹å¿…è´¥çŠ¶æ€ï¼šå…ˆæ‰‹æ“ä½œå®Œï¼Œèµ°ä¸åˆ°ä»»ä½•ä¸€ä¸ªå¿…è´¥çŠ¶æ€ï¼ˆé˜Ÿé¦–ä¸å¤„äºå¿…è´¥æ€ï¼Œè‡ªå·±å¤„äºï¼‰å…ˆæ‰‹å¿…è´¥çŠ¶æ€ï¼ša1 ^ a2 ^ a3 ^ â€¦ ^an = 0å…ˆæ‰‹å¿…èƒœçŠ¶æ€ï¼ša1 ^ a2 ^ a3 ^ â€¦ ^an â‰  0 è¯æ˜ï¼š å¯¹äºå…ˆæ‰‹ï¼Œå¦‚æœé‡åˆ°å…¨0çš„å±€é¢ï¼Œåˆ™è´¥ å¦‚æœå…ˆæ‰‹é‡åˆ°å¼‚æˆ–ä¸ä¸º0çš„æƒ…å†µï¼Œå‡è®¾å¼‚æˆ–ç»“æœä¸ºxï¼Œå‡è®¾xçš„æœ€é«˜ä½1æ‰€åœ¨ä½ä¸ºkï¼Œåˆ™è‡³å°‘å­˜åœ¨aiç¬¬kä½ä¸º1ï¼Œaiå¼‚æˆ–x&lt;ai,æ‰€ä»¥åœ¨å–çš„è¿‡ç¨‹ä¸­å¯ä»¥å°†aiå–ä¸º(aiå¼‚æˆ–x)çš„çŠ¶æ€ï¼Œå› ä¸ºxæ˜¯a1~ançš„å¼‚æˆ–ï¼Œå°†aiå–å®Œä¹‹åä¸€å®šèƒ½å°†å¼‚æˆ–ç»“æœè½¬ä¸º0ï¼Œåæ‰‹å¿…è´¥ï¼Œå…ˆæ‰‹å¿…èƒœ å¦‚æœå…ˆæ‰‹é‡åˆ°å¼‚æˆ–ä¸º0çš„æƒ…å†µï¼Œåˆ™æ— è®ºæ€ä¹ˆå–ï¼Œå¼‚æˆ–ç»“æœéƒ½ä¸æ˜¯0.ä¹Ÿå°±æ˜¯å¯¹æ‰‹å¿…èƒœæ€ï¼Œåè¯æ³•ï¼šå‡è®¾å–å®Œåå¼‚æˆ–ç»“æœä¸º0ï¼Œå–çš„é¡¹aiå˜æˆäº†aiâ€™,åˆ™å°†å‰åä¸¤æ¬¡é¡¹è¿›è¡Œå¼‚æˆ–ï¼ša1\\^a2â€¦\\^ai\\^an ^ a1\\^a2\\^â€¦\\^aiâ€˜\\^an=ai\\^aiâ€™ï¼Œå¦‚æœæ˜¯0ï¼Œåˆ™ai=aiâ€™,åˆ™ä¸æ»¡è¶³å–è¿™ä¸€åŠ¨ä½œï¼Œæ•…ä¸å¯èƒ½ä¸º0 12345678910111213141516#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int main()&#123; int n,tmp,x=0; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d&quot;,&amp;tmp); x^=tmp; &#125; if(x) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; å°é˜¶-Nimæ¸¸æˆå¦‚æœå…ˆæ‰‹æ—¶å¥‡æ•°å°é˜¶ä¸Šçš„å€¼çš„å¼‚æˆ–å€¼ä¸º0ï¼Œåˆ™å…ˆæ‰‹å¿…è´¥ï¼Œåä¹‹å¿…èƒœ æ³¨æ„åˆ¤æ–­å¥‡æ•°çš„å¤„ç†:i&amp;1 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+10;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int res=0; for(int i=1;i&lt;=n;i++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(i&amp;1) res^=x;//å¥‡æ•°å°é˜¶ä¸Šçš„ &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; é›†åˆ-Nimæ¸¸æˆAcWing 893. é›†åˆ-Nimæ¸¸æˆ - AcWing ç”¨åˆ°äº†sgæ•°ç»„ï¼Œsgæ•°ç»„é€šè¿‡mexå‡½æ•°å®šä¹‰ï¼Œsg=mex{sg(åç»§)}ï¼Œå³åœ¨åç»§ä¸­æœªå‡ºç°çš„æœ€å°çš„éè´Ÿæ•´æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;unordered_set&gt;#include &lt;cstring&gt;using namespace std;const int N=110,M=10010;int n,m;int s[N],f[M];//åˆ†åˆ«å­˜å‚¨å¯æ‹¿çš„çŸ³å­æ•°é‡å’Œæ¯å †çŸ³å­æ•°é‡//è®°å¿†åŒ–æœç´¢ï¼Œæ³¨æ„åˆ°ç›¸åŒçš„xå¾—åˆ°çš„å€¼åº”è¯¥æ˜¯ä¸€æ ·çš„ï¼Œsgçš„æ ‘ç»“æ„ç”»èµ·æ¥æ˜¯ä¸€æ ·çš„int sg(int x)//æ ¹æ®sgçš„å®šä¹‰æ±‚sgå€¼&#123; if(f[x]!=-1) return f[x];//è®°å¿†åŒ–æœç´¢ unordered_set&lt;int&gt; S; for(int i=0;i&lt;n;i++)//å¯¹æ¯ç§å–æ³•è¿›è¡Œè®¨è®º &#123; int sum=s[i]; if(x&gt;=sum) S.insert(sg(x-sum)); &#125; for(int i=0;;i++)//æŒ‰ç…§sgçš„å®šä¹‰å‘åå¯»æ‰¾æœªå‡ºç°çš„é0æ•´æ•° &#123; if(!S.count(i)) return f[x]=i; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;s[i]); scanf(&quot;%d&quot;,&amp;m); memset(f,-1,sizeof f); int res=0; for(int i=0;i&lt;m;i++) &#123; int x; scanf(&quot;%d&quot;,&amp;x);//å°†æ¯ä¸ªæœ‰å‘å›¾é¡¶ç‚¹sgå€¼å¼‚æˆ– res^=sg(x); &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; æ‹†åˆ†-Nimæ¸¸æˆsg(b1,b2)=sg(b1)$\\and$sg(b2) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unordered_set&gt;using namespace std;const int N=110;int n;int f[N];int sg(int x)&#123; if(f[x]!=-1) return f[x]; unordered_set&lt;int&gt; set; for(int i=0;i&lt;x;i++)//ä¸¤å †çš„æ‰€æœ‰ç»“æœ &#123; for(int j=0;j&lt;x;j++) &#123; set.insert(sg(i)^sg(j)); &#125; &#125; for(int i=0;;i++)//æŒ‰ç…§sgçš„å®šä¹‰ï¼Œå»mexï¼Œæœªå‡ºç°çš„ &#123; if(!set.count(i)) &#123; return f[x]=i; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); memset(f,-1,sizeof f); int res=0; while(n--) &#123; int x; cin&gt;&gt;x; res^=sg(x); &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; åŠ¨æ€è§„åˆ’ DPéœ€è¦æ³¨æ„åˆå§‹åŒ–â€”â€”from xiao èƒŒåŒ…é—®é¢˜0-1èƒŒåŒ…é—®é¢˜ï¼šæ¯ä»¶ç‰©å“æœ€å¤šä½¿ç”¨ä¸€æ¬¡ å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼šæ¯ä»¶ç‰©å“æœ‰æ— é™ä¸ª å¤šé‡èƒŒåŒ…é—®é¢˜ï¼šæ¯ä»¶ç‰©å“æœ‰s[i]ä¸ªï¼Œæœ‰ä¸€ç§ä¼˜åŒ–è®¡ç®—æ–¹å¼ åˆ†ç»„èƒŒåŒ…é—®é¢˜ï¼šæœ‰å¤šä¸ªç»„ï¼Œæ¯ç»„é‡Œåªèƒ½é€‰ä¸€ä¸ª ä¼˜åŒ–å’Œå˜å½¢éƒ½æ˜¯åœ¨åŸæ–¹ç¨‹åŸºç¡€ä¸Šè¿›è¡Œçš„ç­‰ä»·å˜å½¢ï¼Œé™ç»´çš„æ—¶å€™å¦‚æœç”¨åˆ°çš„æ˜¯ä¸Šä¸€å±‚çš„çŠ¶æ€ï¼Œå°±è¦é€†åºæšä¸¾ï¼Œå¦‚æœç”¨åˆ°çš„æ˜¯æœ¬å±‚çš„çŠ¶æ€ï¼Œå°±è¦é¡ºåºæšä¸¾ 0-1èƒŒåŒ…é—®é¢˜ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int V[N],W[N];int n,v;int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=v;j++) &#123; if(j&gt;=V[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-V[i]]+W[i]); else dp[i][j]=dp[i-1][j]; &#125; &#125; cout&lt;&lt;dp[n][v]; return 0;&#125; é™ç»´å 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N=1010;int V[N],W[N];int n,v;int dp[N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=v;j&gt;=V[i];j--)//æ³¨æ„é€†åºï¼Œå› ä¸ºdp[j-v]é¡¹éœ€è¦ç”¨åˆ°ä¹‹å‰çš„é¡¹ï¼Œå¦‚æœæ­£åºè®¡ç®—ï¼Œä¼šè¢«æå‰è¦†ç›– &#123; dp[j]=max(dp[j],dp[j-V[i]]+W[i]); &#125; &#125; cout&lt;&lt;dp[v]; return 0;&#125; å®Œå…¨èƒŒåŒ…é—®é¢˜æ¯ä¸ªç‰©å“æ— æ•°ä¸ª æœ´ç´ åšæ³• 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=1010;int dp[N][N];int n,c;int w[N],v[N];int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=dp[i-1][j]; for(int k=1;k*w[i]&lt;=j;k++)//ç±»ä¼¼äºdpæ•°ç»„çš„æ–¹æ³•æ¥è®¡ç®— &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]); &#125; &#125; &#125; cout&lt;&lt;dp[n][c]; return 0;&#125; ä¼˜åŒ–åšæ³•ï¼šæ›¿æ¢å…¬å¼ 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int dp[N][N];int n,c;int w[N],v[N];int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=dp[i-1][j]; if(j&gt;=w[i]) dp[i][j]=max(dp[i][j],dp[i][j-w[i]]+v[i]); &#125; &#125; cout&lt;&lt;dp[n][c]; return 0;&#125; ç»ˆæä¼˜åŒ–ï¼šæ›¿æ¢å…¬å¼+é™ç»´ ï¼Œæ³¨æ„æ˜¯é¡ºåºçš„ 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;int f[N];int n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int v,w; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v&gt;&gt;w; for(int j=v;j&lt;=m;j++)//æ³¨æ„è¿™é‡Œæ˜¯é¡ºåºçš„ï¼Œå› ä¸ºç”¨çš„j-væ˜¯iä½œä¸ºå‰é¡¹çš„ï¼Œæ˜¯æ›´æ–°è¦†ç›–ä¹‹åçš„ &#123; f[j]=max(f[j],f[j-v]+w); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; å¤šé‡èƒŒåŒ…é—®é¢˜æ¯ä¸ªç‰©å“æœ‰é™ä¸ªï¼Œå…·ä½“æœ‰s[i]ä¸ª 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=110;int n,v;int V[N],S[N],W[N];int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;S[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=v;j++) &#123; for(int k=0;k&lt;=S[i]&amp;&amp;j&gt;=k*V[i];k++) &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-k*V[i]]+k*W[i]); &#125; &#125; &#125; cout&lt;&lt;dp[n][v]; return 0;&#125; äºŒè¿›åˆ¶ä¼˜åŒ– ä¼˜åŒ–çš„æ€æƒ³ï¼šå°†ç¬¬iç»„å¯æ‹¿çš„s[i]ä¸ªç‰©å“è¿›è¡Œæ‹†åˆ†ï¼ŒæŒ‰ç…§äºŒè¿›åˆ¶è¿›è¡Œæ‰“åŒ…æˆä¸€ä¸ªç‰©å“ï¼Œåªéœ€è¦å¯¹æ‹†åˆ†åçš„$log(s)$ä¸ªç‰©å“è¿›è¡Œé€‰æˆ–è€…ä¸é€‰ï¼Œå°±èƒ½ç­‰æ•ˆäºå¯¹s[i]ä¸ªç‰©å“é€‰çš„æ•°é‡ï¼Œå…·ä½“å°†s[i]ä¸ªç‰©å“æ‹†åˆ†æˆ: 1 , 2 , 4 , 2^k^ , c ,å…¶ä¸­1+2+4+â€¦+2^k^&lt;=s[i]ï¼Œä½†k+1æ¬¡æ–¹ä¸æ»¡è¶³è¯¥æ¡ä»¶ï¼Œcæ˜¯s[i]-(1+2+4+â€¦+2^k^) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N=20000,M=2010;int V[N],W[N];int n,v;int f[M];int main()&#123; cin&gt;&gt;n&gt;&gt;v; int a,b,s; int cnt=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k=1; while(k&lt;=s) &#123; cnt++; V[cnt]=a*k; W[cnt]=b*k; s=s-k; k=k*2; &#125; if(s&gt;0) &#123; cnt++; V[cnt]=s*a; W[cnt]=s*b; &#125; &#125; n=cnt; for(int i=1;i&lt;=n;i++) &#123; for(int j=v;j&gt;=V[i];j--) &#123; f[j]=max(f[j],f[j-V[i]]+W[i]); &#125; &#125; cout&lt;&lt;f[v];&#125; åˆ†ç»„èƒŒåŒ…é—®é¢˜åˆ†æˆå¤šä¸ªç»„ï¼Œæ¯ç»„ä¹‹ä¸­åªèƒ½é€‰0ä¸ªæˆ–è€…1ä¸ª äºŒç»´dpï¼š é™ç»´ä¼˜åŒ–ï¼š 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=110;int n,m;int v[N][N],w[N][N],s[N];int f[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i]; for(int j=1;j&lt;=s[i];j++) &#123; cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=0;j--) &#123; for(int k=1;k&lt;=s[i];k++) &#123; if(v[i][k]&lt;=j) &#123; f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125; &#125; cout&lt;&lt;f[m]; return 0;&#125; çº¿æ€§DPçº¿æ€§æŒ‡é€’æ¨æœ‰ä¸ªæ¨¡ç³Šçš„é¡ºåºï¼Œå¦‚èƒŒåŒ…é—®é¢˜çš„äºŒç»´è¡¨ä»å·¦åˆ°å³ æ•°å­—ä¸‰è§’å½¢ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510, INF = 1e9;int n;int a[N][N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 0; i &lt;= n; i ++ )//å› ä¸ºé€’æ¨å¼éœ€è¦ç”¨åˆ°[i-1,j-1]å’Œ[i-1,j]é¡¹,æ•…éœ€è¦åˆå§‹åŒ–ä¸ºè´Ÿæ— ç©·,é¿å…é€‰æ‹©è¯¥è·¯å¾„ for (int j = 0; j &lt;= i + 1; j ++ ) f[i][j] = -INF; f[1][1] = a[1][1]; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]); int res = -INF; for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[n][i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; æœ€é•¿ä¸Šå‡å­åºåˆ—ä¸€ 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;const int N=1010;int n;int a[N];int f[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); f[i]=1; &#125; for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;i;j++) &#123; if(a[j]&lt;a[i]) &#123; f[i]=max(f[i],f[j]+1); &#125; &#125; &#125; int res=0; for(int i=1;i&lt;=n;i++) &#123; res=max(res,f[i]); &#125; cout&lt;&lt;res; return 0;&#125; æœ€é•¿ä¸Šå‡å­åºåˆ—è´°é‡‡ç”¨ç±»ä¼¼å•è°ƒé˜Ÿåˆ—çš„æ ·å­ï¼Œs[i]å­˜å‚¨é•¿åº¦ä¸ºiçš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„æœ€å°çš„æœ«å°¾å…ƒç´ ï¼Œå¯è¯æ˜så­˜å‚¨çš„ç»“æœä¸€å®šæ˜¯ä¸¥æ ¼å•è°ƒé€’å¢çš„ï¼Œè¯æ˜ï¼š å‡è®¾s[i]=s[i+1],åˆ™å¯çŸ¥å¯¹äºé•¿åº¦ä¸ºi+1çš„å­åºåˆ—ï¼Œå…¶æœ€å°çš„æœ«å°¾å…ƒç´ æ˜¯s[i+1]ï¼Œé‚£è¿™ä¸ªåºåˆ—çš„ç¬¬iä¸ªå…ƒç´ ä¸€å®šå°äºs[i+1]ï¼Œä¸s[i]=s[i+1]ä¸ç¬¦ï¼Œæ•…å¯è¯ï¼›è‹¥s[i]&gt;s[i+1]ï¼ŒåŒç†å¯è¯ æ‰€ä»¥sæ•°ç»„ä¸€å®šæ˜¯å•è°ƒé€’å¢çš„ï¼Œå½“æ’å…¥ä¸€ä¸ªæ–°çš„æ•°hæ—¶ï¼Œå…ˆæ‰¾åˆ°æœ€å¤§çš„æ¯”hå°çš„æ•°s[k]ï¼Œå¯çŸ¥ç”±äºs[k]æ˜¯é•¿åº¦ä¸ºkçš„å­åºåˆ—ä¸­æœ«å°¾å…ƒç´ æœ€å°çš„ï¼Œæ‰€ä»¥hä¸è¯¥åºåˆ—æ‹¼æ¥å¯ä»¥å¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸ºk+1çš„å­åºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å°†å…¶ä¸s[k+1]çš„å¤§å°è¿›è¡Œæ¯”è¾ƒï¼Œåˆ¤æ–­æ˜¯å¦èƒ½æ›¿æ¢ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],f[N];int cnt;int find(int x)&#123; int l=1,r=cnt; while(l&lt;r)//ç­‰ä»·äºæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”xå¤§çš„è¿›è¡Œæ›¿æ¢ &#123; int mid=l+r&gt;&gt;1; if(f[mid]&gt;=x) r=mid; else l=mid+1; &#125; return l;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; f[++cnt]=a[1];//ä»1å¼€å§‹ for(int i=2;i&lt;=n;i++) &#123; if(a[i]&gt;f[cnt]) f[++cnt]=a[i]; else&#123; int idx=find(a[i]);//æ‰¾åˆ°fä¸­ç¬¬ä¸€ä¸ªå¤§äºç­‰äºa[i]çš„ç”¨a[i]æ›¿æ¢ f[idx]=a[i]; &#125; &#125; cout&lt;&lt;cnt; return 0;&#125; æœ€é•¿å…¬å…±å­åºåˆ—ä¹¦ä¸Šçš„è§£é‡Šæ˜¯ï¼š æ³¨æ„è¿™é‡Œçš„f[i-1,j]æ˜¯åŒ…å«01å’Œ00çš„ï¼Œè€Œä¸æ˜¯å‡†ç¡®è¡¨ç¤ºå‡ºç¬¬jä¸ªä¸€å®šé€‰ï¼Œä¹Ÿå°±æ˜¯è¯´f[i-1,j]é¡¹ä¸f[i-1,j-1]é‡å ï¼Œä½†ç”±äºæ±‚çš„æ˜¯maxï¼Œæ‰€ä»¥ä¸è¦æ±‚ä¸é‡å¤ï¼Œç”±äºf[i-1,j]å’Œf[i,j-1]åŒ…å«äº†f[i-1,j-1]ï¼Œæ‰€ä»¥æ— éœ€å†æ¯”è¾ƒf[i-1,j-1] 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1010;int n,m;char a[N];char b[N];int f[N][N];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) &#123; f[i][j]=max(f[i][j],f[i-1][j-1]+1); &#125; &#125; &#125; cout&lt;&lt;f[n][m]; return 0;&#125; ç¼–è¾‘è·ç¦» 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int n,m;char a[N],b[N];int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;a+1; cin&gt;&gt;m&gt;&gt;b+1; for(int i=1;i&lt;=n;i++) dp[i][0]=i; for(int j=1;j&lt;=m;j++) dp[0][j]=j; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1); if(a[i]==b[j]) dp[i][j]=min(dp[i][j],dp[i-1][j-1]); else dp[i][j]=min(dp[i][j],dp[i-1][j-1]+1); &#125; &#125; cout&lt;&lt;dp[n][m]; return 0;&#125; åŒºé—´DPåŒºé—´ DP å¸¸ç”¨æ¨¡ç‰ˆ æ‰€æœ‰çš„åŒºé—´dpé—®é¢˜æšä¸¾æ—¶ï¼Œç¬¬ä¸€ç»´é€šå¸¸æ˜¯æšä¸¾åŒºé—´é•¿åº¦ï¼Œå¹¶ä¸”ä¸€èˆ¬ len = 1 æ—¶ç”¨æ¥åˆå§‹åŒ–ï¼Œæšä¸¾ä» len = 2 å¼€å§‹ï¼›ç¬¬äºŒç»´æšä¸¾èµ·ç‚¹ i ï¼ˆå³ç«¯ç‚¹ j è‡ªåŠ¨è·å¾—ï¼Œj = i + len - 1ï¼‰ï¼Œä»å°åŒºé—´åˆ°å¤§åŒºé—´ï¼Œä»¥ä½¿å¾—å¤§åŒºé—´èƒ½ä½¿ç”¨å°åŒºé—´çš„è§£ æ¨¡æ¿ä»£ç å¦‚ä¸‹ï¼š 123456789101112for (int len = 1; len &lt;= n; len++) &#123; // åŒºé—´é•¿åº¦ for (int i = 1; i + len - 1 &lt;= n; i++) &#123; // æšä¸¾èµ·ç‚¹ int j = i + len - 1; // åŒºé—´ç»ˆç‚¹ if (len == 1) &#123; dp[i][j] = åˆå§‹å€¼ continue; &#125; for (int k = i; k &lt; j; k++) &#123; // æšä¸¾åˆ†å‰²ç‚¹ï¼Œæ„é€ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); &#125; &#125;&#125; å¦‚ä¸Šå¾ªç¯æ¨¡å¼æ˜¯å› ä¸ºè¦ä¿è¯è®¡ç®—dp[i][j]æ—¶å…¶ä¾èµ–çš„è¾ƒå°çš„åŒºé—´çš„dpå€¼å·²ç»è®¡ç®—å¾—åˆ°äº† çŸ³å­åˆå¹¶ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=310;int s[N];int f[N][N];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); &#125; for(int i=1;i&lt;=n;i++) s[i]+=s[i-1]; for(int len=2;len&lt;=n;len++) &#123; for(int i=1;i+len-1&lt;=n;i++) &#123; int l=i,r=i+len-1; f[l][r]=1e8; for(int k=l;k&lt;r;k++) &#123; f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); &#125; &#125; &#125; cout&lt;&lt;f[1][n]; return 0;&#125; è®¡æ•°ç±»DPæ•´æ•°åˆ’åˆ†é—®é¢˜æ–¹æ³•ä¸€ è½¬æ¢ä¸ºå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œf[i][j]è¡¨ç¤ºç”¨å‰iä¸ªæ•°å‡‘å‡ºjçš„æ–¹æ¡ˆæ•°ï¼Œæ˜“çŸ¥æ ¹æ®æœ€åä¸€ä¸ªæ•°çš„å¤šå°‘è¿›è¡Œåˆ’åˆ†è®¡ç®—æœ€åæ±‚å’Œ 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N=1010,mod=1e9+7;int n;int f[N][N];int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) f[i][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; f[i][j]=f[i-1][j]; for(int k=1;k*i&lt;=j;k++) &#123; f[i][j]=(f[i][j]+f[i-1][j-k*i])%mod; &#125; &#125; &#125; cout&lt;&lt;f[n][n]; return 0;&#125; åˆ©ç”¨ä¸€ä¸‹å˜å½¢ 1234567891011121314151617181920212223242526// f[i][j] = f[i - 1][j] + f[i][j - i]#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 7, mod = 1e9 + 7;int f[N][N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt;= n; i ++) &#123; f[i][0] = 1; // å®¹é‡ä¸º0æ—¶ï¼Œå‰ i ä¸ªç‰©å“å…¨ä¸é€‰ä¹Ÿæ˜¯ä¸€ç§æ–¹æ¡ˆ &#125; for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 0; j &lt;= n; j ++) &#123; f[i][j] = f[i - 1][j] % mod; // ç‰¹æ®Š f[0][0] = 1 if (j &gt;= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; &#125; &#125; cout &lt;&lt; f[n][n] &lt;&lt; endl;&#125; é™ç»´â€”â€”æœ€ç»ˆå†™æ³•ï¼š 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N=1010,mod=1e9+7;int n;int dp[N];int main()&#123; cin&gt;&gt;n; dp[0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; dp[j]=(dp[j]+dp[j-i])%mod; &#125; &#125; cout&lt;&lt;dp[n]; return 0;&#125; æ–¹æ³•äºŒ çŠ¶æ€è¡¨ç¤ºï¼šf[i][j]è¡¨ç¤ºæ€»å’Œä¸ºiï¼Œæ€»ä¸ªæ•°ä¸ºjçš„æ–¹æ¡ˆæ•° çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šf[i][j] = f[i - 1][j - 1] + f[i - j][j]; 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main()&#123; cin &gt;&gt; n; f[1][1] = 1; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; æ•°ä½ç»Ÿè®¡DPè®¡æ•°é—®é¢˜åˆ†æƒ…å†µè®¨è®º é—®é¢˜è½¬æ¢ä¸ºæ±‚1~nè¿™äº›æ•°ä¸­æ•°å­—iå‡ºç°çš„æ¬¡æ•°ï¼Œå‡è®¾nä¸€å…±æœ‰7ä½ï¼Œå¦‚abcdefgï¼Œç°åœ¨æˆ‘ä»¬è€ƒè™‘ç¬¬4ä½ï¼ˆdï¼‰ä¸Šæ•°å­—iå‡ºç°çš„æ¬¡æ•°ï¼Œæˆ‘ä»¬æ„é€ çš„æ•°ä¸ºxxxiyyy è‹¥dä¸ä¸º0ï¼Œxxxå–000~abc-1ï¼Œyyyå¯¹äºæ¯ç§xxxçš„å–æ³•éƒ½å¯ä»¥å–000~999,æ•…ä¸ºabc*1000 è‹¥dä¸º0ï¼Œåˆ™xxxä¸èƒ½å–000ï¼Œå› ä¸º000 0 123å†™åš123ï¼Œå®é™…ä¸Šä¸ä¼šå†™å‡ºè¿™ä¸ª0ï¼Œæ‰€ä»¥è¿™é‡Œxxxåªèƒ½å–001~abc-1ï¼Œyyyå–000~999,æ•…ä¸º(abc-1)*1000 è‹¥XXXå–abcï¼Œæ­¤æ—¶è‹¥d&gt;iï¼Œåˆ™yyyå¯å–000~999,æ•…ä¸º1000 è‹¥XXXå–abcï¼Œæ­¤æ—¶è‹¥d=iï¼Œåˆ™yyyå¯å–000~efgï¼Œæ•…ä¸ºefg+1ï¼Œè‹¥d&lt;iä¸èƒ½å– 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# include &lt;iostream&gt;# include &lt;cmath&gt;using namespace std;int dgt(int n) // è®¡ç®—æ•´æ•°næœ‰å¤šå°‘ä½&#123; int res = 0; while (n) ++ res, n /= 10; return res;&#125;int cnt(int n, int i) // è®¡ç®—ä»1åˆ°nçš„æ•´æ•°ä¸­æ•°å­—iå‡ºç°å¤šå°‘æ¬¡ &#123; int res = 0, d = dgt(n); for (int j = 1; j &lt;= d; ++ j) // ä»å³åˆ°å·¦ç¬¬jä½ä¸Š æ•°å­—iå‡ºç°å¤šå°‘æ¬¡ &#123; // lå’Œræ˜¯ç¬¬jä½å·¦è¾¹å’Œå³è¾¹çš„æ•´æ•° (è§†é¢‘ä¸­çš„abcå’Œefg); djæ˜¯ç¬¬jä½çš„æ•°å­— int p = pow(10, j - 1), l = n / p / 10, r = n % p, dj = n / p % 10; // è®¡ç®—ç¬¬jä½å·¦è¾¹çš„æ•´æ•°å°äºl (è§†é¢‘ä¸­l = 000 ~ abc - 1)çš„æƒ…å†µ å·¦è¾¹ä¸ç­‰äºabcçš„æ—¶å€™ è¯´æ˜éƒ½æ˜¯æ¯”abcå°çš„æ•°å­— if (i) res += l * p; //å¦‚æœä¸æ˜¯ç»Ÿè®¡æ•°å­—0 å·¦è¾¹ç›´æ¥ä¹˜på°±è¡Œäº† n=ab3xxx p=1000 //n=1236055 6000-6999è¿™é‡Œ1000 ç¬¬jä½ä¸Šçš„6å‡ºç°äº†pæ¬¡ ä½†æ˜¯å·¦è¾¹è¿˜æœ‰16000-16999 26000-26999 36000-36999...1226000-1226999 å…±å·¦è¾¹æ•°å­—lï¼ˆå³123ï¼‰ä¸ª æ‰€ä»¥æ˜¯l*p else if (!i &amp;&amp; l) res += (l - 1) * p; // ç»Ÿè®¡çš„æ•°å­—i = 0, å·¦è¾¹é«˜ä½ä¸èƒ½å…¨ä¸º0(è§†é¢‘ä¸­xxx = 001 ~ abc - 1) //å°‘äº†0000-0999çš„ä¸€ç§æƒ…å†µ ä»10000-10999 å¼€å§‹ ... 1220000-1220999 13000-13999 å…±(l-1)æ¬¡ // è®¡ç®—ç¬¬jä½å·¦è¾¹çš„æ•´æ•°ç­‰äºl (è§†é¢‘ä¸­l = abc)çš„æƒ…å†µ åªä¼šå’Œ*jä½åé¢çš„æ•°*æœ‰å…³//ä¸‹é¢å°±æ˜¯lçš„å·¦è¾¹ç›¸ç­‰çš„æƒ…å†µ å¯¹ç¬¬jä½ä¸Š ä¸ä¼šå¤šç®—6000-6999 ...1226000-1226999é‡Œé¢çš„ä»»æ„ä¸ªé›†åˆ 123å¼€å§‹çš„æƒ…å†µ if ( (dj &gt; i) &amp;&amp; (i || l) ) res += p;//ç¬¬jä½æ¯”ç°åœ¨ç»Ÿè®¡çš„æ•°å­—å¤§ å°±å¯ä»¥ç›´æ¥åŠ ä¸Špä¸­æƒ…å†µ // n=1236055 åˆ™æœ‰1235000-1235999 999+1ç§æƒ…å†µ å³pç§ //å½“ç»Ÿè®¡çš„æ•°å­—i==0 ä¸” l==0ï¼Œ ä¸¾ä¾‹ n=123456 l==0 ç¬¬jä½ä¸º1 å°±æ˜¯p=100000 æ­¤æ—¶000000-099999æ˜¯ä¸æˆç«‹çš„ å› ä¸ºæˆ‘è¦ç»Ÿè®¡ç¬¬jä½ä¸ºiçš„æ—¶å€™ æœ‰å¤šå°‘ä¸ªè¿™æ ·çš„ æ•° è€Œæ­¤æ—¶ 000000-099999 æ˜¾ç„¶å’Œ 100000-199999 ç¬¬j-1ä½ä¸º2çš„æ—¶å€™é‡å¤äº† if ( (dj == i) &amp;&amp; (i || l) ) res += r + 1;//è¿™æ˜¯ræœ‰å¤šå°‘ä¸ª å°±æ˜¯å¤šå°‘ä¸ª+1//if(dj==i) n=1236055 1236000-1236055 å³55+1ç§æƒ…å†µ//å½“ç»Ÿè®¡çš„æ•°å­—i==0 ä¸” l==0ï¼Œ ä¸¾ä¾‹ n=123456 l==0ä¸”i==0 å°±æ˜¯000000 -0123456 è€Œè¿™ä¸ªæ—¶å€™æ˜¾ç„¶å’Œ ç¬¬j-1çš„ä½çš„æ—¶å€™é‡å¤äº†100000-109999//if(dj&gt;i) n=1236000 åˆ™æœ‰1237000-1237999 æ‰€ä»¥æ˜¯0 &#125; return res;&#125;int main()&#123; int a, b; while (cin &gt;&gt; a &gt;&gt; b , a) &#123; if (a &gt; b) swap(a, b); for (int i = 0; i &lt;= 9; ++ i) cout &lt;&lt; cnt(b, i) - cnt(a - 1, i) &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; return 0;&#125; çŠ¶æ€å‹ç¼©DPè’™å¾·é‡Œå®‰çš„æ¢¦æƒ³ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 12, M = 1&lt;&lt; N; long long f[N][M] ;// ç¬¬ä¸€ç»´è¡¨ç¤ºåˆ—ï¼Œ ç¬¬äºŒç»´è¡¨ç¤ºæ‰€æœ‰å¯èƒ½çš„çŠ¶æ€bool st[M]; //å­˜å‚¨æ¯ç§çŠ¶æ€æ˜¯å¦æœ‰å¥‡æ•°ä¸ªè¿ç»­çš„0ï¼Œå¦‚æœå¥‡æ•°ä¸ª0æ˜¯æ— æ•ˆçŠ¶æ€ï¼Œå¦‚æœæ˜¯å¶æ•°ä¸ªé›¶ç½®ä¸ºtrueã€‚//vector&lt;int &gt; state[M]; //äºŒç»´æ•°ç»„è®°å½•åˆæ³•çš„çŠ¶æ€vector&lt;vector&lt;int&gt;&gt; state(M); //ä¸¤ç§å†™æ³•ç­‰ä»·:äºŒç»´æ•°ç»„int m, n;int main() &#123; while (cin &gt;&gt; n &gt;&gt; m, n || m) &#123; //è¯»å…¥nå’Œmï¼Œå¹¶ä¸”ä¸æ˜¯ä¸¤ä¸ª0å³åˆæ³•è¾“å…¥å°±ç»§ç»­è¯»å…¥ //ç¬¬ä¸€éƒ¨åˆ†ï¼šé¢„å¤„ç†1 //å¯¹äºæ¯ç§çŠ¶æ€ï¼Œå…ˆé¢„å¤„ç†æ¯åˆ—ä¸èƒ½æœ‰å¥‡æ•°ä¸ªè¿ç»­çš„0 for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) &#123; int cnt = 0 ;//è®°å½•è¿ç»­çš„0çš„ä¸ªæ•° bool isValid = true; // æŸç§çŠ¶æ€æ²¡æœ‰å¥‡æ•°ä¸ªè¿ç»­çš„0åˆ™æ ‡è®°ä¸ºtrue for(int j = 0; j &lt; n; j ++) &#123; //éå†è¿™ä¸€åˆ—ï¼Œä»ä¸Šåˆ°ä¸‹ if ( (i &gt;&gt; j) &amp; 1) &#123; //i &gt;&gt; jä½è¿ç®—ï¼Œè¡¨ç¤ºiï¼ˆiåœ¨æ­¤å¤„æ˜¯ä¸€ç§çŠ¶æ€ï¼‰çš„äºŒè¿›åˆ¶æ•°çš„ç¬¬jä½ï¼› // &amp;1ä¸ºåˆ¤æ–­è¯¥ä½æ˜¯å¦ä¸º1ï¼Œå¦‚æœä¸º1è¿›å…¥if if (cnt &amp; 1) &#123; //è¿™ä¸€ä½ä¸º1ï¼Œçœ‹å‰é¢è¿ç»­çš„0çš„ä¸ªæ•°ï¼Œå¦‚æœæ˜¯å¥‡æ•°ï¼ˆcnt &amp;1ä¸ºçœŸï¼‰åˆ™è¯¥çŠ¶æ€ä¸åˆæ³• isValid =false; break; &#125; cnt = 0; // æ—¢ç„¶è¯¥ä½æ˜¯1ï¼Œå¹¶ä¸”å‰é¢ä¸æ˜¯å¥‡æ•°ä¸ª0ï¼ˆç»è¿‡ä¸Šé¢çš„ifåˆ¤æ–­ï¼‰ï¼Œè®¡æ•°å™¨æ¸…é›¶ã€‚ //å…¶å®æ¸…ä¸æ¸…é›¶æ²¡æœ‰å½±å“ &#125; else cnt ++; //å¦åˆ™çš„è¯è¯¥ä½è¿˜æ˜¯0ï¼Œåˆ™ç»Ÿè®¡è¿ç»­0çš„è®¡æ•°å™¨++ã€‚ &#125; if (cnt &amp; 1) isValid = false; //æœ€ä¸‹é¢çš„é‚£ä¸€æ®µåˆ¤æ–­ä¸€ä¸‹è¿ç»­çš„0çš„ä¸ªæ•° st[i] = isValid; //çŠ¶æ€iæ˜¯å¦æœ‰å¥‡æ•°ä¸ªè¿ç»­çš„0çš„æƒ…å†µ,è¾“å…¥åˆ°æ•°ç»„stä¸­ &#125; //ç¬¬äºŒéƒ¨åˆ†ï¼šé¢„å¤„ç†2 // ç»è¿‡ä¸Šé¢æ¯ç§çŠ¶æ€ è¿ç»­0çš„åˆ¤æ–­ï¼Œå·²ç»ç­›æ‰ä¸€äº›çŠ¶æ€ã€‚ //ä¸‹é¢æ¥çœ‹è¿›ä¸€æ­¥çš„åˆ¤æ–­ï¼šçœ‹ç¬¬i-2åˆ—ä¼¸å‡ºæ¥çš„å’Œç¬¬i-1åˆ—ä¼¸å‡ºå»çš„æ˜¯å¦å†²çª for (int j = 0; j &lt; (1 &lt;&lt; n); j ++) &#123; //å¯¹äºç¬¬iåˆ—çš„æ‰€æœ‰çŠ¶æ€ state[j].clear(); //æ¸…ç©ºä¸Šæ¬¡æ“ä½œé—ç•™çš„çŠ¶æ€ï¼Œé˜²æ­¢å½±å“æœ¬æ¬¡çŠ¶æ€ã€‚ for (int k = 0; k &lt; (1 &lt;&lt; n); k ++) &#123; //å¯¹äºç¬¬i-1åˆ—æ‰€æœ‰çŠ¶æ€ if ((j &amp; k ) == 0 &amp;&amp; st[ j | k]) // ç¬¬i-2åˆ—ä¼¸å‡ºæ¥çš„ å’Œç¬¬i-1åˆ—ä¼¸å‡ºæ¥çš„ä¸å†²çª(ä¸åœ¨åŒä¸€è¡Œ) //è§£é‡Šä¸€ä¸‹st[j | k] //å·²ç»çŸ¥é“st[]æ•°ç»„è¡¨ç¤ºçš„æ˜¯è¿™ä¸€åˆ—æ²¡æœ‰è¿ç»­å¥‡æ•°ä¸ª0çš„æƒ…å†µï¼Œ //æˆ‘ä»¬è¦è€ƒè™‘çš„æ˜¯ç¬¬i-1åˆ—ï¼ˆç¬¬i-1åˆ—æ˜¯è¿™é‡Œçš„ä¸»ä½“ï¼‰ä¸­ä»ç¬¬i-2åˆ—æ¨ªæ’è¿‡æ¥çš„ï¼Œ //è¿˜è¦è€ƒè™‘è‡ªå·±è¿™ä¸€åˆ—ï¼ˆi-1åˆ—ï¼‰æ¨ªæ’åˆ°ç¬¬iåˆ—çš„ //æ¯”å¦‚ ç¬¬i-2åˆ—æ’è¿‡æ¥çš„æ˜¯k=10101ï¼Œç¬¬i-1åˆ—æ’å‡ºå»åˆ°ç¬¬iåˆ—çš„æ˜¯ j =01000ï¼Œ //é‚£ä¹ˆåˆåœ¨ç¬¬i-1åˆ—ï¼Œåˆ°åº•æœ‰å¤šå°‘ä¸ª1å‘¢ï¼Ÿ //è‡ªç„¶æƒ³åˆ°çš„å°±æ˜¯è¿™ä¸¤ä¸ªæ“ä½œå…±åŒçš„ç»“æœï¼šä¸¤ä¸ªçŠ¶æ€æˆ–ã€‚ j | k = 01000 | 10101 = 11101 //è¿™ä¸ª j|k å°±æ˜¯å½“å‰ ç¬¬i-1åˆ—çš„åˆ°åº•æœ‰å‡ ä¸ª1ï¼Œå³å“ªå‡ è¡Œæ˜¯æ¨ªç€æ”¾æ ¼å­çš„ state[j].push_back(k); //äºŒç»´æ•°ç»„state[j]è¡¨ç¤ºç¬¬jè¡Œï¼Œ //jè¡¨ç¤º ç¬¬iåˆ—â€œçœŸæ­£â€å¯è¡Œçš„çŠ¶æ€ï¼Œ //å¦‚æœç¬¬i-1åˆ—çš„çŠ¶æ€kå’Œjä¸å†²çªåˆ™å‹å…¥stateæ•°ç»„ä¸­çš„ç¬¬jè¡Œã€‚ //â€œçœŸæ­£â€å¯è¡Œæ˜¯æŒ‡ï¼šæ—¢æ²¡æœ‰å‰åä¸¤åˆ—ä¼¸è¿›ä¼¸å‡ºçš„å†²çªï¼›åˆæ²¡æœ‰è¿ç»­å¥‡æ•°ä¸ª0ã€‚ &#125; &#125; //ç¬¬ä¸‰éƒ¨åˆ†ï¼šdpå¼€å§‹ memset(f, 0, sizeof f); //å…¨éƒ¨åˆå§‹åŒ–ä¸º0ï¼Œå› ä¸ºæ˜¯è¿ç»­è¯»å…¥ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªæ¸…ç©ºæ“ä½œã€‚ //ç±»ä¼¼ä¸Šé¢çš„state[j].clear() f[0][0] = 1 ;// è¿™é‡Œéœ€è¦å›å¿†çŠ¶æ€è¡¨ç¤ºçš„å®šä¹‰ //æŒ‰å®šä¹‰è¿™é‡Œæ˜¯ï¼šå‰ç¬¬-1åˆ—éƒ½æ‘†å¥½ï¼Œä¸”ä»-1åˆ—åˆ°ç¬¬0åˆ—ä¼¸å‡ºæ¥çš„çŠ¶æ€ä¸º0çš„æ–¹æ¡ˆæ•°ã€‚ //é¦–å…ˆï¼Œè¿™é‡Œæ²¡æœ‰-1åˆ—ï¼Œæœ€å°‘ä¹Ÿæ˜¯0åˆ—ã€‚ //å…¶æ¬¡ï¼Œæ²¡æœ‰ä¼¸å‡ºæ¥ï¼Œå³æ²¡æœ‰æ¨ªç€æ‘†çš„ã€‚å³è¿™é‡Œç¬¬0åˆ—åªæœ‰ç«–ç€æ‘†è¿™1ç§çŠ¶æ€ã€‚ for (int i = 1; i &lt;= m; i ++) &#123; //éå†æ¯ä¸€åˆ—:ç¬¬iåˆ—åˆæ³•èŒƒå›´æ˜¯(0~m-1åˆ—) for (int j = 0; j &lt; (1&lt;&lt;n); j ++) &#123; //éå†å½“å‰åˆ—ï¼ˆç¬¬iåˆ—ï¼‰æ‰€æœ‰çŠ¶æ€j for (auto k : state[j]) // éå†ç¬¬i-1åˆ—çš„çŠ¶æ€kï¼Œå¦‚æœâ€œçœŸæ­£â€å¯è¡Œï¼Œå°±è½¬ç§» f[i][j] += f[i-1][k]; // å½“å‰åˆ—çš„æ–¹æ¡ˆæ•°å°±ç­‰äºä¹‹å‰çš„ç¬¬i-1åˆ—æ‰€æœ‰çŠ¶æ€kçš„ç´¯åŠ ã€‚ &#125; &#125; //æœ€åç­”æ¡ˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ //f[m][0]è¡¨ç¤º å‰m-1åˆ—éƒ½å¤„ç†å®Œï¼Œå¹¶ä¸”ç¬¬m-1åˆ—æ²¡æœ‰ä¼¸å‡ºæ¥çš„æ‰€æœ‰æ–¹æ¡ˆæ•°ã€‚ //å³æ•´ä¸ªæ£‹ç›˜å¤„ç†å®Œçš„æ–¹æ¡ˆæ•° cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125;&#125; æœ€çŸ­Hamiltonè·¯å¾„ 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=20,M=1&lt;&lt;N;int f[M][N],w[N][N];//wè¡¨ç¤ºçš„æ˜¯æ— æƒå›¾int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;w[i][j]; memset(f,0x3f,sizeof(f));//å› ä¸ºè¦æ±‚æœ€å°å€¼ï¼Œæ‰€ä»¥åˆå§‹åŒ–ä¸ºæ— ç©·å¤§ f[1][0]=0;//å› ä¸ºé›¶æ˜¯èµ·ç‚¹,æ‰€ä»¥f[1][0]=0; for(int i=0;i&lt;1&lt;&lt;n;i++)//iè¡¨ç¤ºæ‰€æœ‰çš„æƒ…å†µ for(int j=0;j&lt;n;j++)//jè¡¨ç¤ºèµ°åˆ°å“ªä¸€ä¸ªç‚¹ if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;n;k++)//kè¡¨ç¤ºèµ°åˆ°jè¿™ä¸ªç‚¹ä¹‹å‰,ä»¥kä¸ºç»ˆç‚¹çš„æœ€çŸ­è·ç¦» if(i&gt;&gt;k&amp;1) f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//æ›´æ–°æœ€çŸ­è·ç¦» cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//è¡¨ç¤ºæ‰€æœ‰ç‚¹éƒ½èµ°è¿‡äº†,ä¸”ç»ˆç‚¹æ˜¯n-1çš„æœ€çŸ­è·ç¦» //ä½è¿ç®—çš„ä¼˜å…ˆçº§ä½äº&#x27;+&#x27;-&#x27;æ‰€ä»¥æœ‰å¿…è¦çš„æƒ…å†µä¸‹è¦æ‰“æ‹¬å· return 0;&#125; è®°å¿†åŒ–æœç´¢æ»‘é›ª 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=310;int n,m;int h[N][N];int f[N][N];int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;int dp(int x,int y)//æ±‚f[x][y]&#123; if(f[x][y]!=-1) return f[x][y]; f[x][y]=1;//æ³¨æ„è¿™ä¸ªåˆå§‹åŒ– for(int i=0;i&lt;4;i++) &#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[x][y]&gt;h[a][b]) &#123; f[x][y]=max(f[x][y],dp(a,b)+1); &#125; &#125; return f[x][y];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;h[i][j]; &#125; &#125; memset(f,-1,sizeof(f));//åšä¸‹æ ‡è®° int res=0; for(int i=1;i&lt;=n;i++)//éå†æœç´¢æœ€å¤§å€¼ &#123; for(int j=1;j&lt;=m;j++) &#123; res=max(res,dp(i,j)); &#125; &#125; cout&lt;&lt;res; return 0;&#125; è´ªå¿ƒåŒºé—´é—®é¢˜åŒºé—´è´ªå¿ƒè®¨è®ºæŒ‰å·¦ç«¯ç‚¹ã€å³ç«¯ç‚¹æ’åºï¼Œç„¶åä¾æ¬¡æšä¸¾æ¯ä¸ªåŒºé—´ åŒºé—´é€‰ç‚¹å°†æ¯ä¸ªåŒºé—´æŒ‰ç…§å³ç«¯ç‚¹ä»å°åˆ°å¤§è¿›è¡Œæ’åº ä»å‰å¾€åæšä¸¾åŒºé—´ï¼Œendå€¼åˆå§‹åŒ–ä¸ºæ— ç©·å° å¦‚æœæœ¬æ¬¡åŒºé—´ä¸èƒ½è¦†ç›–æ‰ä¸Šæ¬¡åŒºé—´çš„å³ç«¯ç‚¹ï¼Œ ed &lt; range[i].l è¯´æ˜éœ€è¦é€‰æ‹©ä¸€ä¸ªæ–°çš„ç‚¹ï¼Œ res ++ ; ed = range[i].r; 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const//æŒ‰ç…§å³ç«¯ç‚¹æ’åº &#123; return r&lt;W.r; &#125;&#125;range[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;range[i].l,&amp;range[i].r); sort(range,range+n); int res=0,ed=-2e9;//edæ˜¯ä¸Šä¸€ä¸ªç‚¹çš„ä¸‹æ ‡ for(int i=0;i&lt;n;i++) &#123; if(range[i].l&gt;ed) &#123; res++; ed=range[i].r; &#125; &#125; printf(&quot;%d&quot;,res); return 0;&#125; æœ€å¤§ä¸ç›¸äº¤åŒºé—´ä¸ªæ•°å’Œä¸Šä¸€é¢˜ä»£ç æ˜¯ä¸€æ ·çš„ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const//æŒ‰ç…§å³ç«¯ç‚¹æ’åº &#123; return r&lt;W.r; &#125;&#125;range[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;range[i].l,&amp;range[i].r); sort(range,range+n); int res=0,ed=-2e9;//edæ˜¯ä¸Šä¸€ä¸ªç‚¹çš„ä¸‹æ ‡ for(int i=0;i&lt;n;i++) &#123; if(range[i].l&gt;ed) &#123; res++; ed=range[i].r; &#125; &#125; printf(&quot;%d&quot;,res); return 0;&#125; åŒºé—´åˆ†ç»„ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const &#123; return l&lt;W.l; &#125;&#125;ranges[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;ranges[i].l,&amp;ranges[i].r); &#125; sort(ranges,ranges+n); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;heap;//å°æ ¹å † for(int i=0;i&lt;n;i++) &#123; auto r=ranges[i]; if(heap.empty()||heap.top()&gt;=r.l) heap.push(r.r);//å¦‚æœç©ºæˆ–è€…æ²¡æœ‰ä¸€ä¸ªåŒºé—´å¯ä»¥å®¹çº³ else&#123; heap.pop(); heap.push(r.r); &#125; &#125; printf(&quot;%d&quot;,heap.size()); return 0;&#125; åŒºé—´è¦†ç›– 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const &#123; return l&lt;W.l; &#125;&#125;ranges[N];int main()&#123; int st,ed; scanf(&quot;%d%d&quot;,&amp;st,&amp;ed); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;ranges[i].l,&amp;ranges[i].r); &#125; sort(ranges,ranges+n); int res=0; bool suc=false; for(int i=0;i&lt;n;i++) &#123; int j=i,r=-2e9; while(j&lt;n&amp;&amp;ranges[j].l&lt;=st) &#123; r=max(r,ranges[j].r); j++; &#125; if(r&lt;st) &#123; res=-1; break; &#125; res++; if(r&gt;=ed) &#123; suc=true; break; &#125; st=r; i=j-1; &#125; if(suc) &#123; printf(&quot;%d&quot;,res); &#125;else printf(&quot;-1&quot;); return 0;&#125; Huffmanæ ‘åˆå¹¶æœå­1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;heap; while(n--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); heap.push(x); &#125; int res=0; while(heap.size()&gt;1) &#123; int a=heap.top();heap.pop(); int b=heap.top();heap.pop(); res+=(a+b); heap.push(a+b); &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; æ’åºä¸ç­‰å¼æ’é˜Ÿæ‰“æ°´ï¼ŒæŠ¤èˆªé—®é¢˜ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010;int n;int t[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;t[i]); sort(t,t+n); reverse(t,t+n); LL res=0; for(int i=0;i&lt;n;i++) res+=t[i]*i; printf(&quot;%lld\\n&quot;,res); return 0;&#125; ç»å¯¹å€¼ä¸ç­‰å¼è´§ä»“é€‰å€12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;int q[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); sort(q,q+n); int res=0; for(int i=0;i&lt;n;i++) res+=abs(q[i]-q[n/2]); printf(&quot;%d\\n&quot;,res); return 0;&#125; æ¨å…¬å¼è€æ‚æŠ€çš„ç‰›123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt;PII;const int N=50010;int n;PII cow[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; int s,w; scanf(&quot;%d%d&quot;,&amp;w,&amp;s); cow[i]=&#123;w+s,w&#125;; &#125; sort(cow,cow+n); int res=-2e9,sum=0; for(int i=0;i&lt;n;i++) &#123; int s=cow[i].first-cow[i].second,w=cow[i].second; res=max(res,sum-s); sum+=w; &#125; printf(&quot;%d&quot;,res); return 0;&#125; ç®—æ³•å¤ä¹ attentionï¼š å½’å¹¶æ’åºçš„æ‰«å°¾å·¥ä½œ å›æº¯æ³• é€’å½’&amp;&amp;å­é›†æ ‘æ¡†æ¶123456789101112131415161718void backtrack(int t)&#123; if(t&gt;n) output(); else&#123; compute()//åˆ¤æ–­æ‰€éœ€å˜é‡çš„è®¡ç®— if(constraint(t))//çº¦æŸå‡½æ•° &#123; changestate(); backtrack(t+1); stateback(); &#125; if(bound(t)) &#123; backtrack(t+1); &#125; compute_back()//åˆ¤æ–­æ‰€éœ€å˜é‡çš„è®¡ç®— &#125;&#125; è¿­ä»£æ¡†æ¶12345678910111213141516171819void backtrack(void)&#123; int t=1; while(t&gt;0) &#123; if(f(n,t)&lt;g(n,t)) &#123; for(int i=f(n,t);i&lt;=g(n,t);i++) &#123; if(constraint(t)&amp;&amp;bound(t)) &#123; if(solution(t)) output(); else t++; &#125; &#125; &#125; else t--; &#125;&#125; æ’åˆ—æ ‘æ¡†æ¶12345678910111213141516void backtrack(int t)&#123; if(t&gt;n) output(); else for(int i=t;i&lt;=n;i++) &#123; if(constraint(t)&amp;&amp;bound(t)) &#123; swap(x[i],x[t]); changestate(); backtrack(t+1); changestate(); swap(x[i],x[t]); &#125; &#125;&#125; è£…è½½é—®é¢˜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int n;int cw=0,cbest=0;int r;int c1,c2;int x[100];int bestx[100];int w[100];void backtrack(int t)&#123; if(t&gt;n) &#123; if(cw&gt;cbest) &#123; for(int i=1;i&lt;=n;i++) bestx[i]=x[i]; cbest=cw; &#125; return; &#125; r-=w[t]; if(cw+w[t]&lt;=c1) &#123; x[t]=1; cw+=w[t]; backtrack(t+1); x[t]=0; cw-=w[t]; &#125; if(cw+r&gt;cbest) &#123; x[t]=0; backtrack(t+1); &#125; r+=w[t];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c1; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]; r+=w[i]; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; return 0;&#125; input 124 10090 10 80 10 python 1234567891011121314151617181920212223242526272829303132333435n = 0c = 0w = [0]*100x = [0]*100bestx = [0]*100cbest = 0cw = 0r = 0def backtrack(t): global cw,cbest,x,bestx,r if t&gt;n: if cw&gt;cbest: bestx = x.copy() cbest = cw return r -= w[t] if cw+w[t]&lt;= c: x[t] = 1 cw+=w[t] backtrack(t+1) x[t] = 0 cw-=w[t] if cw+r&gt;cbest: x[t] = 0 backtrack(t+1) r += w[t]def main(): global n,c,w,r n,c = map(int,input().split()) w[1:n+1] = list(map(int,input().split())) r = sum(w[1:n+1]) backtrack(1) print(cbest) print(bestx[1:n+1])main() æ‰¹å¤„ç†ä½œä¸šè°ƒåº¦12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;const int N=1010;int M[N][N];int x[N];int bestx[N];int f1,f2[N];int bestf=1000000,n,f;void backtrack(int t)&#123; if(t&gt;n) &#123; if(f&lt;bestf) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; bestf=f; &#125; return; &#125; for(int i=t;i&lt;=n;i++) &#123; f1+=M[x[i]][1];//åœ¨swapå‰ï¼Œæå‰ä½¿ç”¨j f2[t]=((f2[t-1]&gt;f1)?f2[t-1]:f1)+M[x[i]][2]; f+=f2[t]; if(f&lt;bestf) &#123; swap(x[i],x[t]); backtrack(t+1); swap(x[i],x[t]); &#125; f1-=M[x[i]][1]; f-=f2[t]; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;M[i][1]&gt;&gt;M[i][2];//ç¬¬iä¸ªä½œä¸šåœ¨æŸå°æœºå™¨ä¸Š &#125; for(int i=1;i&lt;=n;i++) x[i]=i; backtrack(1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;bestx[i]&gt;&gt;&quot; &quot;; cout&lt;&lt;endl; cout&lt;&lt;bestf; return 0;&#125; inputï¼š 123432 13 12 3 å…«çš‡åé—®é¢˜1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int N=1010;int x[N];int sum,n;bool place(int t)&#123; for(int j=1;j&lt;t;j++) &#123; if(abs(j-t)==abs(x[j]-x[t])) return false; &#125; return true;&#125;void backtrack(int t)&#123; if(t&gt;n) &#123; sum++; return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); if(place(t)) backtrack(t+1); swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; x[i]=i; &#125; backtrack(1); cout&lt;&lt;sum; return 0;&#125; input 128output 92 0-1èƒŒåŒ…é—®é¢˜ç®€åŒ–ç‰ˆæœ¬12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int N=1010;int x[N],bestx[N];int bestv,cv;int cw,r;int w[N],v[N];int c,n;void backtrack(int t)&#123; if(t&gt;n) &#123; if(cv&gt;bestv) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; bestv=cv; &#125; return; &#125; r-=v[t]; if(cw+w[t]&lt;=c) &#123; x[t]=1; cv+=v[t]; cw+=w[t]; backtrack(t+1); x[t]=0; cv-=v[t]; cw-=w[t]; &#125; if(cv+r&gt;bestv) &#123; x[t]=0; backtrack(t+1); &#125; r+=v[t];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]; r+=v[i]; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;bestv; return 0;&#125; æœ€å¤§å›¢é—®é¢˜12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;const int N=1010;int G[N][N];int x[N],bestx[N];int r,cbest,cv;int n,m;bool choose(int t)&#123; for(int i=1;i&lt;t;i++) &#123; if(x[i]==1&amp;&amp;G[i][t]==0) return false; &#125; return true;&#125;void backtrack(int t)&#123; if(t&gt;n) &#123; if(cv&gt;cbest) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; cbest=cv; &#125; return; &#125; r--; if(choose(t)) &#123; cv++; x[t]=1; backtrack(t+1); cv--; x[t]=0; &#125; if(cv+r&gt;cbest) &#123; x[t]=0; backtrack(t+1); &#125; r++;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m;//é¡¶ç‚¹å’Œè¾¹æ•° r=n; int u,v; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;u&gt;&gt;v; G[u][v]=1; G[v][u]=1; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;cbest; return 0;&#125; input 123456785 71 21 41 52 52 33 54 5 TSPé—®é¢˜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N=1010;int G[N][N];int x[N],bestx[N];int cbest=1000000,cw;int n;void backtrack(int t)&#123; if(t==n) &#123; if(G[x[n]][x[n-1]]&gt;0&amp;&amp;G[x[n]][1]&gt;0&amp;&amp;(cw+G[x[n]][x[n-1]]+G[x[n]][1]&lt;cbest)) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[j]=x[j]; &#125; cbest=cw+G[x[n]][x[n-1]]+G[x[n]][1]; &#125; return; &#125; for(int i=t;i&lt;=n;i++) &#123; if(G[x[t-1]][x[i]]&gt;0&amp;&amp;(cw+G[x[t-1]][x[i]]&lt;cbest)) &#123; swap(x[i],x[t]); cw+=G[x[t-1]][x[t]]; backtrack(t+1); cw-=G[x[t-1]][x[t]]; swap(x[i],x[t]); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;G[i][j]; &#125; x[i]=i; &#125; backtrack(2); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt;cbest; return 0;&#125; input 123454-1 30 6 430 -1 5 106 5 -1 204 10 20 -1 éšæœºåŒ–ç®—æ³•æ•°å€¼éšæœºåŒ–ç®—æ³• æŠ•ç‚¹æ³•è®¡ç®—Ï€ï¼šè®¾æœ‰ä¸€åŠå¾„ä¸ºrçš„åœ†åŠå…¶å¤–åˆ‡å››è¾¹å½¢ï¼Œå‘è¯¥æ­£æ–¹å½¢éšæœºåœ°æŠ•æ·nä¸ªç‚¹ï¼Œè®¾è½å…¥åœ†å†…çš„ç‚¹æ•°ä¸ºkï¼Œç”±äºæ‰€æŠ•å…¥çš„ç‚¹å†æ­£æ–¹å½¢ä¸Šå‡åŒ€åˆ†å¸ƒï¼Œæ•…è½å…¥åœ†ä¸­çš„ç‚¹çš„æ¦‚ç‡ä¸ºã€‚ã€‚ï¼Œå½“nè¶³å¤Ÿå¤§æ—¶ï¼Œkä¸nçš„æ¯”å°±é€¼è¿‘è¿™ä¸€æ¦‚ç‡ï¼Œæ•…Ï€=ã€‚ã€‚ã€‚ è®¡ç®—å®šç§¯åˆ†ï¼šå‘å•ä½æ­£æ–¹å½¢å†…éšæœºåœ°æŠ•nä¸ªç‚¹ï¼Œå¦‚æœæœ‰mä¸ªç‚¹è½å…¥Gå†…ï¼Œç”±äºæ‰€æŠ•ç‚¹å‡åŒ€åœ°åˆ†å¸ƒåœ¨æ­£æ–¹å½¢ä¸Šï¼Œæ•…å½“nè¶³å¤Ÿï¼Œå¯è¿‘ä¼¼è®¡ç®—Gä¸º è§£çº¿æ€§æ–¹ç¨‹ç»„ï¼Œ","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"}]}],"categories":[],"tags":[{"name":"NL2SQL","slug":"NL2SQL","permalink":"https://leungto.github.io/tags/NL2SQL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"},{"name":"DL","slug":"DL","permalink":"https://leungto.github.io/tags/DL/"}]}