{"meta":{"title":"小凉的博客","subtitle":"","description":"记录一下!","author":"小凉","url":"https://leungto.github.io","root":"/"},"pages":[{"title":"about","date":"2022-06-21T15:09:41.000Z","updated":"2024-02-01T09:38:28.207Z","comments":true,"path":"about/index.html","permalink":"https://leungto.github.io/about/index.html","excerpt":"","text":"研0 HNU -&gt; FDU DB4AI QQ:2744386030 我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。"},{"title":"categories","date":"2022-06-18T15:09:15.000Z","updated":"2025-05-06T11:30:25.425Z","comments":true,"path":"categories/index.html","permalink":"https://leungto.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-18T15:09:33.000Z","updated":"2022-06-21T03:39:13.178Z","comments":true,"path":"tags/index.html","permalink":"https://leungto.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NN zero to hero (P2): makemore-bigram","slug":"NN-zero-to-hero-P2-makemore","date":"2025-04-29T01:43:26.000Z","updated":"2025-05-07T02:35:43.853Z","comments":true,"path":"2025/04/29/NN-zero-to-hero-P2-makemore/","link":"","permalink":"https://leungto.github.io/2025/04/29/NN-zero-to-hero-P2-makemore/","excerpt":"","text":"makemoremakemore是个二元语言模型，也就是上下文长度只有1，根据前一个字符预测后一个字符是什么，已有数据集names.txt记录了一些人名，现在希望利用模型得到一些人的名称 基于统计的方法基于统计的方法对数据集中连续的字符对进行统计，得到一张表，通过这张表，可知某个字符i后，字符j的出现次数，基于这张表，可计算出字符i后，字符j的出现概率，然后通过概率抽样的方法得到下一个字符 对于数据集中的每个句子，在前面和后面分别加上.符号，所以第一个字符是抽样.字符后字符出现概率得到的，如果抽样抽到了.，则说明句子结束 1234567891011121314151617181920212223242526import torchimport matplotlib.pyplot as pltN = torch.zeros((27,27),dtype=torch.int32)words = open(&quot;names.txt&quot;, &quot;r&quot;).read().splitlines()chars = sorted(list(set(&quot;&quot;.join(words))))stoi = &#123;s:i+1 for i,s in enumerate(chars)&#125;stoi[&#x27;.&#x27;] = 0itos = &#123;i:s for s,i in stoi.items()&#125;# 统计字母对的出现次数for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1,ch2 in zip(chs, chs[1:]): N[stoi[ch1],stoi[ch2]] += 1# 绘图plt.figure(figsize=(16,16))plt.imshow(N, cmap=&#x27;Blues&#x27;)for i in range(27): for j in range(27): chstr = itos[i] + itos[j] plt.text(j, i, chstr, ha=&quot;center&quot;, va=&quot;bottom&quot;, color=&#x27;gray&#x27;) plt.text(j, i, N[i, j].item(), ha=&quot;center&quot;, va=&quot;top&quot;, color=&#x27;gray&#x27;)plt.axis(&#x27;off&#x27;)plt.savefig(&#x27;bigram.png&#x27;) 上面的table显示了字符对的出现频率，其中..出现了0次，因为数据集中没有空的句子 1234567891011121314P = (N+1).float()P /= P.sum(1, keepdim=True) # 归一化for i in range(5): out = [] ix = 0 while True: p = P[ix] ix = torch.multinomial(p, num_samples=1, replacement=True).item() #根据概率采样 out.append(itos[ix]) if ix == 0: break print(&#x27;&#x27;.join(out)) 利用构建好的概率模型进行推理，P对原先的N的概率模型进行了平滑处理，因为一些字符对在N中完全没有出现过，这样使这样的字符对也能被取到，此外在一些数学计算上也避免出现异常，下面是生成的一些名字，还怪正常的哈哈 采用损失函数统计模型的好坏，也就是对于数据集中的每个句子，我们希望概率模型的预测结果和真实结果一致，用损失展示模型的好坏 123456789101112131415161718192021# GOAL: maximize likelihood of the data w.r.t. model parameters (statistical modeling)# equivalent to maximizing the log likelihood (because log is monotonic)# equivalent to minimizing the negative log likelihood# equivalent to minimizing the average negative log likelihood# log(a*b*c) = log(a) + log(b) + log(c)log_likelihood = 0.0n = 0for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1,ch2 in zip(chs, chs[1:]): p = P[stoi[ch1], stoi[ch2]] log_likelihood += torch.log(p) n += 1print(f&#x27;&#123;log_likelihood=&#125;&#x27;)nll = -log_likelihoodprint(f&#x27;&#123;nll=&#125;&#x27;)print(f&#x27;&#123;nll/n&#125;&#x27;) 如果模型完全预测正确，也就是对应项p=1，此时log值为0，最终的损失为0，否则p越小，对应的log越负，负log结果得到的损失越大 123log_likelihood=tensor(-559951.5625)nll=tensor(559951.5625)2.4543561935424805 采用神经网络1234567891011121314151617181920212223242526272829303132333435363738394041# create the training set of bigrams (x,y)xs, ys = [], []for w in words[:1]: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1, ch2 in zip(chs, chs[1:]): ix1 = stoi[ch1] ix2 = stoi[ch2] print(ch1, ch2) xs.append(ix1) ys.append(ix2) xs = torch.tensor(xs)ys = torch.tensor(ys)W = torch.randn((27, 27)) # 27个神经元（一排）xenc = F.one_hot(xs, num_classes=27).float()logist = xenc @ Wcounts = torch.exp(logist)probs = counts / counts.sum(1, keepdim=True)print(probs.shape)nlls = torch.zeros(5)for i in range(5): # i-th bigram: x = xs[i].item() # input character index y = ys[i].item() # label character index print(&#x27;--------&#x27;) print(f&#x27;bigram example &#123;i+1&#125;: &#123;itos[x]&#125;&#123;itos[y]&#125; (indexes &#123;x&#125;,&#123;y&#125;)&#x27;) print(&#x27;input to the neural net:&#x27;, x) print(&#x27;output probabilities from the neural net:&#x27;, probs[i]) print(&#x27;label (actual next character):&#x27;, y) p = probs[i, y] print(&#x27;probability assigned by the net to the the correct character:&#x27;, p.item()) logp = torch.log(p) print(&#x27;log likelihood:&#x27;, logp.item()) nll = -logp print(&#x27;negative log likelihood:&#x27;, nll.item()) nlls[i] = nllprint(&#x27;=========&#x27;)print(&#x27;average negative log likelihood, i.e. loss =&#x27;, nlls.mean().item()) W是已有的神经网络，这里是个参数随机初始化的一排27个神经元组成的神经网络，输出27个维度，后接softmax操作（先经过exp，然后经过归一化），得到类似于统计方法的概率分布。可以看做经过神经网络得到的是出现次数log后的结果，exp之后得到了计数，归一化得到了概率 12345678910111213141516171819202122232425262728293031323334# --------- !!! OPTIMIZATION !!! yay, but this time actually --------------# create the datasetxs, ys = [], []for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1, ch2 in zip(chs, chs[1:]): ix1 = stoi[ch1] ix2 = stoi[ch2] xs.append(ix1) ys.append(ix2)xs = torch.tensor(xs)ys = torch.tensor(ys)num = xs.nelement()print(&#x27;number of examples: &#x27;, num)# initialize the &#x27;network&#x27;W = torch.randn((27, 27), requires_grad=True)# gradient descentfor k in range(100): # forward pass xenc = F.one_hot(xs, num_classes=27).float() # input to the network: one-hot encoding logits = xenc @ W # predict log-counts counts = logits.exp() # counts, equivalent to N probs = counts / counts.sum(1, keepdims=True) # probabilities for next character loss = -probs[torch.arange(num), ys].log().mean() + 0.01*(W**2).mean() print(loss.item()) # backward pass W.grad = None # set to zero the gradient loss.backward() # update W.data += -50 * W.grad 训练神经网络，完成了整个步骤，这里的loss除了负log的损失之外，为了让模型平滑（类似于之前的P=N+1的效果），加入了正则化项0.01*(W**2).mean()，让W的参数不要太大 所有的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import torchimport matplotlib.pyplot as pltimport torch.nn.functional as FN = torch.zeros((27,27),dtype=torch.int32)words = open(&quot;names.txt&quot;, &quot;r&quot;).read().splitlines()chars = sorted(list(set(&quot;&quot;.join(words))))stoi = &#123;s:i+1 for i,s in enumerate(chars)&#125;stoi[&#x27;.&#x27;] = 0itos = &#123;i:s for s,i in stoi.items()&#125;# 统计字母对的出现次数for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1,ch2 in zip(chs, chs[1:]): N[stoi[ch1],stoi[ch2]] += 1# 绘图plt.figure(figsize=(16,16))plt.imshow(N, cmap=&#x27;Blues&#x27;)for i in range(27): for j in range(27): chstr = itos[i] + itos[j] plt.text(j, i, chstr, ha=&quot;center&quot;, va=&quot;bottom&quot;, color=&#x27;gray&#x27;) plt.text(j, i, N[i, j].item(), ha=&quot;center&quot;, va=&quot;top&quot;, color=&#x27;gray&#x27;)plt.axis(&#x27;off&#x27;)# plt.savefig(&#x27;bigram.png&#x27;)P = (N+1).float()P /= P.sum(1, keepdim=True) # 归一化for i in range(5): out = [] ix = 0 while True: p = P[ix] ix = torch.multinomial(p, num_samples=1, replacement=True).item() #根据概率采样 out.append(itos[ix]) if ix == 0: break print(&#x27;&#x27;.join(out))# GOAL: maximize likelihood of the data w.r.t. model parameters (statistical modeling)# equivalent to maximizing the log likelihood (because log is monotonic)# equivalent to minimizing the negative log likelihood# equivalent to minimizing the average negative log likelihood# log(a*b*c) = log(a) + log(b) + log(c)log_likelihood = 0.0n = 0for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1,ch2 in zip(chs, chs[1:]): p = P[stoi[ch1], stoi[ch2]] log_likelihood += torch.log(p) n += 1print(f&#x27;&#123;log_likelihood=&#125;&#x27;)nll = -log_likelihoodprint(f&#x27;&#123;nll=&#125;&#x27;)print(f&#x27;&#123;nll/n&#125;&#x27;)print(&#x27;========================================&#x27;)# create the training set of bigrams (x,y)xs, ys = [], []for w in words[:1]: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1, ch2 in zip(chs, chs[1:]): ix1 = stoi[ch1] ix2 = stoi[ch2] print(ch1, ch2) xs.append(ix1) ys.append(ix2) xs = torch.tensor(xs)ys = torch.tensor(ys)W = torch.randn((27, 27))xenc = F.one_hot(xs, num_classes=27).float()logist = xenc @ Wcounts = torch.exp(logist)probs = counts / counts.sum(1, keepdim=True)print(probs.shape)nlls = torch.zeros(5)for i in range(5): # i-th bigram: x = xs[i].item() # input character index y = ys[i].item() # label character index print(&#x27;--------&#x27;) print(f&#x27;bigram example &#123;i+1&#125;: &#123;itos[x]&#125;&#123;itos[y]&#125; (indexes &#123;x&#125;,&#123;y&#125;)&#x27;) print(&#x27;input to the neural net:&#x27;, x) print(&#x27;output probabilities from the neural net:&#x27;, probs[i]) print(&#x27;label (actual next character):&#x27;, y) p = probs[i, y] print(&#x27;probability assigned by the net to the the correct character:&#x27;, p.item()) logp = torch.log(p) print(&#x27;log likelihood:&#x27;, logp.item()) nll = -logp print(&#x27;negative log likelihood:&#x27;, nll.item()) nlls[i] = nllprint(&#x27;=========&#x27;)print(&#x27;average negative log likelihood, i.e. loss =&#x27;, nlls.mean().item())print(&#x27;==================&#x27;)# --------- !!! OPTIMIZATION !!! yay, but this time actually --------------# create the datasetxs, ys = [], []for w in words: chs = [&#x27;.&#x27;] + list(w) + [&#x27;.&#x27;] for ch1, ch2 in zip(chs, chs[1:]): ix1 = stoi[ch1] ix2 = stoi[ch2] xs.append(ix1) ys.append(ix2)xs = torch.tensor(xs)ys = torch.tensor(ys)num = xs.nelement()print(&#x27;number of examples: &#x27;, num)# initialize the &#x27;network&#x27;W = torch.randn((27, 27), requires_grad=True)# gradient descentfor k in range(1000): # forward pass xenc = F.one_hot(xs, num_classes=27).float() # input to the network: one-hot encoding logits = xenc @ W # predict log-counts counts = logits.exp() # counts, equivalent to N probs = counts / counts.sum(1, keepdims=True) # probabilities for next character loss = -probs[torch.arange(num), ys].log().mean() + 0.01*(W**2).mean() print(loss.item()) # backward pass W.grad = None # set to zero the gradient loss.backward() # update W.data += -50 * W.gradfor i in range(5): out = [] ix = 0 while True: # ---------- # BEFORE: #p = P[ix] # ---------- # NOW: xenc = F.one_hot(torch.tensor([ix]), num_classes=27).float() logits = xenc @ W # predict log-counts counts = logits.exp() # counts, equivalent to N p = counts / counts.sum(1, keepdims=True) # probabilities for next character # ---------- ix = torch.multinomial(p, num_samples=1, replacement=True).item() out.append(itos[ix]) if ix == 0: break print(&#x27;&#x27;.join(out))","categories":[],"tags":[]},{"title":"NN zero to hero (P1): micrograd","slug":"NN-zero-to-hero-P1-micrograd","date":"2025-04-27T11:53:44.000Z","updated":"2025-04-29T01:33:06.141Z","comments":true,"path":"2025/04/27/NN-zero-to-hero-P1-micrograd/","link":"","permalink":"https://leungto.github.io/2025/04/27/NN-zero-to-hero-P1-micrograd/","excerpt":"","text":"karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero 1.导数 slope通过下面的方法可求得导数，即(f(x+h)-f(x))/h h趋于0 1234567891011121314h = 0.0001# inputsa = 2.0b = -3.0c = 10.0d1 = a*b + cc += hd2 = a*b + cprint(&#x27;d1&#x27;, d1)print(&#x27;d2&#x27;, d2)print(&#x27;slope&#x27;, (d2 - d1)/h) 2.前向传播如果只考虑前向传播，代码的逻辑只是做类的封装，把原有的数据封装到新的Value类中 12345678910111213141516171819202122232425import mathclass Value: def __init__(self, data): self.data = data def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): return Value(self.data + other.data) def __mul__(self, other): return Value(self.data * other.data) def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1) return t def main(): a = Value(2.0) b = Value(-3.0) c = Value(10.0) d = a*b + c; f = Value(-2.0) L = d * f print(L)main() 为了便于之后的反向传播，我们还需要记录某个节点由哪些节点生成、以及是如何生成的，加上_prev属性，对应_children元组，表示由哪些节点操作而成，操作用op记录 1234567891011121314151617181920212223242526class Value: def __init__(self, data, _children=(), _op=&#x27;&#x27;): self.data = data self._prev = set(_children) #为了性能用的set self._op = _op def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): return Value(self.data + other.data, (self, other), &#x27;+&#x27;) def __mul__(self, other): return Value(self.data * other.data, (self, other), &#x27;*&#x27;) def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1 ,(self, ), &#x27;tanh&#x27;) return t def main(): a = Value(2.0) b = Value(-3.0) c = Value(10.0) d = a*b + c; f = Value(-2.0) L = d * f draw_dot(L) print(L)main() 用graphviz可视化整个前向传播的过程，为了方便查看加上label变量，并对中间的变量进行了定义e: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import mathfrom sklearn.tree import export_graphvizfrom graphviz import Digraph# 下面两个函数直接用，是用来可视化的def trace(root): # builds a set of all nodes and edges in a graph nodes, edges = set(), set() def build(v): if v not in nodes: nodes.add(v) for child in v._prev: edges.add((child, v)) build(child) build(root) return nodes, edgesdef draw_dot(root): dot = Digraph(format=&#x27;svg&#x27;, graph_attr=&#123;&#x27;rankdir&#x27;: &#x27;LR&#x27;&#125;) # LR = left to right nodes, edges = trace(root) for n in nodes: uid = str(id(n)) # for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it dot.node(name = uid, label = &quot;&#123; %s | %.4f &#125;&quot; % (n.label, n.data), shape=&#x27;record&#x27;) if n._op: # if this value is a result of some operation, create an op node for it dot.node(name = uid + n._op, label = n._op) # and connect this node to it dot.edge(uid + n._op, uid) for n1, n2 in edges: # connect n1 to the op node of n2 dot.edge(str(id(n1)), str(id(n2)) + n2._op) dot.save(&#x27;output.dot&#x27;) return dotclass Value: def __init__(self, data, _children=(), _op=&#x27;&#x27;, label=&#x27;&#x27;): self.data = data self._prev = set(_children) #为了性能用的set self._op = _op self.label = label def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): return Value(self.data + other.data, (self, other), &#x27;+&#x27;) def __mul__(self, other): return Value(self.data * other.data, (self, other), &#x27;*&#x27;) def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1 ,(self, ), &#x27;tanh&#x27;) return t def main(): a = Value(2.0, label=&#x27;a&#x27;) b = Value(-3.0, label=&#x27;b&#x27;) c = Value(10.0, label=&#x27;c&#x27;) e = a*b; e.label = &#x27;e&#x27; d = e + c; d.label = &#x27;d&#x27; f = Value(-2.0, label=&#x27;f&#x27;) L = d * f; L.label = &#x27;L&#x27; draw_dot(L) print(L)main() 这样我们就得到了一张不含梯度的计算图 3.加入梯度下面加入梯度（dL/dx,x当前的变量），根据链式法则，我们实际上不需要按照1中的求导方法 比如L的梯度就是1，因为dL/dL = 1,然后计算f和d，因为L=f*d，所以dL/df = d，所以f.grad=4,d.grad=-2,然后求dL/dc，根据链式法则，dL/dc = (dL/dd) * (dd/dc) = -2*(dd/dc)，因为是加法，所以dd/dc = 1，所以dL/dc = -2，同理dL/de=-2(由此可以看出，如果操作是+，那么操作数的梯度等于该操作结果的梯度,这里可能有点小问题，暂时这样看)，继续 dL/da = dL/de * de/da = -2*(de/da)，因为e = a*b, 所以de/da = b =-3，所以dL/da = 6，同理dL/db = -4（可以看出如果操作是*，操作数的梯度等于该操作结果的梯度乘以另外一个操作数） variable grad a 6 b -4 c -2 e -2 f 4 d -2 L 1 按照类似上面的做法，加入grad，每个操作在做前向传播的时候给out记录下反向传播时如何给操作节点分配梯度，在做完前向传播后，对节点进行拓扑排序，然后设置最终结果的grad为1，反转拓扑排序得到的列表，调用节点自己的_backward函数进行梯度的反向传播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import mathfrom sklearn.tree import export_graphvizfrom graphviz import Digraphdef trace(root): # builds a set of all nodes and edges in a graph nodes, edges = set(), set() def build(v): if v not in nodes: nodes.add(v) for child in v._prev: edges.add((child, v)) build(child) build(root) return nodes, edgesdef draw_dot(root): dot = Digraph(format=&#x27;svg&#x27;, graph_attr=&#123;&#x27;rankdir&#x27;: &#x27;LR&#x27;&#125;) # LR = left to right nodes, edges = trace(root) for n in nodes: uid = str(id(n)) # for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it dot.node(name = uid, label = &quot;&#123; %s | %.4f | grad %.4f &#125;&quot; % (n.label, n.data, n.grad), shape=&#x27;record&#x27;) if n._op: # if this value is a result of some operation, create an op node for it dot.node(name = uid + n._op, label = n._op) # and connect this node to it dot.edge(uid + n._op, uid) for n1, n2 in edges: # connect n1 to the op node of n2 dot.edge(str(id(n1)), str(id(n2)) + n2._op) dot.save(&#x27;output.dot&#x27;) return dotclass Value: def __init__(self, data, _children=(), _op=&#x27;&#x27;, label=&#x27;&#x27;): self.data = data self._prev = set(_children) #为了性能用的set self._op = _op self.label = label self.grad = 0.0 self._backward = lambda: None def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): out = Value(self.data + other.data, (self, other), &#x27;+&#x27;) def _backward(): self.grad = 1.0 * out.grad other.grad = 1.0 * out.grad out._backward = _backward return out def __mul__(self, other): out = Value(self.data * other.data, (self, other), &#x27;*&#x27;) def _backward(): self.grad = out.grad * other.data other.grad = out.grad * self.data out._backward = _backward return out def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1) out = Value(t,(self, ), &#x27;tanh&#x27;) def _backward(): self.grad = (1 - t**2) * out.grad out._backward = _backward return out def backward(self): # 首先拓扑排序得到操作数-&gt;最终结果节点的列表 topo = [] visited = set() def build_topo(v): if v not in visited: visited.add(v) for child in v._prev: build_topo(child) topo.append(v) build_topo(self) # 设置最终结果的grad为1，然后翻转列表调用_backward进行反向传播 self.grad = 1.0 for node in reversed(topo): node._backward()def main(): a = Value(2.0, label=&#x27;a&#x27;) b = Value(-3.0, label=&#x27;b&#x27;) c = Value(10.0, label=&#x27;c&#x27;) e = a*b; e.label = &#x27;e&#x27; d = e + c; d.label = &#x27;d&#x27; f = Value(-2.0, label=&#x27;f&#x27;) L = d * f; L.label = &#x27;L&#x27; L.backward() draw_dot(L) print(L)main() 这里有个小问题，对于下面的两个实例，上述代码是有误的： 1234a = Value(3.0, label=&#x27;a&#x27;)b = a + a ; b.label = &#x27;b&#x27;b.backward()draw_dot(b) 这里在做反向传播的时候，给a的梯度赋了两次值，第二次的grad=1覆盖了第一次的grad=1，而不是累加 123456789a = Value(-2.0, label=&#x27;a&#x27;)b = Value(3.0, label=&#x27;b&#x27;)d = a * b ; d.label = &#x27;d&#x27;e = a + b ; e.label = &#x27;e&#x27;f = d * e ; f.label = &#x27;f&#x27;f.backward()draw_dot(f) 这种也是被覆盖了，所以梯度的计算应该是累积的，之前的=要改成+=，此外考虑一些其他的基本操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Value: def __init__(self, data, _children=(), _op=&#x27;&#x27;, label=&#x27;&#x27;): self.data = data self.grad = 0.0 self._backward = lambda: None self._prev = set(_children) self._op = _op self.label = label def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): other = other if isinstance(other, Value) else Value(other) out = Value(self.data + other.data, (self, other), &#x27;+&#x27;) def _backward(): self.grad += 1.0 * out.grad other.grad += 1.0 * out.grad out._backward = _backward return out def __mul__(self, other): other = other if isinstance(other, Value) else Value(other) out = Value(self.data * other.data, (self, other), &#x27;*&#x27;) def _backward(): self.grad += other.data * out.grad other.grad += self.data * out.grad out._backward = _backward return out def __pow__(self, other): assert isinstance(other, (int, float)), &quot;only supporting int/float powers for now&quot; out = Value(self.data**other, (self,), f&#x27;**&#123;other&#125;&#x27;) def _backward(): self.grad += other * (self.data ** (other - 1)) * out.grad out._backward = _backward return out def __rmul__(self, other): # other * self return self * other def __truediv__(self, other): # self / other return self * other**-1 def __neg__(self): # -self return self * -1 def __sub__(self, other): # self - other return self + (-other) def __radd__(self, other): # other + self return self + other def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1) out = Value(t, (self, ), &#x27;tanh&#x27;) def _backward(): self.grad += (1 - t**2) * out.grad out._backward = _backward return out def exp(self): x = self.data out = Value(math.exp(x), (self, ), &#x27;exp&#x27;) def _backward(): self.grad += out.data * out.grad # NOTE: in the video I incorrectly used = instead of +=. Fixed here. out._backward = _backward return out def backward(self): topo = [] visited = set() def build_topo(v): if v not in visited: visited.add(v) for child in v._prev: build_topo(child) topo.append(v) build_topo(self) self.grad = 1.0 for node in reversed(topo): node._backward() 4.从神经元到MLP12345678910111213141516171819202122232425262728293031323334353637383940class Neuron: def __init__(self, nin): self.w = [Value(random.uniform(-1,1)) for _ in range(nin)] self.b = Value(random.uniform(-1,1)) def __call__(self, x): act = sum((wi*xi for wi,xi in zip(self.w,x)), self.b) out = act.tanh() return out def parameters(self): return self.w + [self.b] class Layer: # n个神经元组成的一层 def __init__(self, nin, nout): self.neurons = [Neuron(nin) for _ in range(nout)] def __call__(self, x): outs = [n(x) for n in self.neurons] return outs[0] if len(outs) == 1 else outs def parameters(self): return [p for neuron in self.neurons for p in neuron.parameters()] class MLP:# MLP多层感知机, nin是输入的维度，nouts是个列表，记录每层的输出维度 def __init__(self, nin, nouts): sz = [nin] + nouts self.layers = [Layer(sz[i],sz[i+1]) for i in range(len(nouts))] def __call__(self, x): for layer in self.layers: x = layer(x) return x def parameters(self): return [p for layer in self.layers for p in layer.parameters()] 5.训练神经网络12345678910111213141516171819202122232425262728def main(): n = MLP(3, [4, 4, 1]) xs = [ [2.0, 3.0, -1.0], [3.0, -1.0, 0.5], [0.5, 1.0, 1.0], [1.0, 1.0, -1.0], ] ys = [1.0, -1.0, -1.0, 1.0] # desired targets for k in range(20): # forward pass ypred = [n(x) for x in xs] loss = sum((yout - ygt)**2 for ygt, yout in zip(ys, ypred)) # backward pass for p in n.parameters(): p.grad = 0.0 loss.backward() # update for p in n.parameters(): p.data += -0.1 * p.grad print(k, loss.data) print(ypred) 6.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204import mathimport randomfrom sklearn.tree import export_graphvizfrom graphviz import Digraphdef trace(root): # builds a set of all nodes and edges in a graph nodes, edges = set(), set() def build(v): if v not in nodes: nodes.add(v) for child in v._prev: edges.add((child, v)) build(child) build(root) return nodes, edgesdef draw_dot(root): dot = Digraph(format=&#x27;svg&#x27;, graph_attr=&#123;&#x27;rankdir&#x27;: &#x27;LR&#x27;&#125;) # LR = left to right nodes, edges = trace(root) for n in nodes: uid = str(id(n)) # for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it dot.node(name = uid, label = &quot;&#123; %s | %.4f | grad %.4f &#125;&quot; % (n.label, n.data, n.grad), shape=&#x27;record&#x27;) if n._op: # if this value is a result of some operation, create an op node for it dot.node(name = uid + n._op, label = n._op) # and connect this node to it dot.edge(uid + n._op, uid) for n1, n2 in edges: # connect n1 to the op node of n2 dot.edge(str(id(n1)), str(id(n2)) + n2._op) dot.save(&#x27;output.dot&#x27;) return dotclass Value: def __init__(self, data, _children=(), _op=&#x27;&#x27;, label=&#x27;&#x27;): self.data = data self.grad = 0.0 self._backward = lambda: None self._prev = set(_children) self._op = _op self.label = label def __repr__(self): return f&quot;Value(data=&#123;self.data&#125;)&quot; def __add__(self, other): other = other if isinstance(other, Value) else Value(other) out = Value(self.data + other.data, (self, other), &#x27;+&#x27;) def _backward(): self.grad += 1.0 * out.grad other.grad += 1.0 * out.grad out._backward = _backward return out def __mul__(self, other): other = other if isinstance(other, Value) else Value(other) out = Value(self.data * other.data, (self, other), &#x27;*&#x27;) def _backward(): self.grad += other.data * out.grad other.grad += self.data * out.grad out._backward = _backward return out def __pow__(self, other): assert isinstance(other, (int, float)), &quot;only supporting int/float powers for now&quot; out = Value(self.data**other, (self,), f&#x27;**&#123;other&#125;&#x27;) def _backward(): self.grad += other * (self.data ** (other - 1)) * out.grad out._backward = _backward return out def __rmul__(self, other): # other * self return self * other def __truediv__(self, other): # self / other return self * other**-1 def __neg__(self): # -self return self * -1 def __sub__(self, other): # self - other return self + (-other) def __radd__(self, other): # other + self return self + other def tanh(self): x = self.data t = (math.exp(2*x) - 1)/(math.exp(2*x) + 1) out = Value(t, (self, ), &#x27;tanh&#x27;) def _backward(): self.grad += (1 - t**2) * out.grad out._backward = _backward return out def exp(self): x = self.data out = Value(math.exp(x), (self, ), &#x27;exp&#x27;) def _backward(): self.grad += out.data * out.grad # NOTE: in the video I incorrectly used = instead of +=. Fixed here. out._backward = _backward return out def backward(self): topo = [] visited = set() def build_topo(v): if v not in visited: visited.add(v) for child in v._prev: build_topo(child) topo.append(v) build_topo(self) self.grad = 1.0 for node in reversed(topo): node._backward()class Neuron: def __init__(self, nin): self.w = [Value(random.uniform(-1,1)) for _ in range(nin)] self.b = Value(random.uniform(-1,1)) def __call__(self, x): act = sum((wi*xi for wi,xi in zip(self.w,x)), self.b) out = act.tanh() return out def parameters(self): return self.w + [self.b] class Layer: # n个神经元组成的一层 def __init__(self, nin, nout): self.neurons = [Neuron(nin) for _ in range(nout)] def __call__(self, x): outs = [n(x) for n in self.neurons] return outs[0] if len(outs) == 1 else outs def parameters(self): return [p for neuron in self.neurons for p in neuron.parameters()] class MLP:# MLP多层感知机, nin是输入的维度，nouts是个列表，记录每层的输出维度 def __init__(self, nin, nouts): sz = [nin] + nouts self.layers = [Layer(sz[i],sz[i+1]) for i in range(len(nouts))] def __call__(self, x): for layer in self.layers: x = layer(x) return x def parameters(self): return [p for layer in self.layers for p in layer.parameters()]def main(): n = MLP(3, [4, 4, 1]) xs = [ [2.0, 3.0, -1.0], [3.0, -1.0, 0.5], [0.5, 1.0, 1.0], [1.0, 1.0, -1.0], ] ys = [1.0, -1.0, -1.0, 1.0] # desired targets for k in range(20): # forward pass ypred = [n(x) for x in xs] loss = sum((yout - ygt)**2 for ygt, yout in zip(ys, ypred)) # backward pass for p in n.parameters(): p.grad = 0.0 loss.backward() # update for p in n.parameters(): p.data += -0.1 * p.grad print(k, loss.data) print(ypred)main()","categories":[],"tags":[{"name":"LLM","slug":"LLM","permalink":"https://leungto.github.io/tags/LLM/"}]},{"title":"NLP入门","slug":"NLP入门","date":"2024-04-05T03:00:35.000Z","updated":"2025-02-21T07:29:37.080Z","comments":true,"path":"2024/04/05/NLP入门/","link":"","permalink":"https://leungto.github.io/2024/04/05/NLP%E5%85%A5%E9%97%A8/","excerpt":"","text":"总结 Python&amp;Pytorch python基础教程 python自然语言实战 pytorch深度学习实践 Deep Learning 吴恩达深度学习 实践：李沐/B站视频 NLP CS224n 信息 1.机器学习，看《机器学习实战》Peter Harrington著，并复现书中代码。 2.深度学习理论，看斋藤康毅的《深度学习入门——基于python的理论与实现》，并复现代码 3.PyTorch框架，看《Python深度学习基于Pytorch》吴茂贵著，并复现代码。 4.深度学习进阶自然语言处理，看斋藤康毅的《深度学习进阶自然语言处理》，并复现代码。 5.看顶会顶刊论文，复现代码。如：CVPR，NIPS，AAAI，ICCV，ECCV等。 NLP算法学习路线-自己整理_nlp入门学习路线教程地址-CSDN博客","categories":[],"tags":[{"name":"NL2SQL","slug":"NL2SQL","permalink":"https://leungto.github.io/tags/NL2SQL/"}]},{"title":"algorithm plus","slug":"algorithm-plus","date":"2023-08-15T11:56:19.000Z","updated":"2025-02-21T07:29:55.930Z","comments":true,"path":"2023/08/15/algorithm-plus/","link":"","permalink":"https://leungto.github.io/2023/08/15/algorithm-plus/","excerpt":"","text":"动态规划数字三角形模型摘花生 因为只能从上面和左边过来，所以有状态转移方程：dp[i][j]=(dp[i-1][j],dp[i][j-1])+a[i][j] 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=105;int n;int a[N][N],dp[N][N];int main()&#123; cin&gt;&gt;n; int r,c; while(n--) &#123; cin&gt;&gt;r&gt;&gt;c; for(int i=1;i&lt;=r;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=r;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125; cout&lt;&lt;dp[r][c]&lt;&lt;endl; &#125; return 0;&#125; 最低通信费N*N的正方形方格，左上角进右下角出，题目条件总路径长度为2*N+1，即只能向下或者向右走，递推方程为dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j] 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=105;int a[N][N];int dp[N][N];int n;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; memset(dp,0x3f,sizeof dp);//边界处理 //处理dp[1][1] dp[0][1]=0; dp[1][0]=0; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j]; &#125; &#125; cout&lt;&lt;dp[n][n]; return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"}]},{"title":"dive into deep learning","slug":"dive-into-deep-learning","date":"2023-07-22T07:33:18.000Z","updated":"2025-02-21T07:29:17.847Z","comments":true,"path":"2023/07/22/dive-into-deep-learning/","link":"","permalink":"https://leungto.github.io/2023/07/22/dive-into-deep-learning/","excerpt":"","text":"pytorch 【PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】】 https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=f21aab4ae7e1148acd5e06c0dddddfd9 1.环境管理建立不同的python版本环境（anaconda prompt） 1conda create -n pytorch python=3.6 #创建一个名为pytorch的环境 激活/进入特定环境 1conda activate pytorch 环境下的工具包 1pip list 安装pytorch工具包 在pytorch官网按照环境复制命令在特定环境进行下载 安装完之后检查pytorch安装情况 123pythonimport torchtorch.cuda.is_available() 两个工具：pycharm和jupyter pycharm创建项目记得勾选对应的interpreter(如：D:\\Users\\lzh\\anaconda3\\envs\\pytorch) jupyter选择环境：在prompt下命令行开启jupyter： 12conda install nb_condajupyter notebook jupyter shift+enter执行并编辑下一行 2.两个函数 1234dir(torch) #dir(package)dir(torch.cuda)dir(torch.cuda.is_available) #输出是双下划线，双下划线表示不可修改，此时不能进一步打开了，就是函数了help(torch.cuda.is_available) 3.数据的加载两个类： Dataset：提供一种方式去获取数据及其label。提取数据，进行编号，数据对应label 如何获取每一个数据及其label 告诉我们总共有多少的数据 Dataloader：为网络提供不同的数据形式。送进网络之前进行打包和压缩 如果文件夹名称就是label： 1234567891011121314151617181920212223242526from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset): def __init__(self,root_dir,label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(self.root_dir,self.label_dir) self.img_path = os.listdir(self.path) def __getitem__(self, idx): img_name = self.img_path[idx] img_item_path = os.path.join(self.root_dir,self.label_dir,img_name) img = Image.open(img_item_path) label = self.label_dir return img, label def __len__(self): return len(self.img_path)root_dir = &quot;hymenoptera_data/train&quot;ants_label_dir = &quot;ants&quot;bees_label_dir = &quot;bees&quot;ants_dataset = MyData(root_dir, ants_label_dir)bees_dataset = MyData(root_dir, bees_label_dir)train_dataset = ants_dataset + bees_dataset 如果分开了img和label： 123456789101112131415161718192021222324252627282930313233343536from torch.utils.data import Datasetimport osfrom PIL import Imageclass MyData(Dataset): def __init__(self,root_dir,image_dir,label_dir): self.root_dir = root_dir self.image_dir = image_dir self.label_dir = label_dir self.img_path = os.path.join(self.root_dir, self.image_dir) self.label_path = os.path.join(self.root_dir, self.label_dir) self.img_name = os.listdir(self.img_path) self.label_name = os.listdir(self.label_path) def __getitem__(self, idx): img_path = os.path.join(self.img_path,self.img_name[idx]) label_path = os.path.join(self.label_path, self.label_name[idx]) img = Image.open(img_path) f = open(label_path) label = f.readline() f.close() return img,label def __len__(self): return len(self.img_name)root_dir = &quot;new_data/train&quot;ants_image_dir = &quot;ants_image&quot;ants_label_dir = &quot;ants_label&quot;bees_image_dir = &quot;bees_image&quot;bees_label_dir = &quot;bees_label&quot;ants_dataset = MyData(root_dir,ants_image_dir,ants_label_dir)bees_dataset = MyData(root_dir,bees_image_dir,bees_label_dir)train_dataset = ants_dataset + bees_dataset 4.tensorboard的使用1）SummaryWriter的使用文件名不能是tensorboard.py 12345678from torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&quot;logs&quot;) #存储tensorboard日志地方for i in range(100): writer.add_scalar(&quot;y=x&quot;, i, i) # name y xwriter.close() 运行后代码相同文件夹下生成logs文件夹 控制台： 1tensorboad --logdir=logs #logs可替换为其他存储日志文件的文件夹名称 如果改变图片的名称，会重新画一幅图，如果不改变图片的名称，会在上一幅图上画 解决方法：删掉原有log文件 2）add_image的使用add_image将图片在tensorboard中展示： 1234567891011121314from torch.utils.tensorboard import SummaryWriterimport numpy as npfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;) #存储tensorboard日志地方image_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img_PIL = Image.open(image_path)img_array = np.array(img_PIL)print(type(img_array))print(img_array.shape)writer.add_image(&quot;test&quot;,img_array,2,dataformats=&#x27;HWC&#x27;) # 标题 内容(限定格式) 第几幅 格式writer.close() 5.transform的使用1）流程 123456789101112131415from PIL import Imagefrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transforms# 获取图片img_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img = Image.open(img_path)# tensorboardwriter = SummaryWriter(&quot;logs&quot;)# transformtensor_trans = transforms.ToTensor()tensor_img = tensor_trans(img)# add_imagewriter.add_image(&quot;img&quot;,tensor_img)writer.close() 2）常见的Transforms 内置call （ctrl+p 提示参数） 12345678910class Person: def __call__(self, name): print(&quot;__call__ &quot;+name) def hello(self, name): print(&quot;hello &quot;+name)person = Person()person(&quot;zhangsan&quot;)person.hello(&quot;zhangsan&quot;) transforms.Normalize transforms.Resize transforms.compose:组合多个操作 transforms.RandomCrop 1234567891011121314151617181920212223242526272829303132333435363738394041424344from PIL import Imagefrom torchvision import transformsfrom torch.utils.tensorboard import SummaryWriter# 打开图片img_path = &quot;hymenoptera_data/train/ants/0013035.jpg&quot;img = Image.open(img_path)print(img)# 建立tensorboardwriter = SummaryWriter(&quot;logs&quot;)# 1. totensortrans_totensor = transforms.ToTensor()img_tensor = trans_totensor(img)# 添加原始图片writer.add_image(&quot;img&quot;, img_tensor, 0)# 获取normalize后的图片# 2. normalizetrans_nore = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])img_nore = trans_nore(img_tensor)# 添加转换后的图片writer.add_image(&quot;img&quot;, img_nore, 1)# 3. Resizeprint(img.size)trans_resize = transforms.Resize((512,512))img_resize = trans_resize(img)img_resize = trans_totensor(img_resize)writer.add_image(&quot;Resize&quot;, img_resize, 0)print(img_resize)# 4. composetrans_resize_2 = transforms.Resize(512)trans_compose = transforms.Compose([trans_totensor, trans_resize_2])img_resize_2 = trans_compose(img)writer.add_image(&quot;Resize&quot;, img_resize_2, 1)# 5. RandomCroptrans_random = transforms.RandomCrop((500, 500))trans_compose_2 = transforms.Compose([trans_random, trans_totensor])for i in range(10): img_crop = trans_compose_2(img) writer.add_image(&quot;RandomCrop&quot;, img_crop, i)writer.close() 关注输入输出 查阅官方文档 关注方法参数 6.数据集的使用123456789101112131415161718import torchvisionfrom torchvision import transformsfrom torch.utils.tensorboard import SummaryWriter# 数据集的变换dataset_transform = transforms.Compose([ transforms.ToTensor()])# 下载数据集train_set = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=True, transform=dataset_transform, download=True)test_set = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=dataset_transform, download=False)# 在tensorboard上展示writer = SummaryWriter(&quot;p10&quot;)for i in range(10): img, target = test_set[i] writer.add_image(&quot;test_set&quot;,img,i)writer.close() 如果下载不成功，通过迅雷等其他方式下载，建立dataset文件夹并将压缩文件直接放到dataset文件夹下，运行代码会自动解压 7.Dataloader的使用dataloader从dataset中取数据打包，以便送入神经网络 torch.utils.data.DataLoader() batch_size 表示每次多少个batch_size打成一包 shuffle 表示是否打乱顺序（每次for data in loader时是否打乱顺序，而不是说打包是否随机取，默认就是随机取的） drop_last 当data/batch_size除不尽要不要舍去剩下的data numofworks 设置为0表示用主进程加载，Windows下设置为其他值可能出错 12345678910111213141516171819202122232425import torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWritertest_data = torchvision.datasets.CIFAR10(&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)# 第一张图片和targetimg, target =test_data[0]print(img.shape) #torch.Size([3, 32, 32])print(target) #3# 测试batchsize、drop_last、shufflewriter = SummaryWriter(&quot;dataloader&quot;)# 可以发现两轮结果不一样，因为shuffle的原因for epoch in range(2): step = 0 for data in test_loader: imgs , targets = data writer.add_images(&quot;epoch: &#123;&#125;&quot;.format(epoch), imgs, step) step = step + 1writer.close() 8. torch.nnnn.module：Base class for all neural network modules. 所有神经网络模型都要继承nn.module 神经网络运行于forward函数之中 123456789101112131415import torchfrom torch import nnclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() def forward(self, input): output = input + 1 return outputtudui =Tudui()x = torch.tensor(1.0)output = tudui(x)print(output) pycharm的断点调试 9.卷积操作 torch.nn.functional.conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) stride：卷积核移动的步长 padding：输入图像是否填充 weight：卷积核 123456789101112131415161718192021222324252627import torchimport torch.nn.functional as F# 输入图像input = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]])# 卷积核kernel = torch.tensor([[1, 2, 1], [0, 1, 0], [2, 1, 0]])input = torch.reshape(input, (1, 1, 5, 5))kernel = torch.reshape(kernel, (1, 1, 3, 3))print(input.shape)print(kernel.shape)# 卷积操作output = F.conv2d(input, kernel, stride=1)print(output)output2 = F.conv2d(input, kernel, stride=2)print(output2)output3 = F.conv2d(input, kernel, stride=1, padding=1)print(output3) 10.神经网络卷积层 torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=’zeros’, device=None, dtype=None) in_channels：输入通道数 out_channels：卷积层内部可通过增加卷积核数量来增加通道数 kernel_size：只需要设置kernel_size，参数训练中调整 1234567891011121314151617181920212223242526272829303132333435import torchimport torchvisionfrom torch import nnfrom torch.nn import Conv2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64)# 建立神经网络模型class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() # 初始化nn.module self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) def forward(self,x): x = self.conv1(x) return xtudui = Tudui()writer = SummaryWriter(&quot;logs&quot;)step = 0# 检测模型for data in dataloader: imgs, targets = data output = tudui(imgs) # print(imgs.shape) # print(output.shape) writer.add_images(&quot;input&quot;, imgs, step) # 为了能够用tensorboard展示进行reshape,但仅此而已 output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() 池化层 池化的作用是减少参数量，下采样 池化层的stride默认是池化核的size ceil_model为true表示当输入图片不足池化核时仍然进行池化，false表示不进行 12345678910111213141516171819202122232425262728from torch import nnimport torchimport torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriter# 构建神经网络class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.maxpool1 = nn.MaxPool2d(kernel_size=3,ceil_mode=True) def forward(self, input): output = self.maxpool1(input) return output# 数据集dataset = torchvision.datasets.CIFAR10(&quot;dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataloader = DataLoader(dataset, batch_size=64)# 运行并展示writer = SummaryWriter(&quot;maxpool&quot;)tudui = Tudui()step = 0for data in dataloader: imgs, targets = data writer.add_images(&quot;imgs&quot;, imgs, step) output = tudui(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() 非线性激活引入非线性特征。relu、sigmoid 参数 inplace：一般inplace为false不覆盖 12345678910111213141516171819202122232425262728import torchfrom torch import nnimport torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.relu = nn.ReLU(inplace=False) def forward(self,input): output = self.relu(input) return outputdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset,batch_size=64)tudui = Tudui()writer = SummaryWriter(&quot;relu&quot;)step = 0for data in dataloader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, step) output = tudui(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() 线性层和其他层123456789101112131415161718192021import torchfrom torch import nnimport torchvisionfrom torch.utils.data import DataLoaderclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.linear = nn.Linear(196608,10) def forward(self, input): output = self.linear(input) return outputdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64, drop_last=True)tudui = Tudui()for data in dataloader: imgs, targets = data output = torch.flatten(imgs) output = tudui(output) print(output.shape) sequential的使用 123456789101112131415161718192021222324252627282930313233import torchfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xtudui = Tudui()print(tudui)input = torch.ones((64, 3, 32, 32))output = tudui(input)print(output.shape)writer = SummaryWriter(&quot;seq&quot;)writer.add_graph(tudui, input)writer.close() 损失函数与反向传播loss计算output和target之间的差距，loss越小越好，loss作为反向传播的依据 12345678910111213141516171819202122232425262728293031323334353637383940import torchimport torchvisionfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xdataset = torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(),download=True)dataloader = DataLoader(dataset, batch_size=64)# 损失函数loss = nn.CrossEntropyLoss()tudui = Tudui()for data in dataloader: imgs, targets = data output = tudui(imgs) result_loss = loss(output, targets) print(result_loss) input() 优化器lr：学习速率 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import torchimport torchvisionfrom torch import nnfrom torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linearfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterclass Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return x# 数据集dataset= torchvision.datasets.CIFAR10(&quot;./dataset&quot;,train=False,transform=torchvision.transforms.ToTensor(), download=True)dataloader = DataLoader(dataset, batch_size=64)# loss、模型、优化器loss = nn.CrossEntropyLoss()tudui = Tudui()optim = torch.optim.SGD(tudui.parameters(), lr=0.01)# 模型训练for epoch in range(20): running_loss = 0.0 for data in dataloader: imgs, targets = data output = tudui(imgs) result_loss = loss(output, targets) optim.zero_grad() # 将梯度清零 result_loss.backward() # 计算新的梯度 optim.step() # 根据梯度更新参数 running_loss = running_loss + result_loss print(running_loss) 现有模型的修改与使用123456789101112131415161718192021import torchvision# train_data = torchvision.datasets.ImageNet(&quot;../data_image_net&quot;, split=&#x27;train&#x27;, download=True,# transform=torchvision.transforms.ToTensor())from torch import nnvgg16_false = torchvision.models.vgg16(pretrained=False)vgg16_true = torchvision.models.vgg16(pretrained=True)print(vgg16_true)train_data = torchvision.datasets.CIFAR10(&#x27;../data&#x27;, train=True, transform=torchvision.transforms.ToTensor(), download=True)# 在现有模型后添加一层网络vgg16_true.classifier.add_module(&#x27;add_linear&#x27;, nn.Linear(1000, 10))print(vgg16_true)print(vgg16_false)# 修改现有模型某一层的参数值vgg16_false.classifier[6] = nn.Linear(4096, 10)print(vgg16_false) 11.完整训练套路CPU： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoader# 准备数据集train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# 数据集长度train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;训练数据集的长度为:&#123;&#125;&quot;.format(train_data_size))print(&quot;测试数据集的长度为:&#123;&#125;&quot;.format(test_data_size))# 利用DataLoader来加载数据集train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# 创建网络模型tudui = Tudui()# 损失函数loss_fn = nn.CrossEntropyLoss()# 优化器learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# 训练网络的一些参数# 记录训练次数total_train_step = 0# 记录测试次数total_test_step = 0# 训练的轮数epoch = 10# 添加tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------第&#123;&#125;轮训练开始--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data output = tudui(imgs) loss = loss_fn(output, targets) # 计算loss optimizer.zero_grad() # 梯度清零 loss.backward() # 计算梯度 optimizer.step() # 调整参数 total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # 测试步骤 tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;整体测试集上的Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;模型已保存&quot;)writer.close() 12. 利用GPU训练方法一：调用 网络模型、数据（输入、标注）、损失函数的 cuda方法 12if torch.cuda.is_available(): # 判断cuda是否可用 xxx GPU版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoader# 准备数据集train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# 数据集长度train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;训练数据集的长度为:&#123;&#125;&quot;.format(train_data_size))print(&quot;测试数据集的长度为:&#123;&#125;&quot;.format(test_data_size))# 利用DataLoader来加载数据集train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# 创建网络模型tudui = Tudui()if torch.cuda.is_available(): tudui = tudui.cuda() print(&quot;yes&quot;)# 损失函数loss_fn = nn.CrossEntropyLoss()if torch.cuda.is_available(): loss_fn = loss_fn.cuda()# 优化器learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# 训练网络的一些参数# 记录训练次数total_train_step = 0# 记录测试次数total_test_step = 0# 训练的轮数epoch = 10# 添加tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------第&#123;&#125;轮训练开始--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data if torch.cuda.is_available(): targets = targets.cuda() imgs = imgs.cuda() output = tudui(imgs) loss = loss_fn(output, targets) # 计算loss optimizer.zero_grad() # 梯度清零 loss.backward() # 计算梯度 optimizer.step() # 调整参数 total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # 测试步骤 tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data if torch.cuda.is_available(): targets = targets.cuda() imgs = imgs.cuda() outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;整体测试集上的Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;模型已保存&quot;)writer.close() 方法二： 首先创建device，然后调用 网络模型、数据（输入、标注）、损失函数 的to方法 123torch.device(&quot;cuda&quot;)torch.device(&quot;cpu&quot;)device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) GPU版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import torchimport torchvisionfrom torch.utils.tensorboard import SummaryWriterfrom model import *from torch import nnfrom torch.utils.data import DataLoaderdevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)# 准备数据集train_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=True, transform=torchvision.transforms.ToTensor(), download=True)test_data = torchvision.datasets.CIFAR10(root=&quot;./dataset&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)# 数据集长度train_data_size = len(train_data)test_data_size = len(test_data)print(&quot;训练数据集的长度为:&#123;&#125;&quot;.format(train_data_size))print(&quot;测试数据集的长度为:&#123;&#125;&quot;.format(test_data_size))# 利用DataLoader来加载数据集train_dataloader = DataLoader(train_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)# 创建网络模型tudui = Tudui()tudui = tudui.to(device)# 损失函数loss_fn = nn.CrossEntropyLoss()loss_fn = loss_fn.to(device)# 优化器learning_rate = 0.01optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)# 训练网络的一些参数# 记录训练次数total_train_step = 0# 记录测试次数total_test_step = 0# 训练的轮数epoch = 10# 添加tensorboardwriter = SummaryWriter(&quot;logs_train&quot;)for i in range(epoch): print(&quot;--------第&#123;&#125;轮训练开始--------&quot;.format(i)) for data in train_dataloader: imgs, targets = data targets = targets.to(device) imgs = imgs.to(device) output = tudui(imgs) loss = loss_fn(output, targets) # 计算loss optimizer.zero_grad() # 梯度清零 loss.backward() # 计算梯度 optimizer.step() # 调整参数 total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;.format(total_train_step,loss.item())) writer.add_scalar(&quot;train_loss&quot;,loss.item(),total_train_step) # 测试步骤 tudui.eval() total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data targets = targets.to(device) imgs = imgs.to(device) outputs = tudui(imgs) loss = loss_fn(outputs, targets) total_test_loss = total_test_loss + loss.item() accuracy = (outputs.argmax(1) == targets).sum() total_accuracy = total_accuracy + accuracy print(&quot;整体测试集上的Loss: &#123;&#125;&quot;.format(total_test_loss)) print(&quot;整体测试集上的正确率: &#123;&#125;&quot;.format(total_accuracy / test_data_size)) writer.add_scalar(&quot;test_loss&quot;, total_test_loss, total_test_step) writer.add_scalar(&quot;test_accuracy&quot;, total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(tudui, &quot;tudui_&#123;&#125;.pth&quot;.format(i)) print(&quot;模型已保存&quot;)writer.close() 13.模型验证123456tudui = torch.load(&quot;tudui_9.pth&quot;, map_location=torch.device(&#x27;cpu&#x27;)) # 如果使用GPU训练的模型，使用map_location映射到cpu上...# 测试之前：tudui.eval()with torch.no_grad(): test.py 1234567891011121314151617181920212223242526import torchimport torchvisionfrom PIL import Imagefrom torch import nnfrom model import *image_path = &quot;dataset/dog.jpg&quot;image = Image.open(image_path)print(image)image = image.convert(&#x27;RGB&#x27;)transform = torchvision.transforms.Compose([torchvision.transforms.Resize((32,32)), torchvision.transforms.ToTensor()])image = transform(image)print(image)tudui = torch.load(&quot;tudui_9.pth&quot;, map_location=torch.device(&#x27;cpu&#x27;))print(tudui)image = torch.reshape(image, (1, 3, 32, 32))tudui.eval()with torch.no_grad(): output = tudui(image)print(output)print(output.argmax(1)) pytorch入门部分 完结撒花😊","categories":[],"tags":[{"name":"DL","slug":"DL","permalink":"https://leungto.github.io/tags/DL/"}]},{"title":"回溯法题解","slug":"回溯法题解","date":"2023-01-02T09:36:20.000Z","updated":"2025-02-21T07:30:20.275Z","comments":true,"path":"2023/01/02/回溯法题解/","link":"","permalink":"https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/","excerpt":"","text":"书写结构：解空间和解结构，剪枝策略，示例，代码，时间复杂度分析 5-1子集和问题 1. 解空间和解结构类似于0-1背包问题，对于S大小为n的子集和问题，解空间是由长度为n的0-1向量组成，解的结构为子集树，如对于上述示例的解，解空间即为(1,1,1,0,0,0) 2. 剪枝策略注意到题目说S是正整数的集合，c是正整数，故深搜的过程一定使得子集和增加或不变。 考虑在某节点处向下搜索的过程，设当前层数为k（即当前考虑是否加入数S[k]到子集中） 约束函数：维护变量cw表示当前子集和，若cw+S[k]&gt;c，则剪去左子树 限界函数：计算变量rw表示剩余的整数之和(S[k+1:n-1]之和)，若cw+rw&lt;c，即将之后所有整数加入子集也无法得到解，故减去右子树 对于本题而言，如果只要一个可行解的话，可以在搜索每个节点的时候，在考虑完是否加入数S[k]之后，判断S[k]是否等于c，若等于，则无需再搜索了 3. 示例太多了不太好画，减少点数据量： 123 102 2 6 4. 代码这里就没弄文件读写了（可以直接粘贴下面的输入测试啦） 输入1： 125 102 2 6 5 4 输入2： 125 102 11 12 5 4 得到一个解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;const int N=100010;int S[N],res[N];int n,c;int num=0;//解的数量void dispsolution(int res[])&#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;num++&lt;&lt;&quot;个解&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void dfs(int cw,int rw,int res[],int level)&#123; if(level&gt;n)//到达叶节点了 &#123; if(cw==c)//找到可行解 &#123; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; exit(0);//直接结束程序(会不会有点暴力) &#125; &#125;else&#123; if(cw+S[level]&lt;=c)//考虑是否进入左子树 &#123; res[level]=1; dfs(cw+S[level],rw-S[level],res,level+1); &#125; rw=rw-S[level];//计算剩余整数之和(剩余整数不包括当前整数) //这里和博客不太一样(他rw算的是包括当前的整数的) if(cw+rw&gt;=c)//考虑是否进入右子树 &#123; res[level]=0; dfs(cw,rw,res,level+1); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; int rw=0;//为了方便计算rw,首先计算所有整数的和 for(int i=1;i&lt;=n;i++)//为了方便,从下标1开始 &#123; cin&gt;&gt;S[i]; rw=rw+S[i]; &#125; dfs(0,rw,res,1);//cw=1,res存储解,从第一层开始 if(num==0) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 得到所有解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;const int N=100010;int S[N],res[N];int n,c;int num=0;//解的数量void dispsolution(int res[])&#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;num++&lt;&lt;&quot;个解&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; if(res[i]) cout&lt;&lt;S[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void dfs(int cw,int rw,int res[],int level)&#123; if(level&gt;n)//到达叶节点了 &#123; if(cw==c) dispsolution(res);//找到可行解 &#125;else&#123; if(cw+S[level]&lt;=c)//考虑是否进入左子树 &#123; res[level]=1; dfs(cw+S[level],rw-S[level],res,level+1); &#125; rw=rw-S[level];//计算剩余整数之和(剩余整数不包括当前整数) //这里和博客不太一样(他rw算的是包括当前的整数的) if(cw+rw&gt;=c)//考虑是否进入右子树 &#123; res[level]=0; dfs(cw,rw,res,level+1); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; int rw=0;//为了方便计算rw,首先计算所有整数的和 for(int i=1;i&lt;=n;i++)//为了方便,从下标1开始 &#123; cin&gt;&gt;S[i]; rw=rw+S[i]; &#125; dfs(0,rw,res,1);//cw=1,res存储解,从第一层开始 if(num==0) cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 5. 时间复杂度分析考虑最坏情况下时间复杂度，每个节点都进行搜索，处理每个节点所需的时间均为$O(1)$，一共有1+2+4+8+…+2^n^ =$O(2^{n+1})$个节点，故时间复杂度为$O(2^{n+1})$ 参考：https://blog.csdn.net/gl620321/article/details/108801724 5-2 最小长度电路板排列问题 1. 解空间和解结构类似于旅行商问题，对于n个电路板的最小电路板排列问题，其解空间为n个数的全排列，解结构为排列树 2. 剪枝策略维护变量bestd表示当前的最小长度，假设此时选择第i个位置上的电路板，考虑选择第j个电路板(j&gt;=i，因为i前面的已经选择好了)作为该位置上的排列，此时利用已经选择好的第1~第i个位置上的电路板（第i个位置刚刚选择好的）来计算连接块的最大长度，若该长度小于当前最优解，则继续进行下面位置的选择，否则第i个位置上不能选择第j个电路板，剪去该子树 3. 示例示例数据量太大，减少点 123454 41 1 1 11 1 0 10 0 0 10 1 1 0 4个电路板，L1={1,2},L2={1,2,4},L3={1,4},L4={1,2,3} 类似于下面的画法（排列树太多了，只画了一个子树）： 最后的结果： 4. 代码输入文件 input.txt: 1234567898 51 1 1 1 10 1 0 1 00 1 1 1 01 0 1 1 01 0 1 0 01 1 0 1 00 0 0 0 10 1 0 0 1 输入含义 L1={1,4,5,6},L2={1,2,3,6,8},L3={1,3,4,5},L4={1,2,3,4,6},L5={1,7,8} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include&lt;fstream&gt;#include &lt;vector&gt;using namespace std;int n, m;int bestx[10];// 这是最终的最优解排列顺序int B[10][10];//电路板在连接块中的排列，是一个二维数组int x[10], low[10], high[10];// 分别是当前的排列、最左边电路板、最右边电路板int bestd=0;// 最优解int len(int ii) &#123;// 计算当前ii排列最小长度 for (int i = 1; i &lt;= m; i++) &#123; high[i] = 0; low[i] = n + 1;// 先初始化最左边和最右边的值， &#125; for (int i = 1; i &lt;= ii; i++)// 对于第i行 for (int k = 1; k &lt;= m; k++)// k列 if (B[x[i]][k] &gt; 0) &#123;// 如果第i个电路板在第k个连接块中， if (i &lt; low[k])//low[k]代表第K个连接块的最左边的值，如果i比它小，则更新左值 low[k] = i; if (i &gt; high[k]) high[k] = i;//如果比初始的右值大，则更新右值 &#125; int tmp = 0; for (int k = 1; k &lt;= m; k++) if (low[k] &lt;= n &amp;&amp; high[k] &gt; 0 &amp;&amp; tmp &lt; high[k] - low[k]) //若连接块的长度无法得到（前面两个bool表达式不满足，不计算该连接块的长度） tmp = high[k] - low[k];//计算每个连接块的举例 return tmp;&#125;void swap(int* x, int i, int j) &#123;// 交换i和j位置的值 int tmp; tmp = x[i]; x[i] = x[j]; x[j] = tmp;&#125;void backtrack(int i) &#123; if (i == n) &#123;// 如果到达末尾 int tmp = len(i);// 计算当前排列最小长度 if (tmp &lt; bestd) &#123; bestd = tmp; for (int j = 1; j &lt;= n; j++) bestx[j] = x[j]; &#125; // 如果比最优解还要好，则更新bestx[]排列； &#125; else &#123;// 若不是末尾； for (int j = i; j &lt;= n; j++) &#123; swap(x, i, j); int ld = len(i); if (ld &lt; bestd) backtrack(i + 1);// 则继续进入下一个数， swap(x, i, j); &#125; &#125;&#125;int arrangeBoards() &#123; bestd = n + 1;// 先假设一个很大的值 for (int i = 1; i &lt;= n; i++) x[i] = i;// 这里是最开始的排序； backtrack(1); return bestd;&#125;int main(void) &#123; ifstream ifs(&quot;input.txt&quot;);//文件输入流 ifs&gt;&gt;n; ifs&gt;&gt;m; vector&lt;int&gt; temp(m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; ifs&gt;&gt;B[i][j] ;// 输入的电路板的二维数组排列 &#125; &#125; int minLen = arrangeBoards(); cout&lt;&lt;minLen&lt;&lt;endl; for (int i = 1; i &lt;= n; i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; ifs.close(); return 0;&#125; 5. 时间复杂度分析对于最坏情况，每个节点都需要计算一次len，即序号运行len函数，而第i层节点运行len函数时间复杂度为$O(im)$，故最坏情况下所需时间为$T=O(m)(n-1)+O(2m)(n-1)(n-2)+…+O(nm)(n-1)!$，故最坏情况下时间复杂度为$O(mn!)$ 5-3 最小重量机器设计问题 题目两个要求，总价格不超过d，并且部件重量之和要最小 1. 解空间和解结构对于n个部件，m个供应商的最小重量机器设计问题，其解空间为长度为n的向量，向量的每一项为1~m的整数，对应的解结构为排列树（也不是那种TSP的排列树，不过也是排列啦，姑且称之为排列树） 2. 剪枝策略考虑第i个部件供应商的选择 约束函数：维护变量cp表示当前已经购得的部件的价格之和，假设考虑选择第j个供应商，若cp+c[i][j]&gt;d，则剪去以该节点为根节点的子树，无需再进行搜索 限界函数：维护变量cw表示当前已经购得的部件的重量之和，变量bestw表示当前最优解的重量之和，假设考虑选择第j个供应商，若cw+w[i][j]&gt;=bestw，则剪去该节点为根节点的子树，无需进行搜索 3. 示例对于题中示例画树： 4. 代码输入： 12345673 3 41 2 33 2 12 2 21 2 33 2 12 2 2 没实现文件读写了~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,d;//n个部件，m个供应商，总价格不超过dint c[999][999];//c[i][j]为从供应商j购买部件i所花费的价格；int w[999][999];//w[i][j]为......重量int cw=0,cp=0;//当前部件的重量 价格int bestw=999,bestp=999;//最优方案的重量，价格int x[999];//当前部件i从供应商j购买int bestx[999];//最优方案部件i从哪个供应商买void backtrack(int i)&#123; if(i&gt;=n)&#123;//到达最后一层 if(cp&lt;=d&amp;&amp;cw&lt;bestw)&#123;//如果价格没超过d，并且重量小于之前方案的bestw bestw=cw;//重量更新 bestp=cp;//价格更新 for(int k=0;k&lt;n;k++)&#123; bestx[k]=x[k];//部件的供应商进行更新 &#125; &#125; &#125; else&#123; //所有的方式都尝试了一遍，比较找到最优的重量 for(int j=0;j&lt;m;j++)&#123; x[i]=j;//当前部件i的供应商为j cw=cw+w[i][j]; cp=cp+c[i][j]; if(cw&lt;bestw&amp;&amp;cp&lt;=d)//如果这次的选择要比之前方案的更优 backtrack(i+1); //回溯 cw-=w[i][j]; cp-=c[i][j]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;//n个部件，m个供应商，总价格不超过d int i=0,j=0; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;c[i][j];//c[i][j]为从供应商j购买部件i所花费的价格； &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;w[i][j];//w[i][j]为......重量 &#125; &#125; backtrack(0);//第i个部件 cout&lt;&lt;bestw&lt;&lt;endl;//最优方案的重量 for(int k=0;k&lt;n;k++) cout&lt;&lt;bestx[k]+1&lt;&lt;&quot; &quot;; //因为j从0开始，所以输出的时候加一个1；&#125; 5. 时间复杂度分析考虑最坏情况，对于每个非叶子节点，搜索所需时间为$O(m)$，对于每个叶子节点，搜索所需的时间为$O(1)$，故最坏情况下所需时间为$T=m*(m+m^2+…+m^{n-1})+m^n=O(m^n)$ 5-4 运动员最佳配对问题 输入： 1234567310 2 32 3 43 4 52 2 23 5 34 5 1 输出： 152 1. 解空间和解结构将问题转换为男运动员选女运动员的问题，故n个男、女运动员的运动员最佳匹配问题的解空间为n个数的全排列，对应的解结构为排列树 2. 剪枝策略考虑对第i个男运动员匹配女运动员的情况，其中变量Max存储当前最优解的竞赛优势，变量sum存储第1~i-1个已经匹配完成的男运动员的竞赛优势，计算第i~n个男运动员的最大可能的竞赛优势ctn，若cnt+sum&lt;Max，则剪去该节点及其子树 其中第j个男运动员的最大可能的竞赛优势为该男运动员与所有女运动员进行匹配所得竞赛优势中最大者，存储到maxsum数组中 3.示例 4.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int n;int boy[21][21],girl[21][21]; //分别用于存放男、女运动员的竞赛优势int Max=INT_MIN; //Max代表男女双方竞赛优势的总和的最大值int sum=0; //sum为临时求和int data[21][21]; //data[i][]用于存放男运动员 i 配对后的双方竞赛优势int maxSum[21]; //记录每个男生匹配后可达到的最大双方竞赛优势int book[21]; //用于标记女运动员是否已匹配：book[0]未匹配；book[1]匹配void dfs(int t)&#123; if(t&gt;=n) //t到达n之后，代表全部标记访问了,得到了最大值 &#123; Max=max(Max,sum); return ; &#125; int ctn=0; //剪枝函数:之前t个已匹配好的男女运动员的sum与之后的 t-&gt;n-1 个男匹配女的最大值加起来与已经得到的Max比较，若前者&lt;=Max，剪枝 for(int i=t;i&lt;n;i++) //求t及t之后男生匹配女生的最大值的和 ctn+=maxSum[i];//若从第t组-&gt;第n组，当前搜索sum加上假设匹配后的最大值cxn，仍然小于Max ，就需要剪枝了，则Max为已经求得的最大值 if(sum+ctn&lt;Max) return ; for(int i=0;i&lt;n;i++) //若cxn&gt;=Max，要探索子树。从第t个男生开始匹配，找未匹配的女生 &#123; if(!book[i]) //第 i 个女生未匹配 &#123; book[i]=1; //第 t 个男生匹配女生i sum+=data[t][i]; //加上男生t与女生i的男女双方竞赛优势 dfs(t+1); //为第i+1个男生匹配 book[i]=0; //若第 t 个男生匹配女生i得到的sum不大于Max，则回溯 sum-=data[t][i]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) //输入男运动员的竞赛优势 &#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;boy[i][j]; &#125; for(int i=0;i&lt;n;i++) //输入女运动员的竞赛优势 &#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;girl[i][j]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; //对每个男生都求男女双方竞赛优势，则能得到i*j种结果（涵盖了P[i][j]*Q[j][i]与Q[i][j]*P[j][i]） data[i][j]=boy[i][j]*girl[j][i]; maxSum[i]=max(maxSum[i],data[i][j]); //记录每个男生匹配后可达到的最大双方竞赛优势，用于后面的剪枝 &#125; &#125; dfs(0); cout&lt;&lt;Max&lt;&lt;endl; return 0;&#125; 5.时间复杂度分析考虑最坏情况，每个节点都需要搜索，对于非叶子节点，其需要时间为$O(n)$，对于叶子节点，其所需时间为$O(1)$，故所需时间为$T=n(n+n(n-1)+…+n!)+n!=O(n*n!)$ 5-5 无分隔符字典问题 1. 解空间和解结构由S为$L_k$子集可知n个符号，长度为k的无分隔符字典问题的解空间为长度为$n^k$的向量，其中向量每一项为0或1，表示$L_k$中某一项是否在S中，解结构为子集树 2. 剪枝策略首先将$L_k$中所有字字符串放入数组L中，考虑是否放入下标为i的字符串： 约束函数：若该字符串与当前S集合中的任意字符串按照题目所给方式进行拼接，结果均不在S集合中，且不为该字符串本身，则考虑将其放入，搜索其左子树，否则剪去该节点的左子树 限界函数：考虑不放入该字符串，若将i+1~$n^k$的字符串均放入，若n^k^-i+S.size&lt;best，则无需搜索其右子树，剪去该节点的右子树 3. 示例假设$\\sum=(a,b),L_k=\\{aa,ab,ba,bb\\}$,则$L_k$的一个最大无分隔符字典为$\\{aa,bb\\}$ 4. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int *ak;int lk;int n, k;int best = 0; //最大无分隔符字典元素个数vector&lt;int&gt; L; //将所有的长度为k的数字字符串存到集合L中set&lt;int&gt; S; //当前字典中的字符串存储在集合s中//将下标为L[]中下标为i的字符串存入集合svoid insert(int i)&#123; S.insert(L[i]);&#125;//将下标为L[]中下标为i的字符串存入集合svoid erase(int i)&#123; S.erase(L[i]);&#125;//将ak[]中起点为i，长度为k数字串转换为十进制数字int digi(int i)&#123; int x = 0; for(int j=0; j&lt;k; j++) &#123; x *= 10; x += ak[j]; &#125; return x;&#125;//判断字符串a和第b个字符串是否互不为前缀bool pref(int a, int b)&#123; int bb =b;//这里用bb只是因为原代码不太对,我直接改了 int x = a; int y = bb/10;//去掉最后一位，得到高k-1位(因为验证的时候这位是肯定要剔除的 //按理说x也要剔除最高位，但是后面的循环不会碰到最高位，所以这里没剔除了 for(int i=0; i&lt;k-1; i++) //ak[0, k-2]存放x的低k-1位，ak[k-1, k-1 + (k-2)]存放y &#123; ak[k-i-2] = x % 10; x /= 10; ak[2*k-i-3] = y % 10; y /= 10; &#125; for(int i=0; i&lt;k-1; i++) //相当于依次判断a2a3..akb1, a3a4..b1b2, akb1..bk-1是否已存在于S中，本程序中下标从0开始 if(S.count(digi(i)) &gt; 0||digi(i)==bb) //如果已存在于S中 return true; x = bb; y = a/10; for(int i=0; i&lt;k-1; i++)//先放b再放a &#123; ak[k-i-2] = x % 10; x /= 10; ak[2*k-i-3] = y % 10; y /= 10; &#125; for(int i=0; i&lt;k-1; i++) if(S.count(digi(i)) &gt; 0||digi(i)==bb) return true; return false;&#125;//判断当前下标为b的字符串是否可以加入字典//将字符串a1a2..ak看作k位十进制数bool oka(int b)&#123; int bb = L[b]; set&lt;int&gt;::iterator it; //定义迭代器 it = S.begin(); while(it != S.end()) &#123; int a = *it; if(pref(a, bb)) //如果a,b其中一个是另一个的前缀 return false; it++; &#125; return true;&#125;//得到总元素个数为n，长度为m的全排列void Perm(int list[], int dep, int m, int n)&#123; if(dep&gt;m) &#123; int x = 0; for(int i=1; i&lt;=m; i++) x = x*10 + list[i]; //转换为十进制数字 L.push_back(x); //将所有的数字字符串存到集合L中 &#125; else for(int j=1;j&lt;=n;j++) &#123; swap(list[dep], list[j]); Perm(list, dep+1, m, n); swap(list[dep], list[j]); &#125;&#125;void backtrack(int dep)&#123; if(dep &gt;= lk) &#123; if(S.size() &gt; best) best = S.size(); return; &#125; if(oka(dep)) &#123; insert(dep); backtrack(dep+1); erase(dep); &#125; if(lk-dep+S.size()&gt;best) backtrack(dep+1);&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;输入正整数n：&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\n输入正整数k：&quot;; fin &gt;&gt; k; cout &lt;&lt; k; ak = new int[2*k]; lk = n; for(int i=1; i&lt;k; i++) //k个字符中，每一个字符都有n种选择，n^k表示所有由k个字符组成的字符串种数 lk *= n; lk--; int *x = new int[n+1]; for(int i=1; i&lt;=n; i++) x[i] = i; Perm(x, 1, k, n); //将长度为k的全排列存入集合L中 backtrack(0); cout &lt;&lt; &quot;\\n最大无分隔符字典元素个数为：&quot; &lt;&lt; best; cout &lt;&lt; endl; cout &lt;&lt; endl; fin.close(); return 0;&#125; 5. 时间复杂度考虑最坏情况，对于n个字符，长度为k的问题，对于每个非叶子节点的左子节点，搜索需要耗费时间为$O(n^kk)$，对于右子节点搜索需要的时间为$O(1)$，对于叶节点需要时间$O(1)$，故耗费的时间$T=O(2^{n^k-1}n^k*k)$ 5-6 无合集问题 大概的思路是从1开始每个数都尝试放入n个子集的每个子集，然后用题目给的条件x+y不属于S进行剪枝 1. 解空间和解结构从1开始尝试放入每个子集中，对于子集为n的无合集问题，其解空间为长度为k的向量，向量的每一项为1~n，表示对应下标的数分配到的子集，其中k为本题所求，以n=3为例，解结构如下： 2. 剪枝策略据题意，若数i无法分配到集合j(不满足和不在集合的条件)，则该节点的第j个分支无需遍历，剪去该分支 3. 示例 4. 代码定义存储当前解的数组a[N][N],其中a[n][0]表示第n个子集的元素个数a[n][1]到a[n][a[n][0]]为这个子集的所有元素。定义n。设置初始的结果ans为1(最后要减1，所以初始值其实是0)，定义最优值为best，定义最优解为e[N][N]，其中的结构和a[N][N]一样,以及定义判定数组h[N][N]，h[i][j]表示第i个子集中是否有j这个元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110;int a[N][N], n, ans = 1, best, e[N][N];bool h[N][N];void dfs(int level)&#123; //判断当前ans中的数是否能插入第level个子集 if(level == n)&#123; //n个子集的下标是0到n-1,所以当level等于n时表示当前ans不能插入所有子集 if(ans &lt;= best) return; //如果当前ans不如当前最优值best，就返回 best = ans; //如果比最优值好，更新最优值和最优解 for(int i = 0; i &lt; n; i ++)&#123; for(int j = 0; j &lt;= a[i][0]; j ++) e[i][j] = a[i][j]; &#125; return; &#125; else&#123; //判断ans能否插入第level个子集 bool flag = true; for(int i = 1; i &lt;= a[level][0]; i ++)&#123;//遍历子集 //如果ans减当前元素在子集中且这个元素不是它本身,flag就为false,表示ans不能插入这个子集 if(h[level][ans - a[level][i]] &amp;&amp; ans - a[level][i] != a[level][i]) flag = false; &#125; if(!flag) dfs(level + 1); //不能插入，判断ans能不能插入第level+1个子集 else&#123; //可以插入，分两种情况，一种是插入，一种是不插入此子集 //插入的情况 a[level][++ a[level][0]] = ans; //第i个子集个数加一，把元素记入子集 h[level][ans ++] = true; //把此元素标记为在此子集中 dfs(0); //判断下一个数是否能插入第0个子集 //回溯到不插入的情况，把子集个数减1，再把当前元素标记为不在此子集中 -- a[level][0]; h[level][-- ans] = false; dfs(level + 1); //判断这个数是否能插入下一个子集 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); cout &lt;&lt; --best &lt;&lt; endl; //记录的是最优值加一，这里减去一并输出 for(int i = 0; i &lt; n; i ++)&#123; for(int j = 1; j &lt;= e[i][0]; j ++) printf(&quot;%d &quot;, e[i][j]); //输出最优解 puts(&quot;&quot;); &#125; return 0;&#125; 参考：无和集问题 - AcWing 5. 时间复杂度考虑最坏情况，对于非叶子节点，假设其位于第i层，则时间消耗为$O(i)$，对于非叶子节点，其时间消耗为$O(1)$,本题时间消耗还与树的层数有关，而层数又是要求的。。。，需要一些推导来得到一个上界吧~ 5-7 n色方柱问题 为了提高效率，用图论的知识简化了题目（我没怎么看懂为啥这样简化的），谢谢有被恶心到 有点难懂，我觉得不会考。。。，理解一下代码吧 代码input.txt: 1234564RGBY0 2 1 3 0 03 0 2 1 0 12 1 0 2 1 31 3 3 0 2 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 50;int board[MAX][6]; //存储n个立方体各面的颜色int solu[MAX][6]; //存储解int n; //立方体个数、颜色种数int ans = 0; //解的个数int used[MAX];char color[MAX];//找到一个解后，输出void out(int edge[])&#123; int i, j, k, a, b, c, d; for(i=0; i&lt;2; i++) //2个子图 &#123; for(j=0; j&lt;n; j++) used[j] = 0; do&#123; j = 0; d = c = -1; while(j&lt;n &amp;&amp; used[j]&gt;0) //找下一条未用的边 j++; if(j &lt; n) do&#123; a = board[j][edge[i*n+j]*2]; b = board[j][edge[i*n+j]*2+1]; if(b == d) //如果上一条边的终点与b相同，说明b为始点，交换，保证a为始点 swap(a, b); //保证有向边的始点对应于前面和左面，终点对应于背面和右面 solu[j][i*2] = a; solu[j][i*2+1] = b; used[j] = 1; if(c&lt;0) //开始顶点 c = a; d = b; for(k=0; k&lt;n; k++) //找下一个立方体 if(used[k]==0 &amp;&amp; (board[k][edge[i*n+k]*2]==b || board[k][edge[i*n+k]*2+1]==b)) j = k; &#125;while(b != c); //找了一圈，回到起点 &#125;while(j&lt;n); //所有立方体都找遍 &#125; for(j=0; j&lt;n; j++) //立方体的顶面和底面的颜色 &#123; k = 3 - edge[j] - edge[j+n]; a = board[j][k*2]; b = board[j][k*2+1]; solu[j][4] = a; solu[j][5] = b; &#125; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;6; j++) cout &lt;&lt; color[solu[i][j]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;&#125;void search()&#123; int i, t, cube; bool ok, newg, over; int *vert = new int[n]; //记录子图中每个顶点的度，应均为2 int *edge = new int[n*2]; //记录每个立方体中边被选用的条数，每个立方体只有3条边，有两个子图要选用 for(i=0; i&lt;n; i++) vert[i] = 0; t = -1; newg = true; while(t &gt; -2) &#123; t++; cube = t % n; //每个立方体找2次，得到真实的立方体编号，也是子图中边的编号 if(newg) //如果没有边被选入子图 edge[t] = -1; over = false; //是否结束，即两个子图构建完成 ok = false; //标记边是否已用过，两个子图不应有公共边 while(!ok &amp;&amp; !over) &#123; edge[t]++; //边被选用加入子图，使用次数增加 if(edge[t]&gt;2) //在立方体每对相对面的顶点连一条边，每个立方体只有3条边 over = true; else ok = (t&lt;n || edge[t]!=edge[cube]); //是否已用过 &#125; if(!over) &#123; //检测边的两个顶点的度 if(++vert[board[cube][edge[t]*2]] &gt; 2+t/2*2) //如果是第一个子图，顶点度不能超过2 ok = false; //如果是第二个子图，加上第一个子图，顶点度不能超过4 if(++vert[board[cube][edge[t]*2+1]] &gt; 2+t/2*2) ok = false; if(t%n == n-1 &amp;&amp; ok) //如果一个或两个子图已构建完成 for(i=0; i&lt;n; i++) if(vert[i] &gt; 2+t/n*2) ok = false; if(ok) &#123; if(t == n*2-1) //找到解 &#123; ans++; out(edge); return; &#125; else newg = true; &#125; else //取下一条边 &#123; --vert[board[cube][edge[t]*2]]; //边的两个顶点 --vert[board[cube][edge[t]*2+1]]; t--; newg = false; &#125; &#125; else //回溯 &#123; t--; if(t &gt; -1) &#123; cube = t % n; --vert[board[cube][edge[t]*2]]; --vert[board[cube][edge[t]*2]]; &#125; t--; newg = false; &#125; &#125;&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;输入立方体个数：&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\n输入颜色：&quot;; for(int i=0; i&lt;n; i++) &#123; fin &gt;&gt; color[i]; cout &lt;&lt; color[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n输入立方体各面颜色：\\n&quot;; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;6; j++) &#123; fin &gt;&gt; board[i][j]; cout &lt;&lt; board[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;\\n立方体叠置方案为：\\n&quot;; search(); if(ans == 0) cout &lt;&lt; &quot;No Solution！\\n&quot;; cout &lt;&lt; end; fin.close(); return 0;&#125; 5-8 整数变换问题 这道题是一定能找到的，有点类似于3n+1?，要不然会要求输出no solution的，而且我们也不能简单地通过n和m的大小关系来得到此时需要做的操作。题目的思路大概就是DFS暴力搜索，左子树f变换，右子树g变换，主要问题在于需要限制搜索的层数，因为有些分支是得不到解的 1. 解空间和解结构解空间是一个长度为k的向量，向量的每一项是f或者g，k的大小与输入有关，解结构如下：左子树是进行f变换，右子树是进行g变换。 2. 剪枝策略虽然看到一些博客根据n和m的大小剪枝，但是实际上在代码中他们没有这样做，而且这种做法应该是不对的。。。 我觉得这里更加类似于DFS，代码也没体现出什么剪枝的策略，这里的搜索过程有点像是一层一层往下搜索，k控制着层数 3. 示例1237 43gfg 4. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define N 25#define inf 0x3f3f3f3fint n, m;//定义k来表示搜索树的深度int k = 1;//定义一个队列来存放各类操作queue&lt;char&gt; q;bool DFS(int x, int n)&#123; //防止死循环，保证最多只能访问到下一层 if(x &gt; k) return false; //找到返回true if(n == m) return true; //这里必须用一个temp做临时变量 //若不用temp做临时变量，回溯的时候n的值发生变化 //导致结果异常 int temp = n; //左右都做一遍，看看能否到达目的 for(int i = 0; i &lt; 2; i++) &#123; if(i == 0) temp = n * 3; else temp = n / 2; if(DFS(x+1, temp)) &#123; if(i == 0) q.push(&#x27;f&#x27;); else q.push(&#x27;g&#x27;); //这里必须要return true //因为只需要找到第一个满足条件的那条路径 //回溯返回的时候把路径上的运算加入队列即可。 return true; &#125; &#125; //如果没找到返回false,k++ //可往更深一层探索 return false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //找不到，往更深一层探索！ while(!DFS(0, n)) k++; cout &lt;&lt; k &lt;&lt; endl; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); &#125; return 0;&#125; 5. 时间复杂度树的层数和输入的数关系比较大，不太好分析。。。，如果树的层数可以得到一个上界的话，可以推导一下最坏情况 参考：https://blog.csdn.net/Small___ming/article/details/103218990 5-9 拉丁矩阵问题 可以从左到右从上到下来填充矩阵的每个“格子”，即树的每一层就是考虑每个格子里放什么，这将得到一棵比较大的树，剪枝的策略就是题目所要求的，每行每列都没有相同的形状，若在该格子里放入第i种宝石能满足要求，则将其放入，否则剪去该条分支，对于检查每行每列是否有相同形状，可以采用两个矩阵来记录，这样时间效率会高点 1. 解空间和解结构本题是求可行解的个数，解空间是一个n行m列的矩阵，也可以理解为n*m长度的向量，其中向量的每个元素为1~n，对应的解结构为排列树 2. 剪枝策略维护矩阵row[N][N]，其中row[i][j]=1表示第i行已经使用了形状j，矩阵col[N][N]，其中col[j][i]=1表示第i列使用了形状j，考虑在为矩阵(x,y)位置上元素选择宝石时，若选择宝石i，则需要保证row[x][i]==0&amp;&amp;col[i][y]==0，即不与x行和y列上已有的形状冲突，若不满足该条件，则可剪去该子树 3. 示例 4. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#define N 10int m,n; //分别为行、列int count=0;int a[N][N]=&#123;0&#125;;int row[N][N]=&#123;0&#125;;//row[i][j]=1表示第i行已经使用了形状jint col[N][N]=&#123;0&#125;;//col[j][i]=1表示第i列已经使用了形状jvoid backtrack(int t)//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1//如第一行就是0 1 2 3 4...&#123; int i,j; int x,y; //分别为行、列（坐标） if(t==m*n)//如果排完了,说明得到了一种可行解 &#123; count++; return; &#125; //否则继续排列 x=t/n; //行坐标 y=t%n; //列坐标 for(i=1;i&lt;=n;i++)//对每种形状都进行尝试 &#123; if(row[x][i]==0&amp;&amp;col[i][y]==0) &#123; row[x][i]=1; col[i][y]=1; a[x][y]=i; backtrack(t+1); row[x][i]=0;//回溯 col[i][y]=0; a[x][y]=0; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); backtrack(0); printf(&quot;count=%d\\n&quot;,count); return 0;&#125; 5. 时间复杂度考虑最坏情况，对于叶子节点，其时间消耗为$O(1)$，对于非叶子节点其时间消耗为$O(n)$，对于n种宝石，排成n行m列的拉丁矩阵问题，时间消耗为$T=O(n^{mn})$ 5-10 排列宝石问题 这道题是类似于5-9的(直接在5-9上面改的几行)，说一下思路吧：类似于对待不同宝石类型要求每行每列都不重复，引入数组color_row和数组color_col，其大致结构和含义与row和col类似，用于记录该行或者该列是否已经使用过该种颜色的宝石，还引入used数组用于满足题中的每种宝石n颗且不同色（避免一种宝石的一种颜色使用了多次），其中used[i][j]=1表示类型i的宝石的第j种颜色已用。 与5-9对比，排列树可选的分支大大增加了，不过剪去的分支也比较多，时间复杂度往上蹭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define N 10using namespace std;int n; //分别为行、列int res=0;int row[N][N]=&#123;0&#125;;//row[i][j]=1表示第i行已经使用了形状jint col[N][N]=&#123;0&#125;;//col[j][i]=1表示第i列已经使用了形状jint color_row[N][N]=&#123;0&#125;;int color_col[N][N]=&#123;0&#125;;int used[N][N]=&#123;0&#125;;//used[i][j]=1表示类型i的第j种颜色已用void backtrack(int t)//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1//如第一行就是0 1 2 3 4...&#123; int i,j; int x,y; //分别为行、列（坐标） if(t==n*n)//如果排完了,说明得到了一种可行解 &#123; res++; return; &#125; //否则继续排列 x=t/n; //行坐标 y=t%n; //列坐标 for(i=1;i&lt;=n;i++)//对每种形状都进行尝试 &#123; for(j=1;j&lt;=n;j++)&#123;//j为颜色 if(!row[x][i]&amp;&amp;!col[i][y]&amp;&amp;!color_row[x][j]&amp;&amp;!color_col[j][y]&amp;&amp;!used[i][j]) &#123; row[x][i]=1; col[i][y]=1; color_row[x][j]=1; color_col[j][y]=1; used[i][j]=1; backtrack(t+1); row[x][i]=0; col[i][y]=0; color_row[x][j]=0; color_col[j][y]=0; used[i][j]=0; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); backtrack(0); printf(&quot;res=%d\\n&quot;,res); return 0;&#125; 5-11 重复拉丁矩阵问题 这题是类似于5-9的，我的代码一直没AC，参考了下答案的，思路是：第一行按照题意，由于对每行每种宝石数量的限制，且要求第一行最小字典序，所以是固定的，无需回溯，故从第二行开始进行搜索。答案遵照教材的排列树的写法，先初始化矩阵，然后再做swap操作，矩阵初始化情况如虚线上矩阵(示例为例)，在搜索的时候，只需要考虑每列宝石要求即可（因为初始化的原因，不需要考虑每行了），但是很奇怪的是，代码没有考虑第一列的情况了，即认为第一列也是固定的，但是我觉得不太对，比如虚线下面的一种也是可以的。 12345678910省略第0行、第0列1 1 2 2 3 3 31 &lt;1&gt; 2 2 3 3 32 1 1 2 3 3 32 1 2 1 3 3 3-------------1 1 2 2 3 3 3 3 3 3 2 2 1 1 3 3 3 1 2 2 1 3 3 2 1 3 1 2 input: 124 7 32 2 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 50;int n, m, k;int times[MAX]; //每种宝石的重复次数int id[MAX]; //每个宝石的价值序号int board[MAX][MAX]; //宝石矩阵//考察当前列宝石数是否多于应出现的次数bool ok(int r, int c, int s)&#123; int k = board[r][s]; int i; if(s &gt; c) for(i=c; i&lt;s; i++) if(board[r][i] == k) //如果已经试过相同类型的宝石，这次就不再试了 return false; int count = 0; for(i=1; i&lt;r; i++) //考察当前列宝石数是否多于应出现的次数 if(board[i][c] == k) count++; if(count &gt;= times[k]) //times[k]表示种类为k的宝石应出现的次数 return false; else return true;&#125;double num = 0; //不同的宝石排列方案数//从上到下，从左到右递归搜索，即先行后列void backtrack(int r, int c)&#123; for(int i=c; i&lt;=n; i++) //列 if(ok(r, c, i)) &#123; swap(board[r][c], board[r][i]); if(c == n) //如果列考察完毕 &#123; if(r == m) //如果行考察完毕 &#123; num += 1; //cout &lt;&lt; num &lt;&lt; &quot; &quot;; return; &#125; else backtrack(r+1, 2); //考察下一行 &#125; else backtrack(r, c+1); //考察下一列 swap(board[r][c], board[r][i]); &#125;&#125;int main()&#123; ifstream fin(&quot;input.txt&quot;); cout &lt;&lt; &quot;\\n输入行数m：&quot;; fin &gt;&gt; m; cout &lt;&lt; m; cout &lt;&lt; &quot;\\n输入列数n：&quot;; fin &gt;&gt; n; cout &lt;&lt; n; cout &lt;&lt; &quot;\\n输入宝石价值种数：&quot;; fin &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl; int i, temp; int t = 1; for(i=1; i&lt;=k; i++) &#123; cout &lt;&lt; &quot;输入第&quot; &lt;&lt; i &lt;&lt; &quot;种宝石在每行每列出现的最多次数：&quot;; fin &gt;&gt; times[i]; cout &lt;&lt; times[i] &lt;&lt; &quot;\\n&quot;; temp = times[i]; while(temp&gt;0) &#123; id[t++] = i; temp--; &#125; &#125; int j; for(i=1; i&lt;=m; i++) //初始化为单位矩阵 for(j=1; j&lt;=n; j++) board[i][j] = id[j]; //第一行已经排列好了,无需再改变了 /* 由于初始化后的单位矩阵的第一列都是1，为使矩阵的第一列同时满足一下两个条件： 同一种宝石数都不超过规定的数量，第1列从上到下的宝石按宝石的价值最小字典序从小到大排列 将第i行的第一个宝石与它同行的第i个宝石交换位置 */ for(i=2; i&lt;=n; i++) swap(board[i][1],board[i][i]); backtrack(2, 2); cout &lt;&lt; &quot;\\n不同的宝石排列方案数为：&quot; &lt;&lt; num; cout &lt;&lt; endl &lt;&lt; endl; return 0;&#125; 下面是我的代码，在5-9基础上改的，输出的文件out.txt是所有的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define N 10using namespace std;int m,n,k; //分别为行、列int res=0;int a[N][N]=&#123;0&#125;;int row[N][N]=&#123;0&#125;;//row[i][j]=1表示第i行已经使用了形状jint col[N][N]=&#123;0&#125;;//col[j][i]=1表示第i列已经使用了形状jint maxtime[N]=&#123;0&#125;;void backtrack(int t,ofstream&amp;out)//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1//如第一行就是0 1 2 3 4...&#123; int x,y; //分别为行、列（坐标） if(t==m*n)//如果排完了,说明得到了一种可行解 &#123; res++; out&lt;&lt;&quot;---&quot;&lt;&lt;res&lt;&lt;endl; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; out&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; &#125; out&lt;&lt;endl; &#125; out&lt;&lt;endl; return; &#125; //否则继续排列 x=t/n; //行坐标 y=t%n; //列坐标 for(int i=1;i&lt;=k;i++)//对每种形状都进行尝试 &#123; bool flag=true; if(x==0&amp;&amp;y&gt;0&amp;&amp;i&lt;a[x][y-1]) flag=false; if(y==0&amp;&amp;x&gt;0&amp;&amp;i&lt;a[x-1][y]) flag=false; if(flag&amp;&amp;row[x][i]&lt;maxtime[i]&amp;&amp;col[i][y]&lt;maxtime[i]) &#123; //cout&lt;&lt;maxtime[i]&lt;&lt;&quot;: &quot;&lt;&lt;row[x][i]&lt;&lt;&quot;,&quot;&lt;&lt;col[i][y]&lt;&lt;&quot;| &quot;&lt;&lt;res&lt;&lt;endl; row[x][i]++; col[i][y]++; a[x][y]=i; backtrack(t+1,out); row[x][i]--;//回溯 col[i][y]--; a[x][y]=0; &#125; &#125;&#125;int main()&#123; ofstream out; out.open(&quot;out.txt&quot;); scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k); for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;maxtime[i]); backtrack(0,out); printf(&quot;res=%d\\n&quot;,res); out.close(); return 0;&#125; 5-12 罗密欧与朱丽叶的迷宫问题 从罗密欧的位置开始，每次都可以走八个方向，用数字记录方向，若下一次走的方向与直接的不同则记转向次数加一，在考虑进入八个方向的下一位置前，需要考虑该位置是否越界，是否是封闭位置，是否已经走过，且是否走入后当前转向次数大于当前最优解此时，以此作为剪枝策略，当遍历完所有的位置后，若到达了朱丽叶的位置，则考虑更新当前最优解或者是增加最优解的次数 1. 解空间和解结构对于n行m列，封闭房间数为k的迷宫，迷宫问题的解空间为1~n*m-k的全排列，表示某个房间第几次到达，解结构为排列树 2. 剪枝策略约束函数：在尝试走入下一位置前，检查该位置是否合法，即是否数组越界，是否为封闭房间，是否已经走过，若不合法，则剪去该子树 限界函数：维护变量curr_rotation表示当前转向次数，min_rotation表示当前最优解的转向次数，若在考虑下一位置时，到达该位置后的转向次数大于最优解的转向次数，则剪去该子树 3. 代码input: 123453 4 21 23 41 12 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; int x, y;&#125;;Point luo;Point ye;Point pos;// 定义八个方向:右,int dx[8] = &#123; 1, 0, -1, 0, 1, 1, -1, -1 &#125;; //八个方向int dy[8] = &#123; 0, 1, 0, -1, 1, -1, 1, -1 &#125;;const int MAX = 10;int n, m, k;int board[MAX][MAX];int best[MAX][MAX];int curr_rotation = 0; //转弯次数int min_rotation = 100000; //最少转弯次数int min_count = 0; //不同的最少转弯道路数bool flag = false;bool Point_check(Point pos) &#123; if (pos.x &gt; 0 &amp;&amp; pos.x &lt;= n &amp;&amp; pos.y &gt; 0 &amp;&amp; pos.y &lt;= m &amp;&amp; board[pos.x][pos.y] == 0) return true; return false;&#125;// 更新当前最少转弯情况下的路线void upgrade() &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) best[i][j] = board[i][j]; flag = true;&#125;// 回溯算法---&gt;形式参数表示的是traceBack的层数void traceBack(int depth, Point pos, int di) &#123; /* 回溯法的终止条件， 当把所有的空房间都遍历一遍 且当前到达的位置是朱丽叶的位置 且当前转弯的次数少于等于历史的次数 */ if (depth == m * n - k &amp;&amp; pos.x == ye.x &amp;&amp; pos.y == ye.y &amp;&amp; curr_rotation &lt;= min_rotation) &#123; /* 如果当前的curr_count小于min_rotation更新min_rotation、min_count以及路径图 */ if (curr_rotation &lt; min_rotation) &#123;//有更少的转向 min_rotation = curr_rotation; min_count = 1;//重新计数 // 更新路径图 upgrade(); &#125; else &#123; min_count++; &#125; return; &#125; else &#123; // 剪枝策略-----当到达这个位置的时候curr_rotation已经大于min_rotation那么进行剪枝 for (int i = 0; i &lt; 8; i++) &#123; // 通过走的方向，计算下一个位置 Point next_pos; next_pos.x = pos.x + dx[i]; next_pos.y = pos.y + dy[i]; // 每次走一步需要判断你下一个地点的位置是否合法 if (Point_check(next_pos)) &#123; board[next_pos.x][next_pos.y] = depth + 1; if (depth &gt; 1 &amp;&amp; di != i) curr_rotation++; if (curr_rotation &lt;= min_rotation) traceBack(depth + 1, next_pos, i); // 进行回溯 board[next_pos.x][next_pos.y] = 0; if (depth &gt; 1 &amp;&amp; di != i) curr_rotation--; &#125; &#125; &#125;&#125;int main() &#123; // 迷宫的初始化 memset(board, 0, sizeof(board)); memset(best,0,sizeof(board)); // 文件的输入 ifstream datain(&quot;input.txt&quot;); cout &lt;&lt; &quot;输入迷宫的宽度：&quot;; datain &gt;&gt; n; cout &lt;&lt; n&lt;&lt;endl; cout &lt;&lt; &quot;\\n输入迷宫的长度：&quot;; datain &gt;&gt; m; cout &lt;&lt; m &lt;&lt; endl; cout &lt;&lt; &quot;\\n输入封闭房间个数：&quot;; datain &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl; // 封闭房间数据的输入 Point forbidden_rooms; for (int i = 0; i &lt; k; i++) &#123; datain &gt;&gt; forbidden_rooms.x &gt;&gt; forbidden_rooms.y; board[forbidden_rooms.x][forbidden_rooms.y] = -1; &#125; // 输入罗密欧和朱丽叶的位置信息 datain &gt;&gt; luo.x &gt;&gt; luo.y; cout &lt;&lt; endl &lt;&lt; &quot;罗密欧位置坐标：[&quot; &lt;&lt; luo.x &lt;&lt; &quot;, &quot; &lt;&lt; luo.y &lt;&lt; &quot;]&quot; &lt;&lt; endl; board[luo.x][luo.y] = 1;//起始位置 datain &gt;&gt; ye.x &gt;&gt; ye.y; cout &lt;&lt; endl &lt;&lt; &quot;朱丽叶位置坐标：[&quot; &lt;&lt; ye.x &lt;&lt; &quot;, &quot; &lt;&lt; ye.y &lt;&lt; &quot;]&quot; &lt;&lt; endl; // 回溯算法开始 traceBack(1, luo, 0); // 把结果输出到txt文件中 ofstream dataout(&quot;output_data1.txt&quot;, ios::trunc); if (flag) &#123; cout &lt;&lt; &quot;\\n最小转弯次数：&quot; &lt;&lt; min_rotation &lt;&lt; endl; cout &lt;&lt; &quot;\\n最小转弯次数的转弯道路数：&quot; &lt;&lt; min_count &lt;&lt; endl; cout &lt;&lt; &quot;行走的路线图：&quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; best[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; board[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; cout&lt;&lt; &quot;\\nNo Solution!&quot; &lt;&lt; endl; &#125; return 0;&#125; 5-13 工作分配问题 由于每个工作仅由一人完成，每个人仅做一个工作，对于示例的输入矩阵，所求即为在每一行取一个数，且保证所取数不在同一列，求他们的和最小值，易知如果用暴力解法，设矩阵的行数为n，则解为n个数的排列组合，其中第i个数表示第i个工作分配给第j个人，则对于上述输入矩阵，可以得到可行解（3,2,1），（2,1,3），…… 1. 解空间和解结构对于n个工作的工作分配问题，其解空间即为1~n的全排列，解结构为排列树，具体而言树的第i层表示第i个工作的分配，每层的顶点表示该工作分配的人，如红色方框框出的节点即表示第1个工作分配给C1 2. 剪枝策略在搜索的过程中记录当前费用cv和最优费用bestv,若cv大于等于bestv，则无需再遍历该节点的子树（因为向下搜索的过程费用一定是单调递增的） 3. 示例分成两幅图来画了，实际上是一幅图 4. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;const int N=10010;int num;int Min=INT_MAX;int arr[N][N];int sum=0;int state[N];void dfs(int t)//从第t层开始搜索&#123; if(t&gt;=num) //已经到达叶子节点，继续判断是否找到了最小总费用 &#123; if(Min&gt;sum)//若当前费用小于最优费用 &#123; Min=sum;//更新最优费用 return; &#125; &#125; for(int i=0;i&lt;num;i++)//搜索过程:将作业t进行分配 &#123; if(!state[i])//若第i个人当前无作业 &#123; state[i]=1;//将任务t分配给第i个人 sum+=arr[t][i];//更新当前费用 if(sum&lt;Min) dfs(t+1);//若当前费用小于最优费用,则继续向下搜索 state[i]=0;//回溯,恢复原状态 sum-=arr[t][i];//将当前费用恢复 &#125; &#125;&#125;int main()&#123; ifstream in; ofstream out; in.open(&quot;input.txt&quot;); out.open(&quot;output.txt&quot;); in&gt;&gt;num; Min=INT_MAX; sum=0; for(int i=0;i&lt;num;i++) &#123; for(int j=0;j&lt;num;j++) &#123; in&gt;&gt;arr[i][j]; &#125; state[i]=0; &#125; dfs(0); cout&lt;&lt;&quot;最小费用为：&quot;&lt;&lt;Min&lt;&lt;endl; out&lt;&lt;&quot;最小费用为：&quot;&lt;&lt;Min&lt;&lt;endl; in.close(); out.close(); return 0;&#125; 5. 时间复杂度考虑最坏情况，对于非叶子节点，其搜索所需时间为$O(n)$，对于叶子节点，其搜索所需时间为$O(1)$，故对于n个工作的工作分配问题，其时间消耗$T=n(n+nn-1+…+n!)+n!=O(n!*n)$ 5-14 布线问题 经典排列树，然后剪枝策略可以维护一个当前最优解的成本，若当前成本大于等于该变量，则剪去该分支。 12332 33 1. 解空间和解结构对于n个元件的布线问题，其解空间为1~n的全排列，解结构为排列树 2. 剪枝策略维护当前最优解的成本bestv和当前费用cv，在考虑线路板t位置上是否放置元件i时，若当前费用加上放置元件i所带来的成本小于当前最优解的成本，则可继续搜索，否则剪去该分支 3. 示例 4. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N=25;int n;int conn[N][N];int bestx[N];int bestv=INT_MAX;int cv;int cx[N];int currentvalue(int cx[],int t)//计算cx第t位带来的成本&#123; int res=0; for(int i=0;i&lt;t;i++)//t是从0开始的 &#123; res=res+conn[cx[i]][cx[t]]*(t-i);//cx从0开始 &#125; return res;&#125;void traceback(int t)&#123; if(t==n)//到达叶子节点 &#123; if(cv&lt;bestv) &#123; for(int i=0;i&lt;n;i++) &#123; bestx[i]=cx[i]; &#125; bestv=cv; &#125; return; &#125; for(int i=t;i&lt;n;i++)//cx从0开始 &#123; swap(cx[t],cx[i]); int value=currentvalue(cx,t);//计算t这一位带来的成本 if(value+cv&lt;bestv)//满足限界条件 &#123; cv+=value; traceback(t+1); cv-=value; &#125; swap(cx[t],cx[i]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; cin&gt;&gt;conn[i][j];//构造领接矩阵 conn[j][i]=conn[i][j];//补全另一半 &#125; &#125; for(int i=0;i&lt;n;i++) cx[i]=i+1;//当前解,先初始化为123... traceback(0); cout&lt;&lt;bestv&lt;&lt;endl; for(int i=0;i&lt;n;i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; return 0;&#125; 5. 时间复杂度考虑最坏情况，对于n个元件的布线问题，对于非叶子节点，其消耗的时间与其层数t有关，为$O(n-t)$,对于叶子节点，其消耗的时间为$O(n)$，故该问题时间消耗为:$T=nn+n(n-1)(n-1)+n(n-1)(n-2)(n-2)+…+n!+n!n=O(n!n)$ 5-15 最佳调度问题可以一一为每个任务分配工作，每个任务都可以尝试分配给每台机器，从而对排列树进行搜索。用一个数组存储每台机器已经分配的任务的总耗时，搜索到可行解后这个数组中的最大值即为当前解所需时间，在剪枝的过程中，将更新后该数组的值（即表示选择分配给该机器）与当前最优解的耗时比较，若小于则可继续搜索。 1. 解空间和解结构对于n个任务k台机器的最佳调度问题，其解空间为长度为n的向量，向量的每一项为1~k，解结构为排列树 2. 剪枝策略按照题意，要求完成全部任务的时间最早，故维护变量mintime表示当前最优解的完成时间，数组ans存储每台机器完成当前任务后的时间，在任务分配过程中，尝试将任务i分配给机器j，若t[i]+ans[j]&gt;=mintime，则将该分支剪去，无需再搜索 3. 代码127 32 14 4 16 6 5 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,k,t[99],ans[99],min_time=0x3f3f3f3f;//ans[i]表示第i个机器运行完其上任务后的时间//t[i]表示第i个任务需要的时间void dfs(int level)&#123; if(level==n) &#123; int tmp=*max_element(ans,ans+n);//max_element找数组的最大值 if(tmp&lt;min_time) min_time=tmp; return; &#125; for(int i=0;i&lt;k;i++)//尝试分配给第i台机器 &#123; ans[i]+=t[level]; if(ans[i]&lt;min_time) dfs(level+1); ans[i]-=t[level]; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;t[i]; dfs(0); cout&lt;&lt;min_time&lt;&lt;endl;&#125; 4. 时间复杂度考虑最坏情况，对于非叶子节点，其时间消耗为$O(k)$，对于叶子节点，其时间消耗为$O(n)$，故对于n个任务k台机器的最佳调度问题，其时间消耗为$T=k(k+k^2+…+k^{n-1})+nk^n=O(n*k^n)$ 5-16 无优先级运算问题 有点类似于整数变换问题，这里也是不知道树的层数，可以从1个数，2个数，…,n个数逐步增加树的层数，在选择数的时候，只能使用未选过的数，以此作为剪枝策略（可以用过数组记录某个数是否选过），使用数组记录该数右侧的运算符，每种符号的选择均作为分支向下搜索，当到达叶子节点时，检查当前运算结果是否为m，若为m，则不继续搜索，程序结束 1. 解空间和解结构对于n个正整数的无优先级运算问题，其解空间为长度为2k-1(k从1到n)的向量，该向量的每一个奇数项为1~n的数且相互之间不重复，偶数项为1、2、3、4，分别表示+,-,*,\\，解的结构为排列树，具体而言如下所示： 2. 剪枝策略维护数组flag表示n个数是否使用，flag[i]=1表示第i个数已经使用，当给第dep位数选择数时，若该数已经使用过，则无法选择，剪去该分支 3. 代码125 255 2 3 6 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;int a[N];//存储题目所给n个数int num[N];//存储当前解int oper[N];//num[i] oper[i] num[i+1]int flag[N];//存储i个数的状态，是否使用int k;//表示使用的数的个数bool found()&#123;//判断是否找到解 int x=num[0]; for(int i=0;i&lt;k;i++) &#123; switch(oper[i])&#123; case 0:x+=num[i+1]; break; case 1:x-=num[i+1]; break; case 2:x*=num[i+1]; break; case 3:x/=num[i+1]; break; &#125; &#125; return (x==m);&#125;bool traceback(int dep)//考虑第dep个数&#123; if(dep&gt;k)&#123; if(found()) return true; else return false; &#125; for(int i=0;i&lt;n;i++)//第dep个数尝试选择数i &#123; if(flag[i]==0) &#123; num[dep]=a[i]; flag[i]=1; for(int j=0;j&lt;4;j++)//选择该数右边的符号 &#123; oper[dep]=j; if(traceback(dep+1)) return true; &#125; flag[i]=0; &#125; &#125; return false;&#125;void out()//输出函数&#123; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;num[i]; switch(oper[i])&#123; case 0:cout&lt;&lt;&quot;+&quot;;break; case 1:cout&lt;&lt;&quot;-&quot;;break; case 2:cout&lt;&lt;&quot;*&quot;;break; case 3:cout&lt;&lt;&quot;/&quot;;break; &#125; &#125; cout&lt;&lt;num[k]; return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; flag[i]=0; &#125; for(k=1;k&lt;=n;k++) &#123; if(traceback(0)) &#123; cout&lt;&lt;k&lt;&lt;endl; out(); return 0; &#125; &#125; cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 4. 时间复杂度考虑最坏情况，需要n个数，每个非叶子节点的时间消耗为$O(n)$，每个叶子节点的时间消耗为$O(n)$，此时时间消耗为$T=n(1+n+4n+4n^2+4^2n^2+…+4^{n-1}n^{n})=O(n^nn4^{n-1})$，真的很大。。。 5-17 世界名画陈列馆问题 input: 14 4 output: 123454 0 0 1 01 0 0 00 0 0 10 1 0 0 这题的思路参考了书的答案，他的剪枝策略有点复杂 1. 解空间和解结构解空间为长度为n*m的向量，向量的每一项为0或者1，表示是否放置警卫，解结构为子集树 2. 剪枝策略 可以证明,当前访问的格点(i,j)已被监视时,放置在(i,j)的情况一定不会比放置在(i+1,j+1)的情况好.当(i+1,j+1)不在网格中时,(i+1,j)和(i,j+1)同理.所以,如果(i,j)已被监视,则不需要在此处放置机器人,直接跳过即可.（update,证明：因为是从上到下从左到右使得格子进入监视状态，当前正在检查访问(i,j)。说明在这之前的(i-1,j)和(i,j-1)已被监视。此时如果放在(i,j)处，只会使得(i+1,j)和(i,j+1)进入访问状态。而如果放在(i+1,j+1)处，显然在完成上述目标的情况下可以使更多格子进入访问状态） 当(i,j)未被监视时,若(i,j+1)已被监视,则在(i,j)放置一定不会比在(i+1,j)放置的情况好.所以当且仅当(i,j)在网格右下角或者(I,j+1)未被监视时才考虑放置在(i,j)的情况. 当(i,j)未被监视时,若(i,j+1)和(i,j+2)均被监视,则在(i+1,j)放置一定不会比在(i+1,j)放置的情况好,所以当且仅当(i,j+1)或(i,j+2)未被监视时才考虑放置在(i,j+1)的情况. 当i=n时,不考虑放置在(i+1,j)的情况. 记录已经监视的格点数,(当前最优值减去当前已放置个数)*5如果小于未监视的格点数,则一定达不到比当前最优值更好的情况,剪去. 类似于(5),考虑更紧的情况,并非每个机器人都能独立监视5个格点,至少会有m/4+5的冗余,这个剪枝仅适用于i&lt;n-1的情况,因为最后两行由于最优值和已放置个数非常接近,总是达不到这个值. 大概就是分为下界剪枝法和控制剪枝法两种，下界剪枝法就是计算剩余需要的警卫数，然后加上当前警卫数和当前最优解警卫数比较，控制剪枝法就是一堆已经证明的放置策略，如2、3、4, 3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int d[6][3]=&#123;&#123;0,0,0&#125;,&#123;0,0,0&#125;,&#123;0,0,-1&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,1,0&#125;&#125;;//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下int x[N][N];//当前的放置策略int y[N][N];//是否受监视int bestx[N][N];//最优放置策略int n,m,best,k=0,t=0,t1,t2,more;//k为当前警卫数量//t为当前受监视的位置的个数bool p;void place(int i,int j)//在(i,j)处放置警卫,改变相邻位置的监视情况&#123; x[i][j]=1; k++; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]++; if(y[p][q]==1) t++; &#125;&#125;void noplace(int i,int j)//用于撤销在(i,j)上放置的警卫&#123; x[i][j]=0; k--; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]--; if(y[p][q]==0) t--; &#125;&#125;void traceback(int i,int j)&#123; do&#123; j++; if(j&gt;m)&#123; i++; j=1; &#125; &#125;while(!(y[i][j]==0||i&gt;n)); //若当前坐标未受监视或全部坐标都受到监视跳出循环 if(i&gt;n)&#123; if(k&lt;best)&#123; best=k; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[i][j]=x[i][j]; &#125; &#125; &#125; return; &#125; if(k+(t1-t)/5&gt;=best)//利用k和t估计警卫下界, return; if((i&lt;n-1)&amp;&amp;(k+(t2-t)/5)&gt;=best)//也是利用k和t估计下界 return; if(i&lt;n)&#123;//下侧放警卫 place(i+1,j); traceback(i,j); noplace(i+1,j); &#125; if(j&lt;m&amp;&amp;(y[i][j+1]==0||y[i][j+2]==0))&#123; place(i,j+1);//在右侧放警卫 traceback(i,j); noplace(i,j+1); &#125; if((y[i+1][j]==0&amp;&amp;y[i][j+1]==0)) &#123; place(i,j);//在本身放警卫 traceback(i,j); noplace(i,j); &#125;&#125;void output()&#123; cout&lt;&lt;best&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;bestx[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;void solve()&#123; //下界剪枝法的辅助，主要是用来辅助通过t和k估计警卫人数的下界的 more=m/4+1; if(m%4==3) more++; else if(m%4==2) more+=2; t2=m*n+more+4; t1=m*n+4; //下面就很好看懂了 best=INT_MAX; memset(y,0,sizeof(y)); memset(x,0,sizeof(x)); if(n==1&amp;&amp;m==1) &#123; cout&lt;&lt;1&lt;&lt;endl&lt;&lt;1&lt;&lt;endl; return; &#125; //构造边界 for(int i=0;i&lt;=m+1;i++) &#123; y[0][i]=1; y[n+1][i]=1; &#125; for(int i=0;i&lt;=n+1;i++) &#123; y[i][0]=1; y[i][m+1]=1; &#125; traceback(1,0); output();&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n; solve(); return 0;&#125; 5-18 世界名画陈列馆问题（不重复监视） 在5-17上改了下，框架没变，去掉了答案那些控制剪枝法的剪枝策略，加上了题目中要求的不重复监视的剪枝策略，且在叶子节点处加上了对整个矩阵检查是否全部监视了，主要加了check函数，checkall函数，改了traceback函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int d[6][3]=&#123;&#123;0,0,0&#125;,&#123;0,0,0&#125;,&#123;0,0,-1&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,1,0&#125;&#125;;//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下int x[N][N];//当前的放置策略int y[N][N];//是否受监视int bestx[N][N];//最优放置策略int n,m,best,k=0,t=0,t1,t2,more;//k为当前警卫数量//t为当前受监视的位置的个数bool p;void place(int i,int j)//在(i,j)处放置警卫,改变相邻位置的监视情况&#123; x[i][j]=1; k++; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]++; if(y[p][q]==1) t++; &#125;&#125;bool check(int i,int j)//检查(i,j)是否能放置警卫&#123; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; if(y[p][q]) &#123; return false; &#125; &#125; return true;&#125;bool checkall()//检查是否全部都有警卫&#123; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(!y[i][j]) return false; &#125; &#125; return true;&#125;void noplace(int i,int j)//用于撤销在(i,j)上放置的警卫&#123; x[i][j]=0; k--; for(int s=1;s&lt;=5;s++) &#123; int p=i+d[s][1]; int q=j+d[s][2]; y[p][q]--; if(y[p][q]==0) t--; &#125;&#125;void traceback(int i,int j)&#123; do&#123; j++; if(j&gt;m)&#123; i++; j=1; &#125; &#125;while(!(y[i][j]==0||i&gt;n)); //若当前坐标未受监视或全部坐标都受到监视跳出循环 if(i&gt;n)&#123; if(k&lt;best&amp;&amp;checkall())&#123; best=k; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[i][j]=x[i][j]; &#125; &#125; &#125; return; &#125; if(k+(t1-t)/5&gt;=best)//利用k和t估计警卫下界, return; if((i&lt;n-1)&amp;&amp;(k+(t2-t)/5)&gt;=best)//也是利用k和t估计下界 return; if(check(i,j)) &#123; place(i,j); traceback(i,j); noplace(i,j); &#125; traceback(i,j);&#125;void output()&#123; cout&lt;&lt;best&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;bestx[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;void solve()&#123; more=m/4+1; if(m%4==3) more++; else if(m%4==2) more+=2; t2=m*n+more+4; t1=m*n+4; //下面就很好看懂了 best=INT_MAX; memset(y,0,sizeof(y)); memset(x,0,sizeof(x)); if(n==1&amp;&amp;m==1) &#123; cout&lt;&lt;1&lt;&lt;endl&lt;&lt;1&lt;&lt;endl; return; &#125; traceback(1,0); output();&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n; solve(); return 0;&#125; 5-19 算m点问题 类似于5-16，但是这里一定用到了k个整数，所以只需要稍微改改(把k设置为n-1然后改输出)，而且这种计算方式可以看成是无优先级的 示例应该给错了，应该是下面这样： 125 1257 2 2 12 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;int a[N];//存储题目所给n个数int num[N];//存储当前解int oper[N];//num[i] oper[i] num[i+1]int flag[N];//存储i个数的状态，是否使用int k;//表示使用的数的个数bool found()&#123;//判断是否找到解 int x=num[0]; for(int i=0;i&lt;k;i++) &#123; switch(oper[i])&#123; case 0:x+=num[i+1]; break; case 1:x-=num[i+1]; break; case 2:x*=num[i+1]; break; case 3:x/=num[i+1]; break; &#125; &#125; return (x==m);&#125;bool traceback(int dep)//考虑第dep个数&#123; if(dep&gt;k)&#123; if(found()) return true; else return false; &#125; for(int i=0;i&lt;n;i++)//第dep个数尝试选择数i &#123; if(flag[i]==0) &#123; num[dep]=a[i]; flag[i]=1; for(int j=0;j&lt;4;j++)//选择该数右边的符号 &#123; oper[dep]=j; if(traceback(dep+1)) return true; &#125; flag[i]=0; &#125; &#125; return false;&#125;void out()//输出函数&#123; int ans=num[0]; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;ans; switch(oper[i])&#123; case 0:cout&lt;&lt;&quot;+&quot;;ans+=num[i+1];break; case 1:cout&lt;&lt;&quot;-&quot;;ans-=num[i+1];break; case 2:cout&lt;&lt;&quot;*&quot;;ans*=num[i+1];break; case 3:cout&lt;&lt;&quot;/&quot;;ans/=num[i+1];break; &#125; cout&lt;&lt;num[i+1]&lt;&lt;&quot;=&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;; &#125; return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; flag[i]=0; &#125; k=n-1; if(traceback(0)) &#123; out(); return 0; &#125; cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; return 0;&#125; 5-20 部落卫队问题 类似于0-1背包问题，子集树，左子树为1，右子树为0,约束函数就是不能和当前卫队里已有的居民为仇敌，若为仇敌，则剪去左子树。限界函数是当前卫队里的人数加上除去当前考虑的居民的剩余的居民，若数量还是比best小，则剪去右子树 1. 解空间和解结构对于n个居民的部落卫队问题，其解空间为长度为n的向量，向量的每一项为0或者1，解结构为子集树 2. 剪枝策略考虑居民t是否加入卫队，加入卫队即进入左子树，否则进入右子树 约束函数：若居民t和1~t-1中已经加入卫队的居民直接有仇视关系，则t不能加入卫队，剪去左子树 限界函数：若居民t不加入卫队，维护变量cv为当前卫队中居民人数，则卫队未来可能的最多人数为cv+n-t，若该值大于n，才搜索右子树，否则剪去右子树 3. 代码input： 12345678910117 101 21 42 42 32 52 63 53 64 55 6 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;const int N=100;int n,m;//n个居民,m个关系int relation[N][N];//居民关系,0表示正常，1表示仇视,从1开始的int cbest=0;//最多的卫兵int bestx[N];//存储最优解int cv=0;//当前卫兵人数int x[N];//当前解,x[i]=1表示第i个居民是卫兵void traceback(int t)//第t个居民是否作为卫兵&#123; if(t==n)//到达叶子节点 &#123; if(cv&gt;cbest) &#123; for(int i=0;i&lt;n;i++) &#123; bestx[i]=x[i]; cbest=cv; &#125; &#125; return; &#125; bool flag=true;//判断是否有冲突 for(int i=0;i&lt;t;i++) &#123; if(x[i]==1&amp;&amp;relation[t+1][i+1]==1) &#123; flag=false; break; &#125; &#125; if(flag)//考虑是否进入左子树 &#123; x[t]=1; cv++; traceback(t+1); x[t]=0; cv--; &#125; if(cv+n-t&gt;cbest)//考虑是否进入右子树 &#123; traceback(t+1); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int t1,t2; for(int i=0;i&lt;m;i++)//构造领接矩阵 &#123; cin&gt;&gt;t1&gt;&gt;t2; relation[t1][t2]=1; relation[t2][t1]=1; &#125; traceback(0);//从第0个居民开始考虑 cout&lt;&lt;cbest&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 4. 时间复杂度考虑最坏情况，对于非叶子节点，搜索所需时间为$O(t+1)$，其中t为当前的层数，对于叶子节点，其搜索所需时间为$O(n)$，故居民数量为n的部落卫队问题的时间复杂度为$O(n*2^n)$ 5-21、5-22装载问题和0-1背包问题，见书上例题~ 5-23 圆排列问题 排列树，在选择一个圆的时候，就能计算他带来的长度（需要单独考虑第一个和最后一个的半径带来的长度），维护当前最优解，若当前解小于最优解才继续搜索，看看代码大概就能懂啦（突然发现书上有这道例题，也可以看看书上的） 1231 1 2 1. 解空间和解结构n个圆的圆排列问题的解空间为1~n的全排列，解结构为排列树 2. 剪枝策略维护变量minlen表示当前最优解的长度，clen表示当前长度，当考虑放置第t个圆时，计算其带来的长度l，若l+clen&gt;=minlen，则剪去该子树 3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100;int n;double r[N];double minlen=DBL_MAX;double clen=0;int x[N];//当前的排列double bring(int t)&#123; if(t==0) return r[x[t]];//第一个就是半径 else&#123;//加上t和t-1位置上圆心的x之间的距离 double res=0; res=sqrt((r[x[t]]+r[x[t-1]])*(r[x[t]]+r[x[t-1]])-abs(r[x[t]]-r[x[t-1]])*abs(r[x[t]]-r[x[t-1]])); if(t==n-1) res+=r[x[t]];//最后一个还要加半径 return res; &#125;&#125;void traceback(int t)//考虑放置的第t个圆&#123; if(t==n)//叶节点，更新min &#123; if(clen&lt;minlen) minlen=clen; return; &#125; for(int i=t;i&lt;n;i++)//考虑将未使用的圆放在t位置 &#123; swap(x[t],x[i]); double ctmp=clen; if(clen+bring(t)&lt;minlen)//当前长度小于最优解长度 &#123; clen=clen+bring(t); traceback(t+1); clen=ctmp; &#125; swap(x[t],x[i]);t &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;r[i]; x[i]=i; &#125; traceback(0); cout&lt;&lt;minlen; return 0;&#125; 4. 时间复杂度考虑最坏情况，对于非叶子节点，搜索所需时间为$O(n-t)$，t为叶子节点的层数，对于叶子节点，搜索所需时间为$O(1)$，故n个圆的圆排列问题的最坏情况下时间复杂度为$O(n!)$ 5-24图着色问题，见书上例题~ 5-25 最短加法链问题 类似于整数变换那题，也是树的层数未知，所以可以用变量控制层数慢慢加大，可以采用无优先级运算问题的类似框架去解这道题，不同的是这题随着层数的加大分支数也加大了，剪枝策略是当前考虑的项不能大于23，看看代码就差不多~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int N=100;int n;//需要得到的数int x[N];//加法链数组int k;//控制层数bool traceback(int t)//考虑加法链的第t项&#123; if(t==k) &#123; if(x[k-1]==n) return true; else return false; &#125; //选择加法链中的两个相加得到第t项 for(int i=0;i&lt;t;i++) &#123; for(int j=0;j&lt;t;j++) &#123; if(x[i]+x[j]&lt;=n)//剪枝，该项要小于等于n &#123; x[t]=x[i]+x[j]; if(traceback(t+1)) &#123; return true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n; x[0]=1; for(k=1;k&lt;=n;k++)//最多n层 &#123; if(traceback(1))//这里得是1,因为如果是0会直接返回false &#123; cout&lt;&lt;k-1&lt;&lt;endl; for(int i=0;i&lt;k;i++) &#123; cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;; &#125; return 0; &#125; &#125; return 0;&#125; 完结撒花🎉~","categories":[],"tags":[]},{"title":"algorithm","slug":"algorithm","date":"2022-12-14T14:09:57.000Z","updated":"2025-03-19T12:41:29.857Z","comments":true,"path":"2022/12/14/algorithm/","link":"","permalink":"https://leungto.github.io/2022/12/14/algorithm/","excerpt":"","text":"tips c++里面1e7和1e8的复杂度大概1s能够计算得到 10的9次方以内或者32位整数用int存放，10的18次方以内或者64位整数用long long 存放 小写字母比大写字母的ASCII大32 %d-整数；%s-字符串（字符数组），%f-浮点数，%c-char 对于四舍五入的处理：可以直接进行判断，也可以使用浮点数的round函数 自建数据结构一定要考虑初始化 C++位运算的优先级比加减乘除的优先级低，所以遇到位运算和加减乘除一起的，要加个括号。 注意要不要用long long 基础算法快速排序快速排序分治 确定分界点 q[l]，q[(l+r)/2],q[r],随机，使其值为x 调整范围 （左半边&lt;=x）（右半边&gt;=x），注意分界点不一定是x 递归处理左右两段 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N = 100010;int q[N];//分治法思想void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; //双指针 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];//取中间作为基准 while (i &lt; j) &#123; do i ++ ; while (q[i] &lt; x);//左右指针移动 do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]);//交换 &#125; quick_sort(q, l, j);//递归处理左右部分 quick_sort(q, j + 1, r);&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); return 0;&#125; python 12345678910111213141516171819202122232425262728def quick_sort(q, l, r): if l &gt;= r: return x = q[l + r &gt;&gt; 1] i = l - 1 j = r + 1 while i &lt; j: while 1: i += 1 if q[i] &gt;= x: break while 1: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j + 1, r)def main(): n = int(input()) data = [int(x) for x in input().split()] quick_sort(data, 0, n - 1) print(&quot; &quot;.join(list(map(str, data))))main() 第k个数注意这个代码左边&lt;=x, 右边&gt;=x, 但分界点不一定=x ，模拟一下3 4 2 8 9 5 7，这个代码可能和有些不一样 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int quick_sort(int q[], int l, int r, int k)//基于快排&#123; if (l &gt;= r) return q[l];//数组中只有一个数 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j)//快排按基准划分 &#123; do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; if (j - l + 1 &gt;= k) return quick_sort(q, l, j, k);//若左半部分元素个数大于等于k，搜左边 else return quick_sort(q, j + 1, r, k - (j - l + 1));//否则搜右边，更新搜索第k - (j - l + 1)个元素&#125;int main()&#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); cout &lt;&lt; quick_sort(q, 0, n - 1, k) &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930def quick_sort(q, l, r, k): if l &gt;= r: return q[l] x = q[l + r &gt;&gt; 1] i = l - 1 j = r + 1 while i &lt; j: while 1: i += 1 if q[i] &gt;= x: break while 1: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] if j - l + 1 &gt;= k: return quick_sort(q, l, j, k) else: return quick_sort(q, j + 1, r, k - (j - l + 1))def main(): n, k = list(map(int, input().split())) data = [int(x) for x in input().split()] print(quick_sort(data, 0, n - 1, k))main() 归并排序归并排序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], tmp[N];void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//分别对左右部分进行排序 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r)//进行合并 if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//合并剩余部分 while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];//重新拷贝到原数组&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); merge_sort(a, 0, n - 1); for (int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, a[i]); return 0;&#125; python：python的最后收尾有更加简单的方法 123456789101112131415161718192021222324252627282930def merge_sort(q, l, r): if l &gt;= r: return mid = l + r &gt;&gt; 1 i = l j = mid + 1 merge_sort(q, l, mid) merge_sort(q, mid + 1, r) tmp = list() while i &lt;= mid and j &lt;= r: if q[i] &lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 tmp += q[i : mid + 1] tmp += q[j : r + 1] q[l : r + 1] = tmp[:]def main(): n = int(input()) data = list(map(int, input().split())) merge_sort(data, 0, n - 1) print(&quot; &quot;.join(list(map(str, data))))main() 逆序对其实在计算的过程中可以想象，只需要给后半段的每一个值计算一个逆序对数量，如果碰到q[i]&gt;q[j]，则由于前半段已经排好序，所以i~mid都是比j要大的，j位置上的逆序对数量可以计算得到，如果q[i]&lt;=q[j],说明j位置上的逆序对需要暂缓计算（因为1~i上的值都比j小，构不成逆序对，所以j在等待一个i+k，使得q[i+k]&gt;q[j]，然后j的逆序对数量就是i+k~mid了），如果没有等到这个i+k，则说明没有逆序对值 注意边界条件&gt;=,写错了可就EML 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int a[N], tmp[N];LL merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else &#123; res += mid - i + 1; tmp[k ++ ] = q[j ++ ]; &#125; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; return res;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); cout &lt;&lt; merge_sort(a, 0, n - 1) &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627def merge_sort(q, l, r): if l &gt;= r: return 0 mid = l + r &gt;&gt; 1 i = l j = mid + 1 result = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r) tmp = list() while i &lt;= mid and j &lt;= r: if q[i] &lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 result = result + mid - i + 1 tmp += q[i : mid + 1] tmp += q[j : r + 1] q[l : r + 1] = tmp[:] return resultdef main(): n = int(input()) data = list(map(int, input().split())) print(merge_sort(data, 0, n - 1))main() 二分数的范围12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); while (m -- ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= x) r = mid; else l = mid + 1; &#125; if (q[l] != x) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;//这里lr无所谓，最后l=r else &#123; cout &lt;&lt; l &lt;&lt; &#x27; &#x27;; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125; python： 1234567891011121314151617181920212223242526272829def binary_search(q, n, k): l, r = 0, n - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if q[mid] &gt;= k: r = mid else: l = mid + 1 if q[l] != k: print(&quot;-1 -1&quot;) else: print(l, end=&quot; &quot;) l, r = 0, n - 1 while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if q[mid] &lt;= k: l = mid else: r = mid - 1 print(l)def main(): n, m = list(map(int, input().split())) data = list(map(int, input().split())) for i in range(m): k = int(input()) binary_search(data, n, k)main() 整数二分总结整数二分法：有单调性可以二分，无单调性也可能可以。主要是否存在一种性质能把区间分成两半——边界 二分可以求这个划分的边界，存在左半部分的右边界和右半部分的左边界，有两套模板，选择的时候判断性质把mid放在left还是right上 二分每次都覆盖最终的结果，最后只剩一个数的时候就是结果 二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 版本1当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。 12345678910int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 版本2当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。 12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1;//需要加一，否则可能出现死循环 if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 假设有一个总区间，经由我们的 check 函数判断后，可分成两部分，这边以o作 true，…..作 false 示意较好识别 如果我们的目标是下面这个v，那麽就必须使用模板 1 …………….vooooooooo 假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用模板 2 oooooooov………………. 所以下次可以观察 check 属性再与模板1 or 2 互相搭配就不会写错啦 数的三次方根1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -100, r = 100;//边界的选择 while (r - l &gt; 1e-8)//注意对浮点数的处理 &#123; double mid = (l + r) / 2; if (mid * mid * mid &gt;= x) r = mid;//类似于整数二分 else l = mid; &#125; printf(&quot;%.6lf\\n&quot;, l);//注意浮点保留小数位 return 0;&#125; (c语言printf()输出格式大全_printf输出格式_rusty_knife的博客-CSDN博客 double输出为%lf python python print（）函数控制输出格式_python 打印格式格式-CSDN博客 123456789101112131415def binary_search(x): l = -10000 r = 10000 while r - l &gt;= 1e-8: mid = (l+r)/2.0 if mid**3 &gt;= x: r = mid else: l = mid return ldef main(): x = float(input()) result = binary_search(x) print(&quot;&#123;:.6f&#125;&quot;.format(result))main() 浮点二分总结浮点二分是类似于整数二分的，且其无需考虑+1-1的，需要注意： while的条件，r-l&gt;精度*10^-2^，比如题目要求精度是-6次，r-l&gt;1e-8 r和l直接取边界值即可 高精度 tips： 注意处理进位，包括最高位的进位 借位的处理，借位不是t/10，而是正负判定赋值 注意是否需要处理前导0,注意乘法是不是可以乘以0 string的存储：”12345” 0 1 2 3 4 1 2 3 4 5 高精度加法 存储时使用数组存储（可用vector），从个位开始存储，如数12345，在数组里的存储方式为：（为了方便加法） 数组的第X位 0 1 2 3 4 存储的数字 5 4 3 2 1 运算的方法：模拟人工加法，每一位的结果等于两个数该位的结果加上低位的进位 不压位代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if (A.size() &lt; B.size()) return add(B, A);//让A总是更长 vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(t); //注意处理最后的进位 return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); auto C = add(A, B); for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; return 0;&#125; 压位代码 压位能减小所需空间，高精度加法可以压9位，乘法可以压4位，压9位就是数组的一位表示原数的9位（int范围的限制） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int base = 1000000000;//压9位，加法进位的时候是需要余basevector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % base); t /= base; &#125; if (t) C.push_back(t); return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1, s = 0, j = 0, t = 1; i &gt;= 0; i -- ) &#123;//s记录当前位数字，j为当前压了几位，t为辅助乘数量级 s += (a[i] - &#x27;0&#x27;) * t; j ++, t *= 10; if (j == 9 || i == 0) &#123; A.push_back(s); s = j = 0; t = 1; &#125; &#125; for (int i = b.size() - 1, s = 0, j = 0, t = 1; i &gt;= 0; i -- ) &#123; s += (b[i] - &#x27;0&#x27;) * t; j ++, t *= 10; if (j == 9 || i == 0) &#123; B.push_back(s); s = j = 0; t = 1; &#125; &#125; auto C = add(A, B); cout &lt;&lt; C.back();//单独输出最高位(因为无需补高位0) for (int i = C.size() - 2; i &gt;= 0; i -- ) printf(&quot;%09d&quot;, C[i]);//需要补高位0，限制在9位 cout &lt;&lt; endl; return 0;&#125; 虽然python自带大整数计算，但是还是模拟一下算法思想： 12345678910111213141516171819202122232425def add(A,B): if len(A)&lt;len(B): return add(B,A) t = 0 result = [] for i in range(len(A)): t += A[i] if i &lt; len(B): t += B[i] result.append(t%10) t = t // 10 if t : result.append(t) return result def main(): A = list(map(int,list(input()))) B = list(map(int,list(input()))) A.reverse() B.reverse() C = add(A,B) C.reverse() print(&#x27;&#x27;.join(list(map(str,C)))) main() 高精度减法 需要首先保证sub(A,B)中有A&gt;=B 然后逐位作差，注意借位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//判断是否有 A&gt;=B&#123; if (A.size() != B.size()) return A.size() &gt; B.size();//首先判断位数 for (int i = A.size() - 1; i &gt;= 0; i -- )//然后从高位起开始判断 if (A[i] != B[i]) return A[i] &gt; B[i]; return true;//若相等，也返回true&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//作差，此时已经保证A &gt;= B&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ )//t表示借位 &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导0 return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for (int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); vector&lt;int&gt; C; if (cmp(A, B)) C = sub(A, B); else C = sub(B, A), cout &lt;&lt; &#x27;-&#x27;;//注意对符号的判断 for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; return 0;&#125; python 1234567891011121314151617181920212223242526272829303132333435363738def cmp(A, B): if len(A) != len(B): return len(A) &gt; len(B) for i in range(len(A) - 1, -1, -1): if A[i] != B[i]: return A[i] &gt; B[i] return Truedef sub(A, B): t = 0 result = [] for i in range(len(A)): t = A[i] - t if i &lt; len(B): t -= B[i] result.append((t + 10) % 10) if t &lt; 0: t = 1 else: t = 0 while len(result) &gt; 1 and result[-1] == 0: result.pop() return resultdef main(): A = list(map(int, input())) B = list(map(int, input())) A.reverse() B.reverse() if cmp(A, B): C = sub(A, B) else: print(&quot;-&quot;, end=&quot;&quot;) C = sub(B, A) C.reverse() print(&quot;&quot;.join(map(str, C)))main() 高精度乘法 首先注意进位的处理，类似加法 其次注意处理前导0 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ )//处理进位，||t &#123; if (i &lt; A.size()) t += A[i] * b;//A的每一位 C.push_back(t % 10); t /= 10;//进位 &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//b为0，前导0 return C;&#125;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); return 0;&#125; 上面这种方法不太好记忆，也可以采用下面这种： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;vector&lt;int&gt; dot(vector&lt;int&gt;&amp;A,int b)&#123; int t=0; vector&lt;int&gt; res; for(int i=0;i&lt;A.size();i++) &#123; t+=A[i]*b; res.push_back(t%10); t=t/10; &#125; while(t)//处理余下的进位 &#123; res.push_back(t%10); t=t/10; &#125; while(res.back()==0&amp;&amp;res.size()&gt;1) res.pop_back();//处理乘以0后的前导0 return res;&#125;int main()&#123; string a; int b; cin&gt;&gt;a&gt;&gt;b; vector&lt;int&gt;A,C; for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#x27;0&#x27;); C=dot(A,b); for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i]; return 0;&#125; python 1234567891011121314151617181920212223def mul(A, b): t = 0 result = [] for i in range(len(A)): t += A[i] * b result.append(t % 10) t = t // 10 while t: result.append(t % 10) t = t // 10 while len(result) &gt; 1 and result[-1] == 0: result.pop() return resultdef main(): A = list(map(int, input())) b = int(input()) A.reverse() C = mul(A, b) C.reverse() print(&quot;&quot;.join(map(str, C)))main() 高精度除法 类似于人做除法，从高位开始除，注意对余数的处理 除完后得到的是从0开始高位——低位的格式，进行反转 处理前导0 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a; vector&lt;int&gt; A; int B; cin &gt;&gt; a &gt;&gt; B; for (int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); int r; auto C = div(A, B, r); for (int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021def div(A, B): r = 0 result = [] for i in range(len(A) - 1, -1, -1): r = r * 10 + A[i] result.append(r // B) r %= B result.reverse() while len(result) &gt; 1 and result[-1] == 0: result.pop() return result, rdef main(): A = list(map(int, input())) B = int(input()) C, r = div(A, B) C.reverse() print(&quot;&quot;.join(map(str, C))) print(r)main() 前缀和和差分一维前缀和 $S_i=a_1+a_2+…+a_i$ $sum(l,r)=S_r-S_{l-1}$ 为了能统一格式，输入可以从1开始，然后s[i] = s[i - 1] + a[i]这一操作就也可以从1开始了 12345678910111213141516171819202122232425#include &lt; iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i - 1] + a[i]; // 前缀和的初始化 while (m -- ) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); // 区间和的计算 &#125; return 0;&#125; 如果不需要原来的数组，也可以直接用a数组自己来变换 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m;int a[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; a[i]=a[i]+a[i-1]; &#125; int st,ed; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;st&gt;&gt;ed; cout&lt;&lt;a[ed]-a[st-1]&lt;&lt;endl; &#125; return 0;&#125; python 123456789101112N = 100010a = [0]*Ns = [0]*Ndef main(): n,m = map(int,input().split()) a[1:n+1] = list(map(int,input().split())) for i in range(1,n+1): s[i] = s[i-1] + a[i] for i in range(m): l,r = map(int,input().split()) print(s[r]-s[l-1])main() 二维前缀和 $S[i][j]$存储包括$a[i][j]$的左上侧元素的和 $S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]$ 查询$(x_1,y_1)$和$(x_2,y_2)$范围内元素的和（包括这两个点），$S[x_2][y_2]-S[x_2][y_1-1]-S[x_1-1][y_2]+S[x_1-1][y_1-1]$ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int s[N][N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;s[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; while (q -- ) &#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); &#125; return 0;&#125; python 12345678910111213141516N = 1010a = [[0] * N for _ in range(N)]s = [[0] * N for _ in range(N)]def main(): n, m, q = map(int, input().split()) for i in range(1, n + 1): a[i][1 : m + 1] = list(map(int, input().split())) for i in range(1, n + 1): for j in range(1, m + 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] for i in range(q): x1, y1, x2, y2 = map(int, input().split()) print(s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]) main() 一维差分 差分的核心操作是：在数组a[L:R]上全都加上c，等价于b[l]+=c,b[R+1]-=c 差分是前缀和的逆运算，即构造数组b，使得a数组是其前缀和数组 差分的数组b不需要显示计算，可以理解为a数组原本是全0，然后在a数组上插入数，即在a[i,i]上插入a[i][i] 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N];void insert(int l, int r, int c)//等价在a上的[l,r]区间的数都加上c&#123; b[l] += c; b[r + 1] -= c;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) insert(i, i, a[i]); while (m -- ) &#123; int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for (int i = 1; i &lt;= n; i ++ ) b[i] += b[i - 1]; for (int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, b[i]); return 0;&#125;/*还见过另外一种差分方法：for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];for (int i = n; i; i -- ) a[i] -= a[i - 1];*/ python 123456789101112131415161718192021N = 100010a = [0] * Nb = [0] * Ndef insert(l, r, c): b[l] += c b[r + 1] -= cdef main(): n, m = map(int, input().split()) a[1 : n + 1] = list(map(int, input().split())) for i in range(1, n + 1): insert(i, i, a[i]) for i in range(m): l, r, c = map(int, input().split()) insert(l, r, c) for i in range(1, n + 1): b[i] = b[i] + b[i - 1] print(&quot; &quot;.join(map(str, b[1 : n + 1])))main() 二维差分 核心思想：给定原矩阵a[i,j]，构造差分矩阵b[i,j]，使得a是b的前缀和 核心操作：给以(x1,y1)为左上角,(x2,y2)为右下角的子矩阵中的所有数加上c，其对于差分矩阵的影响是 S[x1,y1]+=c;S[x1,y2+1]-=c;S[x2+1,y1]-=c;S[x2+1,y2+1]+=c 同样不需要显式构造差分矩阵，借助核心操作可完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) insert(i, j, i, j, a[i][j]); while (q -- ) &#123; int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c); &#125; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; for (int i = 1; i &lt;= n; i ++ ) &#123; for (int j = 1; j &lt;= m; j ++ ) printf(&quot;%d &quot;, b[i][j]); puts(&quot;&quot;); &#125; return 0;&#125; python 123456789101112131415161718192021222324252627N = 1010a = [[0] * N for _ in range(N)]b = [[0] * N for _ in range(N)]def insert(x1, y1, x2, y2, c): b[x1][y1] += c b[x1][y2 + 1] -= c b[x2 + 1][y1] -= c b[x2 + 1][y2 + 1] += cdef main(): n, m, q = map(int, input().split()) for i in range(1, n + 1): a[i][1 : m + 1] = list(map(int, input().split())) for i in range(1, n + 1): for j in range(1, m + 1): insert(i, j, i, j, a[i][j]) for i in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(x1, y1, x2, y2, c) for i in range(1, n + 1): for j in range(1, m + 1): b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] for i in range(1, n + 1): print(&quot; &quot;.join(map(str, b[i][1 : m + 1])))main() 双指针算法 归并排序双指针指向两个数组，快排双指针指向一个数组 核心思想：将朴素的二重循环优化到$O(n)$ 写的时候首先写朴素的二重循环（先枚举终点，再枚举起点），然后考虑i,j之间的关系，是否存在单调的关系 !!!模板： 12345for(int i=0,j=0;i&lt;n;i++)&#123; while(j&lt;i&amp;&amp;check(i,j)) j++; //具体问题的逻辑&#125; 最长连续不重复子序列1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int q[N], s[N];//s用来做hash的，表示某个数的数量int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); int res = 0; for (int i = 0, j = 0; i &lt; n; i ++ )//考虑右边界为i的最长子序列 &#123; s[q[i]] ++ ;//由于左侧一定是不重复的，所以只需要考虑进入的数是否重复 while (j &lt; i &amp;&amp; s[q[i]] &gt; 1) s[q[j ++ ]] -- ;//若重复则紧缩左边界以达到去重目的 res = max(res, i - j + 1);//去重后取最大值作为输出 &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; python ：直接开数组的写法： 123456789101112131415N = 100010s = [0]*Ndef main(): n = int(input()) data = list(map(int,input().split())) res = 0 j = 0 for i in range(n): s[data[i]] += 1 while j&lt;i and s[data[i]] &gt; 1: s[data[j]] -= 1 j += 1 res = max(res, i-j+1) print(res)main() python：采用内置字典的写法 dict.fromkeys([],0) 初始化dict 1234567891011121314def main(): n = int(input()) data = list(map(int,input().split())) d = dict.fromkeys(data,0) j = 0 res = 0 for i in range(n): d[data[i]] += 1 while d[data[i]]&gt;1 and j&lt;i: d[data[j]] -= 1 j += 1 res = max(res,i-j+1) print(res)main() 数组元素的目标和考虑单调性去优化二重朴素循环 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m,x;int a[N];int b[N];int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int j=0;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;b[j]); for(int i=n-1,j=0;i&gt;=0;i--) &#123; while(j&lt;m&amp;&amp;a[i]+b[j]&lt;x) j++; if(a[i]+b[j]==x) &#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; break; &#125; &#125; return 0;&#125; python 12345678910111213def main(): n, m, x = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) j = m - 1 for i in range(n): while a[i] + b[j] &gt; x and j &gt; 0: j -= 1 if a[i] + b[j] == x: print(i, j) breakmain() 判断子序列12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; m; i ++ ) scanf(&quot;%d&quot;, &amp;b[i]); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] == b[j]) i ++ ; j ++ ; &#125; if (i == n) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; python 123456789101112131415def main(): n, m = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) i, j = 0, 0 while i &lt; n and j &lt; m: if a[i] == b[j]: i += 1 j += 1 if i == n: print(&quot;Yes&quot;) else: print(&quot;No&quot;)main() 位运算求n的第k位数字：n&gt;&gt;k&amp;1 返回n的最后一位：lowbit(n)=n&amp;-n，如： x=1010，lowbit(x)=10 x=101000，lowbit(x)=1000 二进制中1的个数1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); while (n -- ) &#123; int x, s = 0; scanf(&quot;%d&quot;, &amp;x); for (int i = x; i; i -= i &amp; -i) s ++ ; printf(&quot;%d &quot;, s); &#125; return 0;&#125; python 12345678910def main(): n = int(input()) data = list(map(int,input().split())) for x in data: res = 0 while x: x = x - (x&amp;-x) res += 1 print(res,end=&#x27; &#x27;)main() 离散化当值域跨度大，但点分布比较稀疏时可用离散化，如给定数-1e10,-1,1e10，该数上所在位置对应一个数，此时可用一个数组中存储上述列举的稀疏的数，一个数组来存储对应的数 离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等… 离散化首先需要排序去重： 12341. 排序：sort(alls.begin(),alls.end())2. 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());unique(alls.begin(),alls.end())/*返回去重最后一位数，外层alls.erase()删去从alls中去重的最后一位数到alls后面的重复数的最后一位（也就是把unique操作中移到alls末尾的重复数全部删掉）*/ unique()函数的底层原理 12345678vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a) &#123; int j = 0; for (int i = 0; i &lt; a.size(); ++i) &#123; if (!i || a[i] != a[i - 1])//如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中 a[j++] = a[i];//每存在一个不同元素，j++ &#125; return a.begin() + j;//返回的是前j个不重复元素的下标&#125; 区间和建立x-&gt;value的映射，但是又不能是数组那种直接hash，所以做法是把所有可能的下标都记录下来，去重后，然后再建立一个新的数组来存放固定好x后的他们的value值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int n, m;int a[N], s[N];vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for (int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; // 去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理插入 for (auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; // 预处理前缀和 for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; //这里可以直接从1开始是因为find函数返回时从1开始的 // 处理询问 for (auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; python：因为把query的下标都加入了，所以这里的find函数一定能找到相同值，如果不插入的话，就需要写两个find函数分别查找大于等于l的下标和小于等于r的下标了 1234567891011121314151617181920212223242526272829303132def find(k, num): l = 0 r = len(k) - 1 while l &lt; r: mid = l + r &gt;&gt; 1 if k[mid] &gt;= num: r = mid else: l = mid + 1 return l + 1def main(): n, m = map(int, input().split()) add = [list(map(int, input().split())) for _ in range(n)] query = [list(map(int, input().split())) for _ in range(m)] d = dict() for item in add: d[item[0]] = d.get(item[0], 0) + item[1] for item in query: d[item[0]] = d.get(item[0], 0) d[item[1]] = d.get(item[1], 0) d = sorted(d.items()) k = [i[0] for i in d] v = [0] + [i[1] for i in d] for i in range(1, len(v)): v[i] = v[i - 1] + v[i] for pair in query: l = find(k, pair[0]) r = find(k, pair[1]) print(v[r] - v[l - 1])main() 区间合并1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt;PII;int n;void merge(vector&lt;PII&gt;&amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(),segs.end()); int st=-2e9,ed=-2e9; for(auto item:segs) &#123; if(item.first&gt;ed) &#123; if(st!=-2e9) res.push_back(&#123;st,ed&#125;);//把上一个块压入 st=item.first,ed=item.second;//开启一个新的块 &#125; else ed=max(ed,item.second);//不能开启新的块,拓展该块 &#125; //无论上述何种情况，最后一个块都尚未压入 if(st!=-2e9) res.push_back(&#123;st,ed&#125;); segs=res;&#125;int main()&#123; cin&gt;&gt;n; int l,r; vector&lt;PII&gt;segs; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;l&gt;&gt;r; segs.push_back(&#123;l,r&#125;); &#125; merge(segs); cout&lt;&lt;segs.size(); return 0;&#125; python 12345678910111213141516171819202122def merge(data): data.sort(key=lambda x: x[0]) st, ed = -2e9, -2e9 res = [] for item in data: if item[0] &gt; ed: if st != -2e9: res.append([st, ed]) st, ed = item else: ed = max(ed, item[1]) if st != -2e9: res.append([st, ed]) return resdef main(): n = int(input()) data = [list(map(int, input().split())) for _ in range(n)] data = merge(data) print(len(data))main() 数据结构单链表一般单链表的实现：指针+结构体 1234struct Node&#123; int val; Node* next;&#125;; 但在笔试题里面不怎么用，因为new的时候耗时比较高，在面试中常用 单链表，用得最多的是邻接表（n个链表），可用于存储树和图 双链表，用于优化某些问题 12int head,idx,e[N],ne[N];//分别为头指针,idx为下一个能放入的点,e数组存储值,ne数组存储next节点。null用-1表示 下面是单链表的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;const int N = 100010;// head 表示头结点的下标// e[i] 表示节点i的值// ne[i] 表示节点i的next指针是多少// idx 存储当前已经用到了哪个点int head, e[N], ne[N], idx;// 初始化void init()&#123; head = -1; idx = 0;&#125;// 将x插到头结点void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx ++ ;&#125;// 将x插到下标是k的点后面void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;// 将下标是k的点后面的点删掉void remove(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int m; cin &gt;&gt; m; init(); while (m -- ) &#123; int k, x; char op; cin &gt;&gt; op; if (op == &#x27;H&#x27;) &#123; cin &gt;&gt; x; add_to_head(x); &#125; else if (op == &#x27;D&#x27;) &#123; cin &gt;&gt; k; if (!k) head = ne[head]; else remove(k - 1); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142N = 100010e = [0]*Nne = [0]*Nhead,idx = -1,0def add_to_head(x): global idx,head e[idx]=x ne[idx]=head head = idx idx +=1def add(k,x): global idx e[idx] = x ne[idx] = ne[k] ne[k]=idx idx += 1def remove(k): ne[k]=ne[ne[k]]def main(): global idx,head m = int(input()) for i in range(m): op = input().split() if op[0]==&#x27;H&#x27;: x = int(op[1]) add_to_head(x) elif op[0]==&#x27;D&#x27;: k = int(op[1]) if k==0: head = ne[head] else: remove(k-1) else: k,x = int(op[1]),int(op[2]) add(k-1,x) i = head while i!=-1: print(e[i],end = &#x27; &#x27;) i = ne[i]main() 双链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;const int N=100010;int e[N],l[N],r[N],idx,m;void init()&#123; r[0]=1; l[1]=0; idx=2;&#125;//在下标k后面插入xvoid insert(int k,int x)&#123; e[idx]=x; l[idx]=k; r[idx]=r[k]; l[r[k]]=idx; r[k]=idx; idx++;&#125;void remove(int k)&#123; l[r[k]]=l[k]; r[l[k]]=r[k];&#125;int main()&#123; cin&gt;&gt;m; init(); while(m--) &#123; string op; int x,k; cin&gt;&gt;op; if(op==&quot;L&quot;) &#123; cin&gt;&gt;x; insert(0,x); &#125; else if(op==&quot;R&quot;) &#123; cin&gt;&gt;x; insert(l[1],x); &#125; else if(op==&quot;D&quot;) &#123; cin&gt;&gt;k; remove(k+1); &#125; else if(op==&quot;IL&quot;) &#123; cin&gt;&gt;k&gt;&gt;x; insert(l[k+1],x); &#125;else &#123; cin&gt;&gt;k&gt;&gt;x; insert(k+1,x); &#125; &#125; for(int i=r[0];i!=1;i=r[i]) &#123; cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950N = 100010e = [0] * Nl = [0] * Nr = [0] * Nidx = 2def init(): r[0] = 1 l[1] = 0def insert(k, x): global idx e[idx] = x l[r[k]] = idx r[idx] = r[k] l[idx] = k r[k] = idx idx += 1def remove(k): l[r[k]] = l[k] r[l[k]] = r[k]def main(): global idx init() m = int(input()) for i in range(m): op = input().split() if op[0] == &quot;L&quot;: x = int(op[1]) insert(0, x) elif op[0] == &quot;R&quot;: x = int(op[1]) insert(l[1], x) elif op[0] == &quot;D&quot;: k = int(op[1]) remove(k + 1) elif op[0] == &quot;IL&quot;: k, x = int(op[1]), int(op[2]) insert(l[k + 1], x) else: k, x = int(op[1]), int(op[2]) insert(k + 1, x) i = r[0] while i != 1: print(e[i], end=&quot; &quot;) i = r[i]main() 栈123456789101112131415161718#include &lt;iostream&gt;using namespace std;const int N=100010;// *********栈int stk[N],tt;//tt表示栈顶(是指向一个元素的)// 插入stk[++tt]=x;// 弹出tt--;//判断栈是否为空if(tt&gt;0) not emptyelse empty//栈顶stk[tt]; 模拟栈1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=100010;int m;int stk[N],tt;int main()&#123; cin&gt;&gt;m; while(m--) &#123; string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;) &#123; cin&gt;&gt;x; stk[++tt]=x; &#125;else if(op==&quot;pop&quot;) &#123; tt--; &#125;else if(op==&quot;empty&quot;) &#123; cout&lt;&lt;(tt?&quot;NO&quot;:&quot;YES&quot;)&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;stk[tt]&lt;&lt;endl; &#125; &#125; return 0;&#125; python：借助python特性简化一下 123456789101112131415def main(): m = int(input()) stk = [] for i in range(m): op = input().split() if op[0] == &#x27;push&#x27;: x = int(op[1]) stk.append(x) elif op[0] == &#x27;pop&#x27;: stk.pop() elif op[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(stk) else &#x27;YES&#x27;) else: print(stk[-1])main() 表达式求值如果所有字符的运算顺序都相同，也就是说从左往右算和从右往左算都无区别，那我们可以将所有数字压进栈中，所有操作符压进栈中，然后做eval操作，但是并不是所有情况我们都可以从后往前直接算的 如果前面运算符的优先级高的话或者相等（运算符优先级相等的话从左往右算），我们必须先算前面的操作，如3*5-2，就不能先算5-2 如果前面有括号，就必须先算括号里的，如(3-2)*5，就不能先算2*5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt;num;stack&lt;char&gt;op;void eval()&#123; auto b=num.top();num.pop();//b是右边的 auto a=num.top();num.pop();//a是左边的 auto c=op.top();op.pop(); int x; if(c==&#x27;+&#x27;) x=a+b; else if(c==&#x27;-&#x27;) x=a-b; else if(c==&#x27;*&#x27;) x=a*b; else x=a/b; num.push(x);&#125;int main()&#123; unordered_map&lt;char,int&gt; pr&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;&#125;;//优先级定义 string str; cin&gt;&gt;str; for(int i=0;i&lt;str.size();i++) &#123; auto c=str[i]; if(isdigit(c))//数字则构造数字 &#123; int x=0,j=i; while(j&lt;str.size()&amp;&amp;isdigit(str[j]))//构造x x=x*10+str[j++]-&#x27;0&#x27;; i=j-1; num.push(x); &#125; else if(c==&#x27;(&#x27;) op.push(c);//处理括号 else if(c==&#x27;)&#x27;)//处理括号前算的情况 &#123; while(op.top()!=&#x27;(&#x27;) eval(); op.pop(); &#125; else//处理优先级前算的情况 &#123; while(op.size()&amp;&amp;op.top()!=&#x27;(&#x27;&amp;&amp;pr[op.top()]&gt;=pr[c]) eval();//算完前面的 op.push(c); &#125; &#125; while(op.size()) eval();//接下来就没有异常情况了，可以直接算了 cout&lt;&lt;num.top()&lt;&lt;endl; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142434445pr = &#123;&quot;+&quot;: 1, &quot;-&quot;: 1, &quot;*&quot;: 2, &quot;/&quot;: 2&#125;num = []op = []def myeval(): b = num.pop() a = num.pop() c = op.pop() x = 0 if c == &quot;+&quot;: x = a + b elif c == &quot;-&quot;: x = a - b elif c == &quot;*&quot;: x = a * b else: x = int(a / b) num.append(x)def main(): exp = input() i = 0 while i &lt; len(exp): if exp[i].isdigit(): j = i while j &lt; len(exp) and exp[j].isdigit(): j += 1 num.append(int(exp[i:j])) i = j - 1 elif exp[i] == &quot;(&quot;: op.append(exp[i]) elif exp[i] == &quot;)&quot;: while op[-1] != &quot;(&quot;: myeval() op.pop() else: while len(op) and op[-1] != &quot;(&quot; and pr[op[-1]] &gt;= pr[exp[i]]: myeval() op.append(exp[i]) i += 1 while len(op): myeval() print(num[-1])main() 队列栈和队列书写思路对比： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N=100010;// *********栈int stk[N],tt;//tt表示栈顶(是指向一个元素的)// 插入stk[++tt]=x;// 弹出tt--;//判断栈是否为空if(tt&gt;0) not emptyelse empty//栈顶stk[tt];//*********队列int q[N],hh,tt=-1;//hh为队头，tt为队尾(包含元素的),hh为队头(同样包含元素),队头在低位，队尾在高位//插入q[++tt]=x;//弹出hh++;//判断队列是否为空if(hh&lt;=tt) not emptyelse empty//取出队头元素q[hh] //取出队尾元素q[tt] 模拟队列操作代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int q[N], hh, tt = -1;int main()&#123; cin &gt;&gt; m; while (m -- ) &#123; string op; int x; cin &gt;&gt; op; if (op == &quot;push&quot;) &#123; cin &gt;&gt; x; q[ ++ tt] = x; &#125; else if (op == &quot;pop&quot;) hh ++ ; else if (op == &quot;empty&quot;) cout &lt;&lt; (hh &lt;= tt ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl; else cout &lt;&lt; q[hh] &lt;&lt; endl; &#125; return 0;&#125; python版本 写法1：时间复杂度比较高，因为append(op[1]) 123456789101112131415q = []def main(): num = int(input()) for i in range(num): op = input().split() ch = op[0] if ch == &#x27;push&#x27;: q.append(op[1]) elif ch == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(q) else &#x27;YES&#x27;) elif ch == &#x27;pop&#x27;: q.pop(0) else: print(q[0])main() 写法2：降低了时间复杂度 123456789101112131415161718q = []def main(): hh,tt = 0,-1 num = int(input()) for i in range(num): op = input().split() ch = op[0] if ch == &#x27;push&#x27;: tt += 1 q.append(op[1]) elif ch == &#x27;pop&#x27;: hh += 1 elif ch == &#x27;empty&#x27;: print(&#x27;NO&#x27; if tt&gt;=hh else &#x27;YES&#x27;) else: print(q[hh])main() 写法三：python库 123456789101112131415from collections import dequedef main(): q = deque() num = int(input()) for i in range(num): op = input().split() if op[0] == &#x27;push&#x27;: q.append(op[1]) elif op[0] == &#x27;pop&#x27;: q.popleft() elif op[0] == &#x27;empty&#x27;: print(&#x27;NO&#x27; if len(q) else &#x27;YES&#x27;) else: print(q[0])main() 单调栈若a[x]&gt;=a[y]且x&gt;y，则a[x]可以被替换为y，故如果用stk栈结构来存储一个数前面的数： 若当前数下标为5，目前栈内的数下标为1~4，由上述说法可知，左侧标的三个红色圈的数都是无效的，故可被替换为新的数，最终形成红色的线，实质上是维持栈中元素随着下标单调递增，不能出现下折或者直线的情况 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N = 100010;int stk[N], tt;int main()&#123; int n; cin &gt;&gt; n; while (n -- ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); while (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;//若队列不为空，且栈顶大于等于x，栈顶将不会再被用到 if (!tt) printf(&quot;-1 &quot;); else printf(&quot;%d &quot;, stk[tt]);//若找到stk[tt]&lt;x,满足单调栈 stk[ ++ tt] = x; &#125; return 0;&#125; python版本： 12345678910111213141516N = 100010stk = [0]*Ndef main(): tt = -1 num = int(input()) lst = list(map(int,input().split())) for i in range(num): while tt&gt;=0 and stk[tt]&gt;= lst[i]: tt -= 1 if tt &lt; 0: print(-1,end=&#x27; &#x27;) else: print(stk[tt],end=&#x27; &#x27;) tt += 1 stk[tt] = lst[i]main() 单调队列滑动队列123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=10000010;int a[N],q[N];int n,k;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int hh=0,tt=-1; for(int i=0;i&lt;n;i++) &#123; //i-k+1~i是当前队列 if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;//首先踢掉不在队列中的 while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//保持队头到队尾递增 q[++tt]=i; //前面一截是不够队列的 if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]); &#125; puts(&quot;&quot;); hh=0,tt=-1; for(int i=0;i&lt;n;i++) &#123; if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++; while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--; q[++tt]=i; if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]); &#125; return 0;&#125; python： 123456789101112131415161718192021222324252627282930N = 1000010q = [0]*Ndef main(): hh,tt = 0,-1 n,k = map(int,input().split()) a = list(map(int,input().split())) res = [] for i in range(n): while tt&gt;=hh and q[hh]&lt;i-k+1: hh += 1 while tt&gt;=hh and a[q[tt]]&gt;=a[i]: tt -= 1 tt += 1 q[tt] = i if i-k+1&gt;=0: res.append(a[q[hh]]) print(&#x27; &#x27;.join(map(str,res))) res.clear() hh,tt = 0,-1 for i in range(n): while tt&gt;=hh and q[hh]&lt;i-k+1: hh += 1 while tt&gt;=hh and a[q[tt]]&lt;=a[i]: tt -= 1 tt += 1 q[tt] = i if i-k+1&gt;=0: res.append(a[q[hh]]) print(&#x27; &#x27;.join(map(str,res)))main() deque： 123456789101112131415161718192021222324252627from collections import dequeq = deque()res = []def main(): n,k = map(int,input().split()) a = list(map(int,input().split())) for i in range(n): while len(q)&gt;0 and i-k+1&gt;q[0]: q.popleft() while len(q)&gt;0 and a[q[-1]]&gt;=a[i]: q.pop() q.append(i) if i-k+1&gt;=0: res.append(a[q[0]]) print(&#x27; &#x27;.join(map(str,res))) res.clear() q.clear() for i in range(n): while len(q)&gt;0 and i-k+1&gt;q[0]: q.popleft() while len(q)&gt;0 and a[q[-1]]&lt;=a[i]: q.pop() q.append(i) if i-k+1&gt;=0: res.append(a[q[0]]) print(&#x27; &#x27;.join(map(str,res)))main() KMP前后缀等长相等 p[1,j]=p[i-j+1,i] 首先明确前后缀的含义，然后明确next数组的含义 注意总是用i和j+1进行匹配 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1e6+10;char p[N],s[N];int n,m;int ne[N];int main()&#123; cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;//习惯从1开始 for(int i=2,j=0;i&lt;=n;i++)//i从2开始是因为如果第一位不匹配无法再退了,该循环计算ne[i] &#123; while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];//如果j还有退路,即&gt;0,且需要退,则退 if(p[i]==p[j+1]) j++;//若匹配上了 ne[i]=j;//记录 &#125; for(int i=1,j=0;i&lt;=m;i++)//进行匹配,从待匹配串的第一位开始匹配 &#123; while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j]; if(s[i]==p[j+1]) j++; if(j==n) &#123; cout&lt;&lt;i-n&lt;&lt;&quot; &quot;; &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324def main(): n = int(input()) p = &#x27; &#x27; + input() m = int(input()) s = &#x27; &#x27; + input() N = 100010 ne = [0] * N j = 0 for i in range(2,n+1): while j and p[i]!=p[j+1]: j = ne[j] if p[i] == p[j+1]: j += 1 ne[i] = j j = 0 for i in range(1,m+1): while j and s[i]!=p[j+1]: j = ne[j] if s[i] == p[j+1]: j += 1 if j == n: print(i-n+1-1,end =&#x27; &#x27;) j = ne[j] # 借助已有优势继续匹配main() Trie Trie：高效地存储和查找字符串，是一个集合的数据结构 Trie树中有个二维数组 son[N][26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1][0]=2表示1结点的一个值为a的子结点为结点2;如果son[1][0] = 0，则意味着没有值为a子结点。这里的son[N]/[26]相当于链表中的ne[N]。 1234567891011void insert(char str[])&#123; int p = 0; //从根结点开始遍历 for (int i = 0; str[i]; i ++ ) &#123; int u =str[i] - &#x27;a&#x27;; if (!son[p][u]) son[p][u] = ++ idx; //没有该子结点就创建一个 p = son[p][u]; //走到p的子结点 &#125; cnt[p] ++; // cnt相当于链表中的e[idx]&#125; Trie树字符串统计12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int son[N][26],cnt[N],idx;int n;char str[N];void insert(char*str)&#123; int p=0; for(int i=0;str[i];i++) &#123; int u=str[i]-&#x27;a&#x27;; if(son[p][u]==0) son[p][u]=++idx; p=son[p][u]; &#125; cnt[p]++;&#125;int query(char*str)&#123; int p=0; for(int i=0;str[i];i++) &#123; int u=str[i]-&#x27;a&#x27;; if(son[p][u]==0) return 0; p=son[p][u]; &#125; return cnt[p];&#125;int main()&#123; cin&gt;&gt;n; char op[2]; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%s%s&quot;,op,str); if(*op==&#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;,query(str)); &#125; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233N = 100010son = [[0]*26 for _ in range(N)]cnt = [0]*Nidx = 0def insert(exp): global idx p = 0 for ch in exp: u = ord(ch) - ord(&#x27;a&#x27;) if son[p][u] == 0: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1def query(exp): global idx p = 0 for ch in exp: u = ord(ch) - ord(&#x27;a&#x27;) if son[p][u] == 0: return 0 p = son[p][u] return cnt[p]def main(): n = int(input()) for i in range(n): op,ch = input().split() if op == &#x27;I&#x27;: insert(ch) else: res = query(ch) print(res)main() 最大异或对有点贪心的味道 这道题的启示是：字典树不单单可以高效存储和查找字符串集合,还可以存储二进制数字思路:将每个数以二进制方式存入字典树,找的时候从最高位去找有无该位的异. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;const int N=100010,M=3100010;int n;int son[M][2],idx,a[N];void insert(int x)&#123; int p=0; for(int i=30;i&gt;=0;i--) &#123; int u=x&gt;&gt;i&amp;1; if(!son[p][u]) son[p][u]=++idx; p=son[p][u]; &#125;&#125;int search(int x)&#123; int p=0,res=0; for(int i=30;i&gt;=0;i--) &#123; int u=x&gt;&gt;i&amp;1; if(son[p][!u]) &#123; res+=1&lt;&lt;i; p=son[p][!u]; &#125;else p=son[p][u]; &#125; return res;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; insert(a[i]); &#125; int res=0; for(int i=0;i&lt;n;i++) &#123; res=max(res,search(a[i])); &#125; cout&lt;&lt;res; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536N = 3100010son = [[0]*2 for _ in range(N)]idx = 0def insert(exp): global idx p = 0 for i in range(30,-1,-1): u = exp&gt;&gt;i&amp;1 if son[p][u] == 0: idx += 1 son[p][u] = idx p = son[p][u]def query(exp): global idx p = 0 res = 0 for i in range(30,-1,-1): u = exp&gt;&gt;i&amp;1 if son[p][1^u] == 0: p = son[p][u] else: res += 1&lt;&lt;i p = son[p][1^u] return res def main(): n = int(input()) lst = list(map(int,input().split())) for item in lst: insert(item) res = 0 for item in lst: res = max(res,query(item)) print(res)main() 并查集并查集： 将两个集合合并 询问两个元素是否在一个集合中 基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储他的父节点，p[x]表示x的父节点 问题一：如何判断树根：if(p[x]==x) 问题二：如何求x的集合编号：while(p[x]!=x) x=p[x]; 问题三：如何合并两个集合：假设p[x]是x的集合编号，p[y]是y的集合编号。合并：p[x]=y 近乎O(1)的效率完成上述两个操作 优化——路径压缩：对问题二找根的过程进行优化，一旦往上走的过程中找到根节点，则把路径上所有节点的的根节点指向根（这样就能实现O(1)） 合并集合123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int p[N];int find(int x)//寻找x点的根节点&#123; if(p[x]!=x) p[x]=find(p[x]);//路径压缩 return p[x];&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) p[i]=i;//开始时每个点都是独立的 char op[2]; int a,b; while(m--)//进行m个操作 &#123; scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b); if(*op==&#x27;M&#x27;) p[find(a)]=find(b); else&#123; if(find(a)==find(b)) cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324N = 100010p = [0]*Ndef find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return xdef main(): n,m = map(int,input().split()) for i in range(1,n+1): p[i] = i for i in range(m): op,a,b = input().split() a,b =int(a),int(b) if op == &#x27;M&#x27;: p[find(a)] = find(b) else: if find(a) == find(b): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() 连通块中点的数量与上题类似，不同之处需要记录数量，这里规定只有根节点的数量属性是有效的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N=100010;int n,m;int p[N],cnt[N];//cnt记录数量，只对根节点有效int find(int x)&#123; if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; p[i]=i; cnt[i]=1; &#125; while(m--) &#123; string op; int a,b; cin&gt;&gt;op; if(op==&quot;C&quot;)//连通 &#123; cin&gt;&gt;a&gt;&gt;b; a=find(a),b=find(b); if(a!=b) &#123; p[a]=b; cnt[b]+=cnt[a]; &#125; &#125; else if(op==&quot;Q1&quot;)//查询是否连通 &#123; cin&gt;&gt;a&gt;&gt;b; if(find(a)==find(b)) cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; &#125;else&#123;//查询连通集 cin&gt;&gt;a; cout&lt;&lt;cnt[find(a)]&lt;&lt;endl; &#125; &#125; return 0;&#125; python 1234567891011121314151617181920212223242526272829N = 100010p = [0]*Ncnt = [1]*Ndef find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return p[x]def main(): n,m = map(int,input().split()) for i in range(1,n+1): p[i] = i for i in range(m): op = input().split() if op[0] == &#x27;C&#x27;: a = find(int(op[1])) b = find(int(op[2])) if a!=b: p[a] = b cnt[b] += cnt[a] elif op[0] == &#x27;Q1&#x27;: if find(int(op[1])) == find(int(op[2])): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) else: print(cnt[find(int(op[1]))])main() 食物链 find(x)有两个功能： 1 路径压缩, 2 更新 d[x]假设有一棵树 a -&gt; b -&gt; c -&gt; d， 根节点为 d。d[b]一开始等于 b、c 之间的距离，再执行完路径压缩命令之后，d[b] 等于b、d之间的距离。 d[a] += d[b]: 为了确保d[a]等于 节点a、d的距离，d[b]必须等于b 、d的距离，所以要先调用find(b)更新d[b]， 同时p[x] = find(b)会改变p[x]的值，结果就会变成d[a] += d[d],所以先用一个变量把p[a]的值存起来。 关键就是既要先执行find(p[x])， 又要让d[x] += d[p[x]]中p[x]的值保持不变，所以代码还可以这么写 这道题的插入方式需要注意，且使用距离来体现与根节点的关系，d%3的情况如下： =0，则与根节点同类型 =1，一层节点，可以吃掉根节点，可以被二层节点吃 =2，二层节点，可以吃掉一层节点，可以被零层节点（根节点同类型）吃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;const int N=50010;int n,m;int p[N],d[N];int find(int x)&#123; if(p[x]!=x) &#123; int t=find(p[x]); d[x]+=d[p[x]]; p[x]=t; &#125; return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i]=i; int res=0; while(m--) &#123; int t,x,y; scanf(&quot;%d%d%d&quot;,&amp;t,&amp;x,&amp;y); if(x&gt;n||y&gt;n) res++; else&#123; int px=find(x),py=find(y);//找到x和y的根节点 if(t==1)//两者同类 &#123; //若相同根，说明之前构造过，则若不同类(d[x]-d[y]%3!=0) //则是非法的 if(px==py&amp;&amp;(d[x]-d[y])%3) res++; else if(px!=py) &#123;//若不同根，说明这是第一次，需要进行构造 p[px]=py; d[px]=d[y]-d[x];//需要弥补x-&gt;px-&gt;y的第二段的长度d[x]+d[px]=d[y] &#125; &#125; else&#123;//为2的情况，x可以吃y //若px==py，说明之前构造过，则若不是x吃y的关系((d[x]-d[y]-1)%3)=0 //则是非法的 if(px==py&amp;&amp;(d[x]-d[y]-1)%3) res++; else if(px!=py) &#123;//若是不同根，说明这是第一次，需要进行构造 p[px]=py; //满足d[y]+1=d[x]+d[px],即将x的根节点作为y的根节点的子节点之后 //还要满足吃的关系（x比y下一层） d[px]=d[y]+1-d[x]; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 另外一种更加容易理解的做法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def main(): # 读取输入的 N 和 K n, k = map(int, input().split()) # 初始化并查集和关系数组 parent = [i for i in range(n + 1)] # 父节点数组 relation = [0] * (n + 1) # 关系数组，0: 同类, 1: 吃父节点, 2: 被父节点吃 false_count = 0 # 假话计数器 # 查找函数，带路径压缩和关系更新 def find(x): if parent[x] != x: original_parent = parent[x] # 记录原来的父节点 parent[x] = find(parent[x]) # 递归找到根节点 # 更新关系：当前节点的关系 = (当前节点与原来父节点的关系 + 原来父节点与根节点的关系) % 3 relation[x] = (relation[x] + relation[original_parent]) % 3 return parent[x] # 合并函数，处理两种关系（同类或捕食） def union(x, y, d): root_x = find(x) # 找到 x 的根节点 root_y = find(y) # 找到 y 的根节点 if root_x == root_y: # 如果 x 和 y 已经在同一个集合中，检查关系是否冲突 if (relation[x] - relation[y] + 3) % 3 != d - 1: return False # 冲突，返回 False else: return True # 不冲突，返回 True else: # 如果 x 和 y 不在同一个集合中，合并它们 parent[root_x] = root_y # 将 root_x 的父节点设为 root_y # 更新 root_x 与 root_y 的关系 # 关系公式：(relation[y] - relation[x] + d - 1 + 3) % 3 relation[root_x] = (relation[y] - relation[x] + d - 1 + 3) % 3 return True # 处理每一条声明 for _ in range(k): d, x, y = map(int, input().split()) # 检查是否超出范围 if x &gt; n or y &gt; n: false_count += 1 # 超出范围，假话 continue # 检查是否是自己吃自己 if d == 2 and x == y: false_count += 1 # 自己吃自己，假话 continue # 尝试合并 x 和 y 的集合，如果返回 False 则表示冲突 if not union(x, y, d): false_count += 1 # 冲突，假话 # 输出假话的总数 print(false_count)if __name__ == &quot;__main__&quot;: main() 整理一下： 12345678910111213141516171819202122232425262728293031323334353637383940N = 50010p = [0] * Nr = [0] * Ndef find(x): if p[x] != x: p_x = p[x] p[x] = find(p[x]) r[x] = (r[x] + r[p_x] + 3) % 3 return p[x]def union(op, a, b): ra = find(a) rb = find(b) if ra == rb: if (r[a] - r[b] + 3) % 3 != op - 1: return False else: return True else: p[ra] = rb r[ra] = (r[b] - r[a] + op - 1 + 3) % 3 return Truedef main(): n, k = map(int, input().split()) res = 0 for i in range(1, n + 1): p[i] = i for i in range(k): op, a, b = map(int, input().split()) if a &gt; n or b &gt; n: res += 1 elif op == 2 and a == b: res += 1 elif not union(op, a, b): res += 1 print(res)main() 堆如何手写一个堆？ 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素 堆——完全二叉树，除了最后一排节点都是非空的，最后一排节点从左到右排列 小根堆——每个点都是小于左右儿子的（可知根节点是堆里面的最小值） 存储方式： 1(根节点) 2(根节点左儿子) 3(根节点右儿子) 4 5 节点x的左儿子：2x 节点x的右儿子：2x+1 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//如何手写一个堆？完全二叉树 5个操作//1. 插入一个数 heap[ ++ size] = x; up(size);//2. 求集合中的最小值 heap[1]//3. 删除最小值 heap[1] = heap[size]; size -- ;down(1);//4. 删除任意一个元素 heap[k] = heap[size]; size -- ;up(k); down(k);//5. 修改任意一个元素 heap[k] = x; up(k); down(k);#include &lt;iostream&gt;using namespace std;int const N = 100010;//h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点//size 既表示堆里存储的元素个数，又表示最后一个结点的下标int h[N], siz; //堆有两个变量h[N]，size; 这里的size和文件里有冲突，只能改成siz了void down(int u)&#123; int t = u;//t存储三个结点中存在的最小的结点的下标，初始化为当前结点u if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; // 左子节点存在并且小于当前结点，更新t的下标 if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;//右子节点存在并且小于当前结点，更新t的下标 if (t != u)//如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值 &#123; swap(h[t], h[u]); down(t); //交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小 &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; //初始化size,表示堆里有n 个元素 for (int i = n / 2; i; i --) down(i); //把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉 //这里无需对所有节点进行down操作，只需要对前n/2个节点进行即可，叶子节点无需再进行down了 while (m -- ) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[siz]; siz --; down(1); &#125; return 0;&#125; python 1234567891011121314151617181920212223242526N = 100010h = [0]*Nsiz = 0def down(u): global siz t = u if 2*u&lt;=siz and h[2*u]&lt;h[t]: t = 2*u if 2*u+1&lt;=siz and h[2*u+1]&lt;h[t]: t = 2*u + 1 if t!=u: h[t],h[u] = h[u],h[t] down(t)def main(): global siz n,m = map(int,input().split()) siz = n h[1:n+1] = list(map(int,input().split())) for i in range(n//2,0,-1): down(i) for i in range(m): print(h[1],end =&#x27; &#x27;) h[1] = h[siz] siz -= 1 down(1)main() 模拟堆由于题目要求修改和删除第k个插入的，所以要加入存储映射，为了便于在up、down过程中修改映射，需要两个数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int h[N],ph[N],hp[N],cnt;//ph[i]=j表示第i个插入的数在堆中下标为j//hp[i]=j表示堆中下标为i的数是第j个插入的void heap_swap(int a,int b)&#123; swap(ph[hp[a]],ph[hp[b]]);//交换a、b下标，需要修改ph swap(hp[a],hp[b]);//因为下标改了，也需要修改hp swap(h[a],h[b]);&#125;void down(int u)&#123; int t=u; if(u*2&lt;=cnt&amp;&amp;h[u*2]&lt;h[t]) t=u*2; if(u*2+1&lt;=cnt&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1; if(u!=t) &#123; heap_swap(u,t); down(t); &#125;&#125;void up(int u)&#123; while(u/2&amp;&amp;h[u]&lt;h[u/2])//有根节点且根节点值没有满足最小堆要求 &#123; heap_swap(u,u/2); u&gt;&gt;=1;//u=u/2; &#125;&#125;int main()&#123; int n,m=0; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; char op[5]; int k,x; scanf(&quot;%s&quot;,op); if(!strcmp(op,&quot;I&quot;)) &#123; scanf(&quot;%d&quot;,&amp;x); cnt++; m++;//用m作为下标，因为cnt会减少而m不会减少 ph[m]=cnt,hp[cnt]=m;//cnt为在堆中下标，而m为第几个插入的数 h[cnt]=x;//插在最后的位置，然后向上up up(cnt); &#125; else if(!strcmp(op,&quot;PM&quot;)) printf(&quot;%d\\n&quot;,h[1]); else if(!strcmp(op,&quot;DM&quot;)) &#123; heap_swap(1,cnt); cnt--; down(1); &#125;else if(!strcmp(op,&quot;D&quot;)) &#123; scanf(&quot;%d&quot;,&amp;k); k=ph[k]; heap_swap(k,cnt); cnt--; up(k); down(k); &#125; else&#123; scanf(&quot;%d%d&quot;,&amp;k,&amp;x); k=ph[k]; h[k]=x; up(k); down(k); &#125; &#125; return 0;&#125; python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657N = 100010h = [0]*Nhp = [0]*Nph = [0]*Ncnt = 0def swap(a,b): ph[hp[a]],ph[hp[b]] = ph[hp[b]],ph[hp[a]] hp[a],hp[b] = hp[b],hp[a] h[a],h[b] = h[b],h[a]def up(u): while u//2 and h[u]&lt;h[u//2]: swap(u,u//2) u = u//2def down(u): global cnt t = u if u*2&lt;=cnt and h[u*2]&lt;h[t]: t = u*2 if u*2+1&lt;=cnt and h[u*2+1]&lt;h[t]: t = u*2+1 if t!=u: swap(u,t) down(t)def main(): global cnt n = int(input()) m = 0 for i in range(n): op = input().split() if op[0] == &#x27;I&#x27;: x = int(op[1]) cnt += 1 m += 1 h[cnt] = x ph[m] = cnt hp[cnt] = m up(cnt) elif op[0] == &#x27;PM&#x27;: print(h[1]) elif op[0] == &#x27;DM&#x27;: swap(1,cnt) cnt -= 1 down(1) elif op[0] ==&#x27;D&#x27;: k = int(op[1]) idx = ph[k] swap(idx,cnt) cnt -= 1 down(idx) up(idx) else: k,x = map(int,op[1:]) idx = ph[k] h[idx] = x down(idx) up(idx)main() 哈希表模拟散列表求质数的方法： 关于哈希函数对应的数组的大小：如果用拉链法，则和数多少差不多即可，如果用开放寻址法，则设置为该数的两倍 开放寻址法： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=200003,null=0x3f3f3f3f;//设置长度为两倍，设置空标志//注意null四个3f，memset对字节做的int h[N];//开放寻址法类似于找坑位int find(int x)//寻找&#123; int t=(x%N+N)%N; while(h[t]!=null&amp;&amp;h[t]!=x)//当前坑位被占，需要向后寻找 &#123; t++; if(t==N) t=0;//循环查找 &#125; return t;//不一定找对！&#125;int main()&#123; memset(h,0x3f,sizeof h);//设置空标志位 int n; scanf(&quot;%d&quot;,&amp;n); string op; int x; while(n--) &#123; cin&gt;&gt;op&gt;&gt;x; if(op==&quot;I&quot;) h[find(x)]=x; else &#123; if(h[find(x)]==null) puts(&quot;No&quot;); else puts(&quot;Yes&quot;); &#125; &#125; return 0;&#125; 拉链法： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=100003;int h[N],e[N],ne[N],idx;void insert(int x)//h数组类似于head指针的数组&#123;//头插法 int k=(x%N+N)%N;//哈希函数值,需要处理负数 e[idx]=x; ne[idx]=h[k]; h[k]=idx++;&#125;bool find(int x)&#123; int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]) &#123; if(e[i]==x) return true; &#125; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); memset(h,-1,sizeof h);//类似于单链表init的时候要将head初始化为-1 while(n--) &#123; string op; int x; cin&gt;&gt;op&gt;&gt;x; if(op==&quot;I&quot;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; python的defaultdict 12345678910111213141516from collections import defaultdictdef main(): d = defaultdict(int) n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: d[num] += 1 else: if d[num] == 0: print(&#x27;No&#x27;) else: print(&#x27;Yes&#x27;)main() 拉链法 12345678910111213141516171819202122232425262728293031323334N = 100003h = [-1]*Ne = [0]*Nne = [0]*Nidx = 0def insert(num): global idx k = num%N e[idx] = num ne[idx] = h[k] h[k] = idx idx += 1def find(num): k = num%N i = h[k] while i!=-1: if e[i] == num: return True i = ne[i] return False def main(): n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: insert(num) else: if find(num): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() 寻址法 1234567891011121314151617181920212223242526N = 200003null = 0x3f3f3f3fh = [null]*Ndef find(x): k = x % N while h[k]!=null and h[k]!=x: k += 1 if k == N: k = 0 return kdef main(): n = int(input()) for i in range(n): op = input().split() num = int(op[1]) if op[0] == &#x27;I&#x27;: k = find(num) h[k] = num else: k = find(num) if h[k]!=null: print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() 字符串哈希前求字符串的前缀哈希值 h[i]字符串前i位字符串对应的哈希值 我们将字符串当做一个p进制的数来看待 在字符串哈希中，我们没有处理冲突，靠经验定理来保证不冲突，将字符串看做是p进制的数 根据经验定理，p取131或者1331，得到的数模上2的64次方，可保证完全散列，由于数据类型unsigned int的值域恰好为2的64次方，故可以直接使用unsigned int存储，溢出即为取模 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N=100010,P=131;int n,m;char str[N];ULL h[N],p[N];//p数组存储每一位上的基本单元ULL get(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,str+1); p[0]=1; for(int i=1;i&lt;=n;i++) &#123; h[i]=h[i-1]*P+str[i];//直接用的ASCII码 p[i]=p[i-1]*P; &#125; while(m--) &#123; int l1,r1,l2,r2; scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2); if(get(l1,r1)==get(l2,r2)) &#123; puts(&quot;Yes&quot;); &#125;else puts(&quot;No&quot;); &#125; return 0;&#125; python 1234567891011121314151617181920212223N = 100010P = 131Q = 1&lt;&lt;64h = [0]*Np = [0]*Ndef find(l,r): return (h[r] - h[l-1]*p[r-l+1])%Qdef main(): global P global Q p[0] = 1 n,m = map(int,input().split()) s = &#x27; &#x27; + input() for i in range(1,n+1): h[i] = (h[i-1]*P + ord(s[i]))%Q p[i] = p[i-1]*P % Q for i in range(m): l1,r1,l2,r2 = map(int,input().split()) if find(l1,r1) == find(l2,r2): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;)main() 搜索与图论1.DFS：递归结束条件的选择+状态标记+递归后的恢复2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路4.树和图的存储：邻接表 h[N], e[N], ne[N], idx5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可 点的数量和边的数量，若点的数量的平方与边的数量大致相同，则为稠密图 邻接矩阵去重边用min，邻接表里面无需去重边 无向图存储的时候边的数量要开成给定边数量的一倍大小 DFS排列数字典型排列树，但是需要按照字典序来做，下面这种做法会有些不同 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=10;int x[N];int n;void DFS(int t)&#123; if(t==n) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;x[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); DFS(t+1); swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) x[i]=i; DFS(1); return 0;&#125; acwing提供的做法： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=10;int n;int path[N];void dfs(int u,int state)//用整型数state记录每个数的使用情况&#123; if(u==n) &#123; for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,path[i]); puts(&quot;&quot;); return; &#125; for(int i=0;i&lt;n;i++) &#123; if(!(state&gt;&gt;i&amp;1))//检查某个数是否被用过 &#123; path[u]=i+1; dfs(u+1,state+(1&lt;&lt;i));//注意这里并没有改变源state &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); dfs(0,0); return 0;&#125; n皇后问题排列树，dg和udg用来判断是否在对角线上有冲突，主对角线检查下标y-x+n是否冲突，副对角线检查x+y是否冲突 同时由于对角线数量是n的两倍左右，N数量要开两倍 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N=20;int x[N],dg[N],udg[N],n;void backtrack(int t)&#123; if(t&gt;n) &#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(j==x[i]) printf(&quot;Q&quot;); else printf(&quot;.&quot;); &#125; puts(&quot;&quot;); &#125; puts(&quot;&quot;); return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); if(!dg[t+x[t]]&amp;&amp;!udg[n+x[t]-t]) &#123; dg[t+x[t]]=udg[n+x[t]-t]=1; backtrack(t+1); dg[t+x[t]]=udg[n+x[t]-t]=0; &#125; swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; x[i]=i; &#125; backtrack(1); return 0;&#125; acwing解法，差不多 BFS分支限界框架 1234567891011121314151617181920212223queue Q;int bestw;Node k=new node();//初始化根节点set k;//设置k,假设k有属性cw,levelQ.push(k);while(!Q.empty())&#123; Node cn = Q.pop(); int level=cn.level; if(level&gt;n)&#123; print(); break; &#125; for(auto node:cn的后继) &#123; if(约束函数/限界函数) &#123; Node tmp = new Node(); set tmp;//设置tmp参数 Q.push() &#125; &#125;&#125; BFS相对而言更简单，通常无需考虑level和一些剪枝 走迷宫首先用回溯法做了一遍，果然超时了，回溯剪枝不够强大 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=105;int a[N][N];int n,m;int cw,cbest=10000;void dfs(int x,int y)&#123; if(x==n&amp;&amp;y==m) &#123; if(cw&lt;cbest) cbest=cw; return; &#125; if(cw&gt;cbest) return; a[x][y]=1; cw++; if(!a[x][y-1]) dfs(x,y-1); if(!a[x][y+1]) dfs(x,y+1); if(!a[x+1][y]) dfs(x+1,y); if(!a[x-1][y]) dfs(x-1,y); a[x][y]=0; cw--;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(a,1,sizeof a); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; dfs(1,1); cout&lt;&lt;cbest; return 0;&#125; 遂使用可爱的BFS！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=110;typedef pair&lt;int,int&gt; PII;int n,m;int g[N][N],d[N][N];//g数组记录地图,d数组记录走到此处的距离int bfs()&#123; queue&lt;PII&gt; q; memset(d,-1,sizeof(d)); d[0][0]=0;//初始化根节点 q.push(&#123;0,0&#125;); int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;//小技巧 while(q.size())//若队列不为空 &#123; auto t=q.front();//取队列元素 q.pop(); for(int i=0;i&lt;4;i++)//扩展 &#123; int x=t.first+dx[i]; int y=t.second+dy[i]; if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]==-1) &#123; d[x][y]=d[t.first][t.second]+1;//配置扩展节点 q.push(&#123;x,y&#125;);//加入队列 &#125; &#125; &#125; return d[n-1][m-1];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;g[i][j]; &#125; &#125; cout&lt;&lt;bfs()&lt;&lt;endl; return 0;&#125; 八数码主要难点在于状态的表示和转换上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;int bfs(string state)&#123; queue&lt;string&gt; q; unordered_map&lt;string,int&gt; d; q.push(state);//初始根节点 d[state]=0; int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,-1,0,1&#125;;//移动的小tip string end=&quot;12345678x&quot;;//终结状态 while(q.size())//若队列不为空 &#123; auto t=q.front(); q.pop(); if(t==end) return d[t];//取出后进行判断 int distance=d[t];//取节点距离方便后面扩展 int k=t.find(&#x27;x&#x27;);//方便修改和表示状态 int x=k/3,y=k%3; for(int i=0;i&lt;4;i++) &#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;=0&amp;&amp;a&lt;3&amp;&amp;b&gt;=0&amp;&amp;b&lt;3) &#123; swap(t[a*3+b],t[k]); if(!d.count(t)) &#123; d[t]=distance+1; q.push(t); &#125; swap(t[3*a+b],t[k]); &#125; &#125; &#125; return -1;&#125;int main()&#123; char s[2]; string state; for(int i=0;i&lt;9;i++) &#123; cin&gt;&gt;s; state+=*s; &#125; cout&lt;&lt;bfs(state)&lt;&lt;endl; return 0;&#125; 树与图的深度优先遍历树和图的存储方式，树是特殊的图，故介绍图的存储方式 图：有向图、无向图 有向图：a-&gt;b 无向图：a-&gt;b,b-&gt;a 故只需要考虑有向图的存储方式 领接矩阵：a-&gt;b，g[a][b]=w，记录边权，不能存储重边（a-&gt;b有多条边，但也可以直接选一条） 邻接表： （数组建立邻接表） 树/图的dfs//邻接表 123456789int h[N], e[N * 2], ne[N * 2], idx;void add(int a, int b) &#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int main()&#123; memset(h,-1,sizeof h);&#125; 树/图的bfs模板 12345678910// 需要标记数组st[N], 遍历节点的每个相邻的便void dfs(int u) &#123;//搜索节点u对应的节点 st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程 for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; dfs(j); &#125; &#125;&#125; 树的重心本题的本质是树的dfs， 每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。 也就是说，dfs并不直接返回答案，而是在每次更新中迭代一次答案。 这样的套路会经常用到，在 树的dfs 题目中 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100010,M=2*N;int n;int h[N],e[M],ne[M],idx;int ans=N;bool st[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;int dfs(int u)&#123; st[u]=true;//标记已经遍历完 int size=0,sum=0; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(st[j]) continue;//如果遍历过，则继续遍历下一个子节点 int s=dfs(j);//子节点的子树的节点数量 size=max(size,s);//计算子树节点的最大值 sum+=s;//为了计算当前节点所在子树 &#125; size=max(size,n-sum-1);//去掉当前节点后连通块的最大节点数 ans=min(ans,size);//选择最小值 return sum+1;//返回的应该是当前节点和以其为根节点的子树的全部节点的个数 &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); memset(h,-1,sizeof h); for(int i=0;i&lt;n-1;i++) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); &#125; dfs(1); printf(&quot;%d\\n&quot;,ans); return 0;&#125; 树与图的广度优先遍历图中点的层次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 100010;int n, m;int h[N], e[N], ne[N], idx;int d[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;int bfs()&#123; memset(d, -1, sizeof d); queue&lt;int&gt; q; d[1] = 0; q.push(1); while (q.size()) &#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (d[j] == -1) &#123; d[j] = d[t] + 1; q.push(j); &#125; &#125; &#125; return d[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i ++ ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; 拓扑排序有向图的拓扑序列有向图才有拓扑序，并非所有图都有拓扑序列，有向无环图一定存在一个入度为0的点，一定存在拓扑序列 所谓拓扑序列，要求A-&gt;B，A在拓扑序列中要求排列在B前面，所有的边都由前指向后 可所有知入度为0的节点可作为拓扑序列的最前位置，思路如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=100010;int n,m;int h[N],e[N],ne[N],idx;int d[N];//记录每个节点的入度int q[N];//队列void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool topsort()&#123; int hh=0,tt=-1;//队头，队尾 for(int i=1;i&lt;=n;i++)//首先将所有入度为0的点加入队列 &#123; if(!d[i]) q[++tt]=i; &#125; while(hh&lt;=tt) &#123; int t=q[hh++];//弹出队首元素 for(int i=h[t];i!=-1;i=ne[i])//遍历其在图中相邻节点 &#123; int j=e[i]; if(--d[j]==0)//如果入度为0，则加入队列中 &#123; q[++tt]=j; &#125; &#125; &#125; return tt==n-1;//所有节点都入队过&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); int a,b; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a&gt;&gt;b; add(a,b); d[b]++; &#125; if(!topsort()) puts(&quot;-1&quot;); else &#123; for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]); puts(&quot;&quot;); &#125; return 0;&#125; Dijkstra稠密图用领接矩阵，稀疏图用邻接链表 朴素版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];bool st[N];int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) &#123; int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m -- ) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); &#125; printf(&quot;%d\\n&quot;, dijkstra()); return 0;&#125; 最小堆优化priority_queue的定义方法如下所示： 1234priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;//本题使用pair来做，pair的first含义为距离，second含义为编号priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1e6+10;int n,m;int h[N],w[N],e[N],ne[N],idx;int dist[N];bool st[N];void add(int a,int b,int c)&#123; e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;&#125;int dijkstra()&#123; memset(dist,0x3f,sizeof dist);//先设置为无穷大 dist[1]=0;//起点设置为0 priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//定义最小堆 heap.push(&#123;0,1&#125;);//到第一个节点的距离时0 while(heap.size()) &#123; auto t=heap.top();//取堆顶节点 heap.pop(); int ver=t.second,distance=t.first;//取节点对应的节点编号和距离 if(st[ver]) continue;//若已经扩展过，则无需扩展 st[ver]=true;//扩展该节点 for(int i=h[ver];i!=-1;i=ne[i]) &#123; int j=e[i];//取节点编号 if(dist[j]&gt;dist[ver]+w[i])//更新其后继节点 &#123; dist[j]=dist[ver]+w[i]; heap.push(&#123;dist[j],j&#125;);//加入到队列中 //注意这里没有删掉以前这个节点在队列中的信息，因为是优先队列 //且每个节点也只能扩展一次 &#125; &#125; &#125; if(dist[n]==0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(h,-1,sizeof h); int a,b,c; while(m--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; printf(&quot;%d&quot;,dijkstra()); return 0;&#125; bellman-ford可以处理负权重的情况，可以检测负环但是时间复杂度较高 串联：由于这个算法的特性决定，每次更新得到的必然是在多考虑 1 条边之后能得到的全局的最短路。而串联指的是一次更新之后考虑了不止一条边：由于使用了松弛，某节点的当前最短路依赖于其所有入度的节点的最短路；假如在代码中使用dist[e.b]=min(dist[e.b],dist[e.a] + e.c);，我们无法保证dist[e.a]是否也在本次循环中被更新，如果被更新了，并且dist[e.b] &gt; dist[e.a] + e.c，那么会造成当前节点在事实上“即考虑了一条从某个节点指向a的边，也考虑了a-&gt;b”，共两条边。而使用dist[e.b]=min(dist[e.b],last[e.a] + e.c);，可以保证a在dist更新后不影响对b的判定，因为后者使用last数组，保存着上一次循环中的dist的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=510,M=10010;struct Edge&#123; int a,b,c;&#125;edges[M];int n,m,k;int dist[N];int last[N];//是用来避免串联影响的void bellman_ford()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;k;i++) &#123; memcpy(last,dist,sizeof dist); for(int j=0;j&lt;m;j++) &#123; auto e=edges[j]; dist[e.b]=min(dist[e.b],last[e.a]+e.c); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);//n个点m条边k步 int a,b,c; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); edges[i]=&#123;a,b,c&#125;; &#125; bellman_ford(); if(dist[n]&gt;0x3f3f3f3f/2) puts(&quot;impossible&quot;); else printf(&quot;%d&quot;,dist[n]); return 0;&#125; spfa改进bellman_ford算法，dist[v]=dist[w]+w仅当前面的节点w的dist发生变化才更新，具体而言需要用广搜来做 还是基于bellman方程来做的，但是只动态加入前继节点改变的后继：dist[x]=dist[t]+w[i] spfa求最短路AcWing 851. SPFA算法 - AcWing 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N=1e6+10;int n,m;int h[N],ne[N],w[N],e[N],idx;int dist[N];bool st[N];void add(int a,int b,int c)&#123; e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;&#125;int spfa()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; queue&lt;int&gt; q; q.push(1); st[1]=true; while(q.size()) &#123; int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]) &#123; int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) &#123; dist[j]=dist[t]+w[i]; if(!st[j]) &#123; q.push(j); st[j]=true; &#125; &#125; &#125; &#125; return dist[n];&#125;int main()&#123; memset(h,-1,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; int t=spfa(); if(t==0x3f3f3f3f) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,t); return 0;&#125; spfa判断负环12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N=2010,M=10010;int n,m;int h[N],ne[M],w[M],e[M],idx;bool st[N];int dist[N],cnt[N];void add(int a,int b,int c)&#123; e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) &#123; st[i]=true; q.push(i); &#125; while(q.size()) &#123; int t=q.front(); q.pop(); st[t]=false; for(int i=h[t];i!=-1;i=ne[i]) &#123; int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) &#123; dist[j]=dist[t]+w[i]; cnt[j]=cnt[t]+1; if(cnt[j]&gt;=n) return true; if(!st[j]) &#123; st[j]=true; q.push(j); &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); &#125; if(spfa()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 问题一：为什么dt数组不用初始化为0x3f3f3f3f，以及为什么初始化要把所有点入队？答：dt数组的初始值是多少都不影响，因为dt数组在这里记录的不是最短路径。首先，我们理解初始化时为什么把所有点都加入队列中，在求1开始到n的最短路时，我们只把1入队了且让dt[1] = 0，目的是让1成为开始时唯一一个更新了dt数组的点，然后在根据已更新dt数组的这些点去更新他的出边（这就是spfa改良bellman的精髓）。但是负环可能不在点1的后继上（可以自行构造，把1放在拓扑图的中断位置，负环在点1的前面），所以要把所有点入队。所有看到这就懂了，dt数组的意义不是记录最短路径，而且来更新后继节点的，如果某个点的dt更新过了，那么就可以用这个点来更新他的后继节点（在求最短路问题里，一个点距离初始点的距离边短了，是不是尝试用这个点去更新他的后继节点，可能使得后继节点的最短距离也变小）。 FloydFloyd求最短路三重循环！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=210,INF=1e9;int n,m,Q;int d[N][N];void floyd()&#123; for(int k=1;k&lt;=n;k++) &#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125;int main()&#123; //初始化图 scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) d[i][j]=0; else d[i][j]=INF; &#125; &#125; while(m--) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); d[a][b]=min(d[a][b],c); &#125; //floyd floyd(); //轮询 while(Q--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); int t=d[a][b]; if(t&gt;INF/2) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); &#125; return 0;&#125; Prim算法Prim算法求最小生成数朴素版本：类似于dijkstra算法 思路： 与dijkstra不同，prim需要迭代n次 最小生成树是针对无向图的，所以在读入边的时候，需要赋值两次 要先累加再更新，避免t有自环，影响答案的正确性。后更新不会影响后面的结果么？不会的，因为dist[i]为i到集合S的距离，当t放入集合后，其dist[t]就已经没有意义了，再更新也不会影响答案的正确性。 需要特判一下第一次迭代，在我们没有做特殊处理时，第一次迭代中所有点到集合S的距离必然为无穷大，而且不会进行更新(也没有必要)，所以不需要将这条边(第一次迭代时，找到的距离集合S最短的边)累加到答案中，也不能认定为图不连通。 如果需要设置起点为i的话，在初始化dist数组之后，dist[i] = 0即可，这样也可以省去每轮迭代中的两个if判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N=510,INF=0x3f3f3f3f;int g[N][N],dist[N],n,m;bool st[N];int prim()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; int res=0; for(int i=0;i&lt;n;i++) &#123; int t=-1; for(int j=1;j&lt;=n;j++) &#123; if(!st[j]&amp;&amp;(t==-1||dist[j]&lt;dist[t])) &#123; t=j; &#125; &#125; if(dist[t]==0x3f3f3f3f) return 0x3f3f3f3f; res+=dist[t]; st[t]=true; for(int i=1;i&lt;=n;i++) dist[i]=min(dist[i],g[t][i]); &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(g,0x3f,sizeof g); int a,b,c; while(m--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=g[b][a]=min(g[a][b],c); &#125; int t=prim(); if(t==0x3f3f3f3f) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); return 0;&#125; Kruskal算法求最小生成数 将所有边按权重从小到大排序 $O(nlogn)$ 枚举每条边a,b，权重c；ifa,b不连通，将这条边也加入集合（并查集的使用） $(1)$ 稀疏图里用kruskal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010,M=200010,INF=0x3f3f3f3f;int n,m;int p[N];//每个节点的爷struct Edge&#123; int a,b,w; bool operator &lt;(const Edge&amp;W) const &#123; return w&lt;W.w;//重载方便排序 &#125;&#125;edges[M];int find(int x)//并查集找爷&#123; if(p[x]!=x) p[x]=find(p[x]); return p[x];&#125;int kruskal()&#123; sort(edges,edges+m); for(int i=1;i&lt;=n;i++) p[i]=i;//你我都是爷 int res=0,cnt=0; for(int i=0;i&lt;m;i++) &#123; int a=edges[i].a,b=edges[i].b,w=edges[i].w; a=find(a),b=find(b); if(a!=b) &#123; p[a]=b;//连通 res+=w;//加上这条边 cnt++;//又连通了一个节点 &#125; &#125; if(cnt&lt;n-1) return INF;//有节点没有加进来，说明图不连通 return res;//返回结果&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) &#123; int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); edges[i]=&#123;a,b,w&#125;; &#125; int t=kruskal(); if(t==INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;,t); return 0;&#125; 染色法判定二分图一个图是二分图，当前仅当图中不含奇数环（由于图中不含奇数环，所以染色过程一定没有矛盾） 二分图指图能分为两个集合，每个集合内部没有边，边都在集合之间（用两种颜色染色） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010,M=200010;int n,m;int h[N],e[M],ne[M],idx;int colour[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool dfs(int u,int c)&#123; colour[u]=c; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(!colour[j])//若没有染色 &#123; if(!dfs(j,3-c)) return false;//因为i染了c，所以后继要染相反的颜色 &#125; else if(colour[j]==c) return false;//如果染了和i相同的颜色，则冲突 &#125; return true;//如果未发生冲突，则返回true&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b; memset(h,-1,sizeof h); for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); &#125; bool flag=true; for(int i=1;i&lt;=n;i++) &#123; if(!colour[i]) &#123; if(!dfs(i,1)) &#123; flag=false; break; &#125; &#125; &#125; if(flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 匈牙利算法二分图的最大匹配姑娘 j 遇到新的追求者的心理活动：如果原来的男朋友有备胎，我就绿他，如果没有，那我看他太可怜了，就一直跟他在一起吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N=510,M=100010;int n1,n2,m;int h[N],e[M],ne[M],idx;int match[N];bool st[N];void add(int a,int b)&#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;bool find(int x)//为男生x找女生&#123; for(int i=h[x];i!=-1;i=ne[i]) &#123; int j=e[i];//女生的编号 if(!st[j])//这个女生之前没有尝试匹配过 &#123; st[j]=true;//现在尝试过了 if(match[j]==0||find(match[j]))//如果喜欢的女生单身,或者能变成前任 &#123; match[j]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;m); memset(h,-1,sizeof h); while(m--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b); &#125; int res=0; for(int i=1;i&lt;=n1;i++) &#123; memset(st,false,sizeof st); if(find(i)) res++;//为男生找到女生 &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 数论 数论 组合计数 高斯消元 简单博弈论 质数定义：在大于1的整数中，如果值包含1和本身这两个约数，就被称之为质数，或者叫素数 所有小于等于1的数既不是质数也不是合数 （1）质数的判定——试除法 （2）分解质因数——试除法：从小到达枚举所有数， 试除法判定质数只枚举较小的约数以减小时间复杂度，时间复杂度$O(sqrt(n))$ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;bool is_prime(int x)&#123; if(x&lt;2) return false; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) return false; &#125; return true;&#125;int main()&#123; int n; cin&gt;&gt;n; int m; while(n--) &#123; cin&gt;&gt;m; if(is_prime(m)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125; 分解质因子质因数是指，能够被n 整除（也就是他的约数或者叫因子），并且本身是质数的数。 我们可以从前往后去筛，而不需要判断这个数是否是质数，举个例子n=12,那么2到12之间一共有2,3,4,5,6,7,8,9,10,11 这几个数，当i=2时，会筛掉2,4,6这几个数（前提是这几个数是ta的约数），4这个合数就是 2*2 被筛掉了 ，6同理，也就是合数等于质数和质数的乘积,不用担心该因子不是质数 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int divide(int x)&#123; for(int i=2;i&lt;=n;i++) &#123; if(n%i==0) &#123; int s=0; while(n%i==0) &#123; n/=i; s++; &#125; printf(&quot;%d %d\\n&quot;,i,s); &#125; &#125;&#125; n中至多只包含一个大于sqrt(n)的质因子，故可以先枚举小于sqrt(n)的质因子，然后单独考虑那个大于sqrt(n)的质因子 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;void divide(int x)&#123; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) &#123; int s=0; while(x%i==0) x/=i,s++; cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;s&lt;&lt;endl; &#125; &#125; if(x&gt;1) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;1&lt;&lt;endl;//剩下一个大于根号x的质因子（该数得是大于1的） puts(&quot;&quot;);&#125;int main()&#123; int n,m; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;m; divide(m); &#125; return 0;&#125; 筛质数埃式筛法：当一个数是质数时（因为合数等价于用其质因子筛，对于合数我们可以直接跳过），即未被筛，则加入，同时用他向后筛他的倍数，可以想象，以他为因数的合数会被筛掉，如果后面的某个数未被筛，说明他前面的数都不是他的因数，满足质数定义，故有效。埃氏筛法复杂度差不多n，但是还是比n大一点 线性筛法：复杂度就是n 埃式筛法： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;int primes[N],cnt;bool st[N];void get_primes(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(st[i]) continue;//若为合数 primes[cnt++]=i;//若为质数 for(int j=i+i;j&lt;=n;j+=i)//筛掉质数的倍数，如i=2,筛掉4,6等等 &#123; st[j]=true; &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; get_primes(n); cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 线性筛法： 线性筛法的原理：n只会被最小质因子筛掉 本来我们应该对每个质数像埃氏筛法一样去筛，去把他的所有倍数找出来，但我们也可以不这样，可以并行地做，让相同的i乘以primes[j]来筛，但是是否需要让i乘以每个primes[j]来筛呢，如果i%primes[j]成立，说明primesj是i的最小质因子，我们希望每个数都被其最小质因子筛，所以i*primes[j+1]筛掉这个任务应该交给k*primes[j]来完成，同理接下来的i*primes[j+x]…，所以就不需要再循环下去了，break 那一上来把primes[j]i筛了合适吗，这个是能保证最小筛吗，如果j大于0，也就是不是第一次循环，假设现在是c+1次循环，那么在第c次判断的时候通过判断可知i%primes[c]!=0,故可知i的最小质因数大于primes[c]，数i\\primes[c+1]的最小质因数要么是i要么是primes[c+1]，如果是第一次循环，那么primes[j]为2，其为最小的质数，用其筛掉的数一定能保证原则用最小质因数筛 我们筛的时候总是用最小质因数来筛，并且筛的是i*primes[j]，这个数筛的时候是归为用primes[j]作为最小质因数来筛的，因为如果归为i，i如果是合数的话，那么应该由i的最小质因数来筛，如果是质数的话，那么i刚刚加入primes数组中，按照顺序(i这个质数)(primes这个质数)，显然primes这个质数更小，所以也是归为primes这个质数来筛的，所以i\\primes[j]来筛总是归为primes[j]作为最小质因数来筛 所以当不满足这个条件的时候，也就是i*primes[j]不能归为primes[j]时，那么一定是i为合数，即由i的最小质因子来筛，因为如果是质数的话按照上一条，仍然归结为primes[j]，也就是说i的最小质因子小于等于primes[j]吧，所以我们为了满足黑体加粗的规则，在等于的时候就跳出循环 1234567891011121314151617void get_primes(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; // 存质数 for (int j = 0; primes[j] &lt;= n / i; j ++ ) // 结束的条件是：primes[j] * i &lt;= n, 最多筛到n &#123; st[primes[j] * i] = true; // 把合数 primes[j] * i 筛了 if (i % primes[j] == 0) break;//遍历的过程中把归结为以i的最小质因子的可能去掉 // 若 i 为 primes[j] 的合数, 在筛prime[j] * i之前就已经把i筛掉了 // i都被筛了，比i大的 primes[j]的倍数也在之前被筛了 // 因为 i = primes[j] * k, primes[j] &lt; i, k &lt; i. // 而 i &lt; n, 若 i - n之间还存在prims[j]* (k + 1) == x &lt; n 的话 // i &lt; x &lt; n，循环结束时可以筛到n，故primes[j]的k + 1倍 x会被筛掉 &#125; &#125;&#125; 约数（1）试除法求一个数的所有约数 只需要枚举较小的约束，较大的那个可以直接计算出来 （2）约束个数 int范围内约数最多的是1500左右 （3）约束之和 约束之和展开即可呀，每个括号里选一个就行了~ （4）最大公约数 欧几里得算法（辗转相除法） 约束个数先把每个数分解为质因子表达式，然后用上面的公式 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N=110,mode=1e9+7;int main()&#123; int n; cin&gt;&gt;n; unordered_map&lt;int,int&gt;primes; while(n--) &#123; int x; cin&gt;&gt;x; for(int i=2;i&lt;=x/i;i++)//把每个数分解成质因子表达式 &#123; while(x%i==0)&#123; x/=i; primes[i]++; &#125; &#125; if(x&gt;1) primes[x]++; &#125; LL res=1;//注意是1 for(auto p:primes) res=res*(p.second+1)%mode; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 约束之和主要是$1+P+P^2…$的处理采用t=t*p+1的方式完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 110, mod = 1e9 + 7;int main()&#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) &#123; x /= i; primes[i] ++ ; &#125; if (x &gt; 1) primes[x] ++ ; &#125; LL res = 1; for (auto p : primes) &#123; LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 试除法求约数1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; get_divisors(int x)&#123; vector&lt;int&gt; res; for(int i=1;i&lt;=x/i;i++)//枚举较小者即可 &#123; if(x%i==0) &#123; res.push_back(i); if(i!=x/i) res.push_back(x/i);//避免两个相同 &#125; &#125; sort(res.begin(),res.end()); return res;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int x; cin&gt;&gt;x; auto res=get_divisors(x); for(auto x:res) cout&lt;&lt;x&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; 最大公约数 欧几里得算法，时间复杂度$log(n)$ 注意: d|a的含义是a能被d整除，即a/d 基于如下原理：d|a,d|b,则有d|ax+by，所以a和b的最大公约数(a,b)也可以表示为(b,a-c*b)，可知假设(a,b)值为k，k一定都整除b和a-c*b，特殊的，这里的c取[a/b]，故有(a,b)=(b,a%b)，如果b为0，则由于0可以被任何数整除，0/k=0,所以最大公约数返回a（也就是说任何的数都是0的约数） 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;//若b为0，则返回a(0可以整除任何数),否则返回(b,a%b)&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;gcd(a,b)&lt;&lt;endl; &#125; return 0;&#125; 欧拉函数欧拉函数互质：公约数只有1的两个整数 欧拉函数就是求出1~N中与N互质的数的个数，比如6与1,5互质，故欧拉函数值为2 欧拉公式原理：上面的公式展开就是下面的容斥原理，比如1/p1这个项前面是负号，两个的话是正号。。。。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int phi(int x)&#123; //这里没存质因数，因为没必要 int res=x; for(int i=2;i&lt;=x/i;i++) &#123; if(x%i==0) &#123; res=res/i*(i-1);//先除后乘，避免计算过程中溢出 while(x%i==0) x/=i;//除尽 &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int x; cin&gt;&gt;x; cout&lt;&lt;phi(x)&lt;&lt;endl; &#125; return 0;&#125; 筛法求欧拉函数如果要求1~N中每一个数的欧拉函数，如果用公式来算，分解质因数n次将复杂度变成$O(n*sqrt(n))$，而筛法求每个数的欧拉函数的时间复杂度为$O(n)$ 在线性筛法的过程中顺便把欧拉函数求出来，注意欧拉函数的定义，1~N中与N互质的数的个数 若i是质数，那么i与前i-1个数均互质，这是质数的定义（质数只有他自己和1两个因子），故其phi值为i-1 primes[j]*i的phi值 如果i%primes[j]==0，按照线性筛法，此时primes[j]恰好是i的最小质因数，所以按照公式可知：phi[i%primes[j]]=primes[j]*phi[i] 如果i%primes[j]!=0，按照线性筛法，此时i的最小质因子大于primes，故需要分别计算i和primes[j]的质因子 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=1000010;int primes[N],cnt;int euler[N];bool st[N];void get_euler(int n)&#123; euler[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!st[i])//是质数 &#123; primes[cnt++]=i; euler[i]=i-1;//质数和其前面的数互质 &#125; for(int j=0;primes[j]&lt;=n/i;j++)//对于该数与质数的乘数，向后筛 &#123; int t=primes[j]*i; st[t]=true; if(i%primes[j]==0)//eulaer中已经包含了1/primes[j] &#123; euler[t]=euler[i]*primes[j]; break; &#125;//未包含 euler[t]=euler[i]*(primes[j]-1); &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; get_euler(n); LL res=0; for(int i=1;i&lt;=n;i++) res+=euler[i]; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 欧拉函数的一个运用，因为a和n互质，假设1~n中与n互质的数为a1,a2,…a_phi(n),将这些数乘以a后也将与n互质（只有1这一个公因子），而在模n的情况下这两种应该是等价的(模n之后)，所以乘起来，可得上面的公式,如5^2^=25%6=1，其中phi(6)=2 快速幂原理： 例子： 快速幂若求A的B次方的后几位数，则这里的后几位数就是q LL res = 1 % p;注意这个式子！！！，当a=5,b=0,p=1这种情况下是会出错的 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a,int b,int q)&#123; LL res=1%q; while(b) &#123; //把b转换为二进制 if(b&amp;1) res=res*a%q; a=a*(LL)a%q;//a变成其平方 b&gt;&gt;=1; &#125; return res%q;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int a,b,q; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;q); printf(&quot;%lld\\n&quot;,qmi(a,b,q)); &#125; return 0;&#125; 快速幂求逆元在欧几里得算法那节我们知道了费马定理：注意条件是a和p互质且p是质数，如果a是p的倍数，快速幂是无法求的 b的逆元就是上面的x，最终通过费马定理转换为求b^(n-2)%n，转变为快速幂 注意这里a和n要求互质，否则结果是impossible 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a,int b,int p)&#123; LL res=1; while(b) &#123; if(b&amp;1) res=res*a%p; a=a*(LL)a%p; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n; cin&gt;&gt;n; int a,p; while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;p); if(a%p==0) puts(&quot;impossible&quot;); else printf(&quot;%lld\\n&quot;,qmi(a,p-2,p));//a^(p-2)%p; &#125; return 0;&#125; 扩展欧几里得算法欧几里得算法： 基于如下原理：d|a,d|b,则有d|ax+by，所以a和b的最大公约数(a,b)也可以表示为(b,a-c*b)，可知假设(a,b)值为k，k一定都整除b和a-c*b，特殊的，这里的c取[a/b]，故有(a,b)=(b,a%b)，如果b为0，则由于0可以被任何数整除，0/k=0,所以最大公约数返回a（也就是说任何的数都是0的约数） 裴蜀定理：对于任意正整数a,b，一定存在非零整数x，y，使得ax+by=(a,b)的最大公约数 最大公约数就是最大公因数，扩展欧几里得就是构造x和y，利用的是递归的思想 当b为0时，可以轻易写出来，当b不为0时，找到前后两层的递归关系 扩展欧几里得算法 x、y并不唯一，算法求出其一 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)//如果b为0，则最大公约数就是a &#123; x=1,y=0; return a; &#125; //下面是递归两层间的关系 int d=exgcd(b,a%b,y,x);//已经求得by+(a%b)x=d的解y,x，现在根据已经求得的解求ax+by=d的解x和y //扩展欧几里得 y-=a/b*x; return d;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a,b; while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); int x,y; exgcd(a,b,x,y); printf(&quot;%d %d\\n&quot;,x,y); &#125; return 0;&#125; 线性同余方程 根据欧几里得算法，对于ax+my=d，其中d是a和m的最大公约数，一定在一些条件下有解，但是题目给出的是b，所以不一定有解，有解的条件是b能够被d整除，并且可知实际的x值会因此而扩大b/d倍 线性同余方程求的是这个x，思路是用扩展欧几里得首先求a和m的最大公约数d，然后把求得的x扩展b/d倍 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;typedef long long LL;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b) &#123; x=1,y=0; return a; &#125; int t=exgcd(b,a%b,y,x); y-=a/b*x; return t;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a,b,m; while(n--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;m); int x,y; int d=exgcd(a,m,x,y); if(b%d) puts(&quot;impossible&quot;);//要求能整除最大公约数 else printf(&quot;%d\\n&quot;,(LL)b/d*x%m); &#125; return 0;&#125; 假设某个特解为ax0+by0=n；那这个也等同于 a（x0+bt）+b（y0-at）=n;x的通解为 x=x0+b*t;最后取模可以求最小的解 中国剩余定理表达整数的奇怪方式 按照上图的步骤来求： 首先化为k1a1-k2a2=m2-m1形式，这个形式做两件事情，第一件事情是判断是否有解，有解等价于(m2-m1)是(a1,a2)的倍数，第二件事情是根据扩展欧几里得算法求出k1 但是为了题目的x的最小条件，我们需要根据扩展欧几里得的通解形式缩小k1，这也是一步 在求出k1之后我们就可以求x了，x=a1k1+m1+ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; LL d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125;int main()&#123; int n; cin&gt;&gt;n; LL x=0,m1,a1; cin&gt;&gt;a1&gt;&gt;m1; for(int i=0;i&lt;n-1;i++)&#123; LL m2,a2; cin&gt;&gt;a2&gt;&gt;m2; LL k1,k2; LL d=exgcd(a1,a2,k1,k2); if((m2-m1)%d)&#123; x=-1; break; &#125; //更新状态 k1*=(m2-m1)/d;//因为等式右边是m2-m1而不是最大公约数，所以需要扩展 LL t=a2/d;//上图下面的通解形式 //将解变成一个最小的正整数解 k1=(k1%t+t)%t; x=k1*a1+m1;//求得x //下面就是把两个式子统一为一个式子继续合并 //更新a和m，k只是个变量，不用管，取余的时候会自动消失 m1=k1*a1+m1; a1=abs(a1/d*a2);//最小公倍数 &#125; if(x!=-1) x=(m1%a1+a1)%a1; cout&lt;&lt;x&lt;&lt;endl; return 0;&#125; 高斯消元高斯消元解线性方程组 线性方程组有三种情况的解，先将矩阵化为上三角 如果出现左侧和右侧都是0的行，说明方程组中该方程可以被其他方程表出，故方程组有无穷解 如果出现左侧全为0右侧不为0的行，则方程组无解 否则就是有唯一解，通过初等行变换，高斯消元的方法求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-8;int n;double a[N][N];int gauss() // 高斯消元，答案存于a[i][n]中，0 &lt;= i &lt; n&#123; int c, r; for (c = 0, r = 0; c &lt; n; c ++ )//依次处理吧各列 &#123; int t = r; for (int i = r; i &lt; n; i ++ ) // 找绝对值最大的行 if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue;//如果最大的行都是0，说明全是0，该列无法用于行的固定 for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前行的首位变成1 for (int i = r + 1; i &lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) &gt; eps) for (int j = n; j &gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; &#125; if (r &lt; n)//如果固定的行数小于n，则说明有一些行左侧全是0 &#123; for (int i = r; i &lt; n; i ++ )//检查这些行右边是不是0 if (fabs(a[i][n]) &gt; eps) return 2; // 无解 return 1; // 有无穷多组解 &#125; //求唯一解，需要再化为最简式，即系数矩阵化为单位矩阵 for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n];//第i行需要减的数与第i行的非首位和该首位对应的列的首位有关 return 0; // 有唯一解&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n + 1; j ++ ) scanf(&quot;%lf&quot;, &amp;a[i][j]); int t = gauss(); if (t == 2) puts(&quot;No solution&quot;); else if (t == 1) puts(&quot;Infinite group solutions&quot;); else &#123; for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\\n&quot;, a[i][n]); &#125; return 0;&#125; 求组合数求组合数有多种方式，需要根据题目数据范围来选择合适的做法 求组合数有多种方式，要根据数据的范围选择 求组合数1考虑打表的方式直接弄出来，直接预处理出来每一个数，复杂度O(n^2^) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=2010,mod=1e9+7;int c[N][N];//单独把c_ij处理出来void init()&#123; for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(!j) c[i][j]=1;//边界条件，当j为0时 else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; &#125; &#125;&#125;int main()&#123; int n; init(); scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,c[a][b]); &#125; return 0;&#125; 求组合数2预处理出来阶乘，用公式计算组合数，但是不存在除法分开取模的特征，所以要计算逆元来做，所以预处理出来一个数的阶乘和他的逆元 处理出来数的阶乘，和数的逆元的相乘结果 两个long long级别的数相乘就要mod一次了~，复杂度O(NlogN) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=100010,mod=1e9+7;int fact[N],infact[N];//阶乘和逆元int qmi(int a,int k,int p)//快速幂&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; //预处理出阶乘和逆元 fact[0]=infact[0]=1;//1的阶乘和逆元都是本身 for(int i=1;i&lt;N;i++) &#123; fact[i]=(LL)fact[i-1]*i%mod; infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;//前面那个乘上i的逆元 &#125; int n; int a,b; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod); &#125; return 0;&#125; 求组合数3采用lucus定理来做：AcWing 887. 求组合数 III - AcWing 关键的一步是来凑出b0+b1*p1+…凑出来b 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;typedef long long LL;int qmi(int a,int k,int p)&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL) res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int C(int a,int b,int p)//直接求组合数&#123; if(b&gt;a) return 0; int res=1; for(int i=1,j=a;i&lt;=b;i++,j--) &#123; res=(LL)res*j%p;//a~a-b+1 res=(LL)res*qmi(i,p-2,p)%p;//b的阶乘的逆元 &#125; return res;&#125;int lucas(LL a,LL b,int p)&#123; if(a&lt;p&amp;&amp;b&lt;p) return C(a,b,p);//均不满足则直接求 return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//lucas定理是个递归的过程&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); LL a,b; int p; while(n--) &#123; scanf(&quot;%lld%lld%d&quot;,&amp;a,&amp;b,&amp;p); printf(&quot;%d\\n&quot;,lucas(a,b,p)); &#125; return 0;&#125; 求组合数4要求求准确的解，而不是模一个数，可以直接用公式来计算，涉及到高精度乘法和高精度除法，效率较低 方法是先将C(a,b)分解质因数a!/((a-b)!*(b!))，然后只用高精度乘法来做即可AcWing 888. 求组合数 IV(高精度-素数组合) - AcWing 首先筛1~a之间的所有质数 再求每个质数的次数 用高精度乘法将上述质数乘上 这里计算每个质数的次数的方法如下： 以2为例： 其实代码里面更好理解，就是不断地除p 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N=5010;int primes[N],cnt;int sum[N];bool st[N];void get_primes(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!st[i]) primes[cnt++]=i; for(int j=0;primes[j]&lt;=n/i;j++) &#123; st[primes[j]*i]=true; if(i%primes[j]==0) break; &#125; &#125;&#125;int get(int n,int p)//计算n的阶乘&#123; int res=0; while(n) &#123; res+=n/p; n/=p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a,int b)&#123; vector&lt;int&gt; c; int t=0; for(int i=0;i&lt;a.size();i++) &#123; t+=a[i]*b; c.push_back(t%10); t/=10; &#125; while(t) &#123; c.push_back(t%10); t/=10; &#125; return c;&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; get_primes(a);//求1~a之间的质数 for(int i=0;i&lt;cnt;i++) &#123; int p=primes[i];//第i个质数 sum[i]=get(a,p)-get(a-b,p)-get(b,p);//求这个质数的次数 &#125; vector&lt;int&gt; res; res.push_back(1); for(int i=0;i&lt;cnt;i++) &#123; for(int j=0;j&lt;sum[i];j++) &#123; res=mul(res,primes[i]); &#125; &#125; for(int i=res.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,res[i]); return 0;&#125; 满足条件的01序列参考：AcWing 889. 满足条件的01序列 - AcWing，即求卡特兰数 注意快速幂求逆元的条件，要求mod为质数 问题转换为从0，0走到n，n的满足一定条件的路径，将序列中0看成向右走，1看成向上走，最终走到(n,n)位置，但是题目要求序列前缀中0的个数要不少于1的个数，所以x&gt;=y，也就是说不能碰到红色的线，那如何求碰到红色线的路径数量呢，任何一个碰到红线然后到达(n,n)的路径通过红线进行镜像处理，最终一定会镜像到达(n-1,n+1)这个点的一条路径，所以只需要求出从(0,0)到达(n-1,n+1)这个点的路径数量，然后相减即可 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010,mod=1e9+7;int qmi(int a,int k,int p)&#123; int res=1; while(k) &#123; if(k&amp;1) res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n; cin&gt;&gt;n; int a=n*2,b=n; int res=1; for(int i=a;i&gt;a-b;i--) res=(LL)res*i%mod; for(int i=1;i&lt;=b;i++) res=(LL)res*qmi(i,mod-2,mod)%mod;//逆元 res=(LL)res*qmi(n+1,mod-2,mod)%mod; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 容斥原理 实现的时候以位运算的方式实现，假设有n个数m个类别，则从1~2^m^-1进行枚举，每一位上表示该位上的集合是否取，在枚举的过程中计算上述等式 能被整除的数1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N=20;int p[N];//m个质数int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) cin&gt;&gt;p[i]; int res=0; for(int i=1;i&lt;1&lt;&lt;m;i++)//1~2^m,看做是2进制串 &#123; int t=1,s=0; for(int j=0;j&lt;m;j++)//计算其中1的个数 &#123; if(i&gt;&gt;j&amp;1) &#123; if((LL)t*p[j]&gt;n)//选择的质数不符合要求 &#123; t=-1;//做个标记然后退出循环 break; &#125; t*=p[j]; s++;//集合中元素的数量 &#125; &#125; if(t!=-1) &#123; if(s%2) res+=n/t;//奇数个数为加 else res-=n/t;//偶数个数为减 &#125; &#125; cout&lt;&lt;res; return 0;&#125; 博弈论若一个游戏满足： 由两名玩家交替行动在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关不能行动的玩家判负则称该游戏为一个公平组合游戏。 尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。 Nim游戏ai是每堆中数量 先手必胜状态：先手操作完，可以走到某一个必败状态（给对方留下必败状态）先手必败状态：先手操作完，走不到任何一个必败状态（队首不处于必败态，自己处于）先手必败状态：a1 ^ a2 ^ a3 ^ … ^an = 0先手必胜状态：a1 ^ a2 ^ a3 ^ … ^an ≠ 0 证明： 对于先手，如果遇到全0的局面，则败 如果先手遇到异或不为0的情况，假设异或结果为x，假设x的最高位1所在位为k，则至少存在ai第k位为1，ai异或x&lt;ai,所以在取的过程中可以将ai取为(ai异或x)的状态，因为x是a1~an的异或，将ai取完之后一定能将异或结果转为0，后手必败，先手必胜 如果先手遇到异或为0的情况，则无论怎么取，异或结果都不是0.也就是对手必胜态，反证法：假设取完后异或结果为0，取的项ai变成了ai’,则将前后两次项进行异或：a1\\^a2…\\^ai\\^an ^ a1\\^a2\\^…\\^ai‘\\^an=ai\\^ai’，如果是0，则ai=ai’,则不满足取这一动作，故不可能为0 12345678910111213141516#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int main()&#123; int n,tmp,x=0; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d&quot;,&amp;tmp); x^=tmp; &#125; if(x) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 台阶-Nim游戏如果先手时奇数台阶上的值的异或值为0，则先手必败，反之必胜 注意判断奇数的处理:i&amp;1 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e5+10;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int res=0; for(int i=1;i&lt;=n;i++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(i&amp;1) res^=x;//奇数台阶上的 &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 集合-Nim游戏AcWing 893. 集合-Nim游戏 - AcWing 用到了sg数组，sg数组通过mex函数定义，sg=mex{sg(后继)}，即在后继中未出现的最小的非负整数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;unordered_set&gt;#include &lt;cstring&gt;using namespace std;const int N=110,M=10010;int n,m;int s[N],f[M];//分别存储可拿的石子数量和每堆石子数量//记忆化搜索，注意到相同的x得到的值应该是一样的，sg的树结构画起来是一样的int sg(int x)//根据sg的定义求sg值&#123; if(f[x]!=-1) return f[x];//记忆化搜索 unordered_set&lt;int&gt; S; for(int i=0;i&lt;n;i++)//对每种取法进行讨论 &#123; int sum=s[i]; if(x&gt;=sum) S.insert(sg(x-sum)); &#125; for(int i=0;;i++)//按照sg的定义向后寻找未出现的非0整数 &#123; if(!S.count(i)) return f[x]=i; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;s[i]); scanf(&quot;%d&quot;,&amp;m); memset(f,-1,sizeof f); int res=0; for(int i=0;i&lt;m;i++) &#123; int x; scanf(&quot;%d&quot;,&amp;x);//将每个有向图顶点sg值异或 res^=sg(x); &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 拆分-Nim游戏sg(b1,b2)=sg(b1)$\\and$sg(b2) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unordered_set&gt;using namespace std;const int N=110;int n;int f[N];int sg(int x)&#123; if(f[x]!=-1) return f[x]; unordered_set&lt;int&gt; set; for(int i=0;i&lt;x;i++)//两堆的所有结果 &#123; for(int j=0;j&lt;x;j++) &#123; set.insert(sg(i)^sg(j)); &#125; &#125; for(int i=0;;i++)//按照sg的定义，去mex，未出现的 &#123; if(!set.count(i)) &#123; return f[x]=i; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); memset(f,-1,sizeof f); int res=0; while(n--) &#123; int x; cin&gt;&gt;x; res^=sg(x); &#125; if(res) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 动态规划 DP需要注意初始化——from xiao 背包问题0-1背包问题：每件物品最多使用一次 完全背包问题：每件物品有无限个 多重背包问题：每件物品有s[i]个，有一种优化计算方式 分组背包问题：有多个组，每组里只能选一个 优化和变形都是在原方程基础上进行的等价变形，降维的时候如果用到的是上一层的状态，就要逆序枚举，如果用到的是本层的状态，就要顺序枚举 0-1背包问题 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int V[N],W[N];int n,v;int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=v;j++) &#123; if(j&gt;=V[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-V[i]]+W[i]); else dp[i][j]=dp[i-1][j]; &#125; &#125; cout&lt;&lt;dp[n][v]; return 0;&#125; python 123456789101112131415def main(): n,m = map(int,input().split()) V = [0]*(n+1) W = [0]*(n+1) dp = [[0]*(m+1) for _ in range(n+1)] for i in range(1,n+1): V[i],W[i] = map(int,input().split()) for i in range(1,n+1): for j in range(1,m+1): if j&gt;=V[i]: dp[i][j] = max(dp[i-1][j],dp[i-1][j-V[i]]+W[i]) else: dp[i][j] = dp[i-1][j] print(dp[n][m])main() 降维后 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N=1010;int V[N],W[N];int n,v;int dp[N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=v;j&gt;=V[i];j--)//注意逆序，因为dp[j-v]项需要用到之前的项，如果正序计算，会被提前覆盖 &#123; dp[j]=max(dp[j],dp[j-V[i]]+W[i]); &#125; &#125; cout&lt;&lt;dp[v]; return 0;&#125; python 12345678910111213def main(): n,m = map(int,input().split()) V = [0]*(n+1) W = [0]*(n+1) dp = [0]*(m+1) for i in range(1,n+1): V[i],W[i] = map(int,input().split()) for i in range(1,n+1): for j in range(m,0,-1): if j&gt;=V[i]: dp[j] = max(dp[j],dp[j-V[i]]+W[i]) print(dp[m])main() 完全背包问题每个物品无数个 朴素做法 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int N=1010;int dp[N][N];int n,c;int w[N],v[N];int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=dp[i-1][j]; for(int k=1;k*w[i]&lt;=j;k++)//类似于dp数组的方法来计算 &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]); &#125; &#125; &#125; cout&lt;&lt;dp[n][c]; return 0;&#125; 优化做法：替换公式 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int dp[N][N];int n,c;int w[N],v[N];int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; dp[i][j]=dp[i-1][j]; if(j&gt;=w[i]) dp[i][j]=max(dp[i][j],dp[i][j-w[i]]+v[i]); &#125; &#125; cout&lt;&lt;dp[n][c]; return 0;&#125; 终极优化：替换公式+降维 ，注意是顺序的 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;int f[N];int n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int v,w; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v&gt;&gt;w; for(int j=v;j&lt;=m;j++)//注意这里是顺序的，因为用的j-v是i作为前项的，是更新覆盖之后的 &#123; f[j]=max(f[j],f[j-v]+w); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; python 12345678910111213def main(): n,m = map(int,input().split()) V = [0]*(n+1) W = [0]*(n+1) dp = [0]*(m+1) for i in range(1,n+1): V[i],W[i] = map(int,input().split()) for i in range(1,n+1): for j in range(1,m+1): if j&gt;=V[i]: dp[j] = max(dp[j],dp[j-V[i]]+W[i]) print(dp[m])main() 多重背包问题每个物品有限个，具体有s[i]个 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=110;int n,v;int V[N],S[N],W[N];int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;v; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;S[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=v;j++) &#123; for(int k=0;k&lt;=S[i]&amp;&amp;j&gt;=k*V[i];k++) &#123; dp[i][j]=max(dp[i][j],dp[i-1][j-k*V[i]]+k*W[i]); &#125; &#125; &#125; cout&lt;&lt;dp[n][v]; return 0;&#125; 二进制优化 优化的思想：将第i组可拿的s[i]个物品进行拆分，按照二进制进行打包成一个物品，只需要对拆分后的$log(s)$个物品进行选或者不选，就能等效于对s[i]个物品选的数量，具体将s[i]个物品拆分成: 1 , 2 , 4 , 2^k^ , c ,其中1+2+4+…+2^k^&lt;=s[i]，但k+1次方不满足该条件，c是s[i]-(1+2+4+…+2^k^) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;const int N=20000,M=2010;int V[N],W[N];int n,v;int f[M];int main()&#123; cin&gt;&gt;n&gt;&gt;v; int a,b,s; int cnt=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k=1; while(k&lt;=s) &#123; cnt++; V[cnt]=a*k; W[cnt]=b*k; s=s-k; k=k*2; &#125; if(s&gt;0) &#123; cnt++; V[cnt]=s*a; W[cnt]=s*b; &#125; &#125; n=cnt; for(int i=1;i&lt;=n;i++) &#123; for(int j=v;j&gt;=V[i];j--) &#123; f[j]=max(f[j],f[j-V[i]]+W[i]); &#125; &#125; cout&lt;&lt;f[v];&#125; 分组背包问题分成多个组，每组之中只能选0个或者1个 二维dp： 降维优化： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=110;int n,m;int v[N][N],w[N][N],s[N];int f[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s[i]; for(int j=1;j&lt;=s[i];j++) &#123; cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=m;j&gt;=0;j--) &#123; for(int k=1;k&lt;=s[i];k++) &#123; if(v[i][k]&lt;=j) &#123; f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125; &#125; cout&lt;&lt;f[m]; return 0;&#125; 线性DP线性指递推有个模糊的顺序，如背包问题的二维表从左到右 数字三角形 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510, INF = 1e9;int n;int a[N][N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 0; i &lt;= n; i ++ )//因为递推式需要用到[i-1,j-1]和[i-1,j]项,故需要初始化为负无穷,避免选择该路径 for (int j = 0; j &lt;= i + 1; j ++ ) f[i][j] = -INF; f[1][1] = a[1][1]; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]); int res = -INF; for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[n][i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; 最长上升子序列一 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;const int N=1010;int n;int a[N];int f[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); f[i]=1; &#125; for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;i;j++) &#123; if(a[j]&lt;a[i]) &#123; f[i]=max(f[i],f[j]+1); &#125; &#125; &#125; int res=0; for(int i=1;i&lt;=n;i++) &#123; res=max(res,f[i]); &#125; cout&lt;&lt;res; return 0;&#125; 最长上升子序列贰采用类似单调队列的样子，s[i]存储长度为i的最长上升子序列的最小的末尾元素，可证明s存储的结果一定是严格单调递增的，证明： 假设s[i]=s[i+1],则可知对于长度为i+1的子序列，其最小的末尾元素是s[i+1]，那这个序列的第i个元素一定小于s[i+1]，与s[i]=s[i+1]不符，故可证；若s[i]&gt;s[i+1]，同理可证 所以s数组一定是单调递增的，当插入一个新的数h时，先找到最大的比h小的数s[k]，可知由于s[k]是长度为k的子序列中末尾元素最小的，所以h与该序列拼接可以得到一个长度为k+1的子序列，所以我们需要将其与s[k+1]的大小进行比较，判断是否能替换 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N=1e5+10;int n;int a[N],f[N];int cnt;int find(int x)&#123; int l=1,r=cnt; while(l&lt;r)//等价于找到第一个比x大的进行替换 &#123; int mid=l+r&gt;&gt;1; if(f[mid]&gt;=x) r=mid; else l=mid+1; &#125; return l;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; f[++cnt]=a[1];//从1开始 for(int i=2;i&lt;=n;i++) &#123; if(a[i]&gt;f[cnt]) f[++cnt]=a[i]; else&#123; int idx=find(a[i]);//找到f中第一个大于等于a[i]的用a[i]替换 f[idx]=a[i]; &#125; &#125; cout&lt;&lt;cnt; return 0;&#125; 最长公共子序列书上的解释是： 注意这里的f[i-1,j]是包含01和00的，而不是准确表示出第j个一定选，也就是说f[i-1,j]项与f[i-1,j-1]重叠，但由于求的是max，所以不要求不重复，由于f[i-1,j]和f[i,j-1]包含了f[i-1,j-1]，所以无需再比较f[i-1,j-1] 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N=1010;int n,m;char a[N];char b[N];int f[N][N];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) &#123; f[i][j]=max(f[i][j],f[i-1][j-1]+1); &#125; &#125; &#125; cout&lt;&lt;f[n][m]; return 0;&#125; 编辑距离 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N=1010;int n,m;char a[N],b[N];int dp[N][N];int main()&#123; cin&gt;&gt;n&gt;&gt;a+1; cin&gt;&gt;m&gt;&gt;b+1; for(int i=1;i&lt;=n;i++) dp[i][0]=i; for(int j=1;j&lt;=m;j++) dp[0][j]=j; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1); if(a[i]==b[j]) dp[i][j]=min(dp[i][j],dp[i-1][j-1]); else dp[i][j]=min(dp[i][j],dp[i-1][j-1]+1); &#125; &#125; cout&lt;&lt;dp[n][m]; return 0;&#125; 区间DP区间 DP 常用模版 所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1），从小区间到大区间，以使得大区间能使用小区间的解 模板代码如下： 123456789101112for (int len = 1; len &lt;= n; len++) &#123; // 区间长度 for (int i = 1; i + len - 1 &lt;= n; i++) &#123; // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) &#123; dp[i][j] = 初始值 continue; &#125; for (int k = i; k &lt; j; k++) &#123; // 枚举分割点，构造状态转移方程 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); &#125; &#125;&#125; 如上循环模式是因为要保证计算dp[i][j]时其依赖的较小的区间的dp值已经计算得到了 石子合并 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N=310;int s[N];int f[N][N];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); &#125; for(int i=1;i&lt;=n;i++) s[i]+=s[i-1]; for(int len=2;len&lt;=n;len++) &#123; for(int i=1;i+len-1&lt;=n;i++) &#123; int l=i,r=i+len-1; f[l][r]=1e8; for(int k=l;k&lt;r;k++) &#123; f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); &#125; &#125; &#125; cout&lt;&lt;f[1][n]; return 0;&#125; 计数类DP整数划分问题方法一 转换为完全背包问题，f[i][j]表示用前i个数凑出j的方案数，易知根据最后一个数的多少进行划分计算最后求和 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const int N=1010,mod=1e9+7;int n;int f[N][N];int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) f[i][0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; f[i][j]=f[i-1][j]; for(int k=1;k*i&lt;=j;k++) &#123; f[i][j]=(f[i][j]+f[i-1][j-k*i])%mod; &#125; &#125; &#125; cout&lt;&lt;f[n][n]; return 0;&#125; 利用一下变形 1234567891011121314151617181920212223242526// f[i][j] = f[i - 1][j] + f[i][j - i]#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 7, mod = 1e9 + 7;int f[N][N];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt;= n; i ++) &#123; f[i][0] = 1; // 容量为0时，前 i 个物品全不选也是一种方案 &#125; for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 0; j &lt;= n; j ++) &#123; f[i][j] = f[i - 1][j] % mod; // 特殊 f[0][0] = 1 if (j &gt;= i) f[i][j] = (f[i - 1][j] + f[i][j - i]) % mod; &#125; &#125; cout &lt;&lt; f[n][n] &lt;&lt; endl;&#125; 降维——最终写法： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N=1010,mod=1e9+7;int n;int dp[N];int main()&#123; cin&gt;&gt;n; dp[0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=n;j++) &#123; dp[j]=(dp[j]+dp[j-i])%mod; &#125; &#125; cout&lt;&lt;dp[n]; return 0;&#125; 方法二 状态表示：f[i][j]表示总和为i，总个数为j的方案数 状态转移方程：f[i][j] = f[i - 1][j - 1] + f[i - j][j]; 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main()&#123; cin &gt;&gt; n; f[1][1] = 1; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 数位统计DP计数问题分情况讨论 问题转换为求1~n这些数中数字i出现的次数，假设n一共有7位，如abcdefg，现在我们考虑第4位（d）上数字i出现的次数，我们构造的数为xxxiyyy 若d不为0，xxx取000~abc-1，yyy对于每种xxx的取法都可以取000~999,故为abc*1000 若d为0，则xxx不能取000，因为000 0 123写做123，实际上不会写出这个0，所以这里xxx只能取001~abc-1，yyy取000~999,故为(abc-1)*1000 若XXX取abc，此时若d&gt;i，则yyy可取000~999,故为1000 若XXX取abc，此时若d=i，则yyy可取000~efg，故为efg+1，若d&lt;i不能取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# include &lt;iostream&gt;# include &lt;cmath&gt;using namespace std;int dgt(int n) // 计算整数n有多少位&#123; int res = 0; while (n) ++ res, n /= 10; return res;&#125;int cnt(int n, int i) // 计算从1到n的整数中数字i出现多少次 &#123; int res = 0, d = dgt(n); for (int j = 1; j &lt;= d; ++ j) // 从右到左第j位上 数字i出现多少次 &#123; // l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字 int p = pow(10, j - 1), l = n / p / 10, r = n % p, dj = n / p % 10; // 计算第j位左边的整数小于l (视频中l = 000 ~ abc - 1)的情况 左边不等于abc的时候 说明都是比abc小的数字 if (i) res += l * p; //如果不是统计数字0 左边直接乘p就行了 n=ab3xxx p=1000 //n=1236055 6000-6999这里1000 第j位上的6出现了p次 但是左边还有16000-16999 26000-26999 36000-36999...1226000-1226999 共左边数字l（即123）个 所以是l*p else if (!i &amp;&amp; l) res += (l - 1) * p; // 统计的数字i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1) //少了0000-0999的一种情况 从10000-10999 开始 ... 1220000-1220999 13000-13999 共(l-1)次 // 计算第j位左边的整数等于l (视频中l = abc)的情况 只会和*j位后面的数*有关//下面就是l的左边相等的情况 对第j位上 不会多算6000-6999 ...1226000-1226999里面的任意个集合 123开始的情况 if ( (dj &gt; i) &amp;&amp; (i || l) ) res += p;//第j位比现在统计的数字大 就可以直接加上p中情况 // n=1236055 则有1235000-1235999 999+1种情况 即p种 //当统计的数字i==0 且 l==0， 举例 n=123456 l==0 第j位为1 就是p=100000 此时000000-099999是不成立的 因为我要统计第j位为i的时候 有多少个这样的 数 而此时 000000-099999 显然和 100000-199999 第j-1位为2的时候重复了 if ( (dj == i) &amp;&amp; (i || l) ) res += r + 1;//这是r有多少个 就是多少个+1//if(dj==i) n=1236055 1236000-1236055 即55+1种情况//当统计的数字i==0 且 l==0， 举例 n=123456 l==0且i==0 就是000000 -0123456 而这个时候显然和 第j-1的位的时候重复了100000-109999//if(dj&gt;i) n=1236000 则有1237000-1237999 所以是0 &#125; return res;&#125;int main()&#123; int a, b; while (cin &gt;&gt; a &gt;&gt; b , a) &#123; if (a &gt; b) swap(a, b); for (int i = 0; i &lt;= 9; ++ i) cout &lt;&lt; cnt(b, i) - cnt(a - 1, i) &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; return 0;&#125; 状态压缩DP蒙德里安的梦想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 12, M = 1&lt;&lt; N; long long f[N][M] ;// 第一维表示列， 第二维表示所有可能的状态bool st[M]; //存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。//vector&lt;int &gt; state[M]; //二维数组记录合法的状态vector&lt;vector&lt;int&gt;&gt; state(M); //两种写法等价:二维数组int m, n;int main() &#123; while (cin &gt;&gt; n &gt;&gt; m, n || m) &#123; //读入n和m，并且不是两个0即合法输入就继续读入 //第一部分：预处理1 //对于每种状态，先预处理每列不能有奇数个连续的0 for(int i = 0; i &lt; (1 &lt;&lt; n); i ++) &#123; int cnt = 0 ;//记录连续的0的个数 bool isValid = true; // 某种状态没有奇数个连续的0则标记为true for(int j = 0; j &lt; n; j ++) &#123; //遍历这一列，从上到下 if ( (i &gt;&gt; j) &amp; 1) &#123; //i &gt;&gt; j位运算，表示i（i在此处是一种状态）的二进制数的第j位； // &amp;1为判断该位是否为1，如果为1进入if if (cnt &amp; 1) &#123; //这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法 isValid =false; break; &#125; cnt = 0; // 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。 //其实清不清零没有影响 &#125; else cnt ++; //否则的话该位还是0，则统计连续0的计数器++。 &#125; if (cnt &amp; 1) isValid = false; //最下面的那一段判断一下连续的0的个数 st[i] = isValid; //状态i是否有奇数个连续的0的情况,输入到数组st中 &#125; //第二部分：预处理2 // 经过上面每种状态 连续0的判断，已经筛掉一些状态。 //下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突 for (int j = 0; j &lt; (1 &lt;&lt; n); j ++) &#123; //对于第i列的所有状态 state[j].clear(); //清空上次操作遗留的状态，防止影响本次状态。 for (int k = 0; k &lt; (1 &lt;&lt; n); k ++) &#123; //对于第i-1列所有状态 if ((j &amp; k ) == 0 &amp;&amp; st[ j | k]) // 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) //解释一下st[j | k] //已经知道st[]数组表示的是这一列没有连续奇数个0的情况， //我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的， //还要考虑自己这一列（i-1列）横插到第i列的 //比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000， //那么合在第i-1列，到底有多少个1呢？ //自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101 //这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的 state[j].push_back(k); //二维数组state[j]表示第j行， //j表示 第i列“真正”可行的状态， //如果第i-1列的状态k和j不冲突则压入state数组中的第j行。 //“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。 &#125; &#125; //第三部分：dp开始 memset(f, 0, sizeof f); //全部初始化为0，因为是连续读入，这里是一个清空操作。 //类似上面的state[j].clear() f[0][0] = 1 ;// 这里需要回忆状态表示的定义 //按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。 //首先，这里没有-1列，最少也是0列。 //其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。 for (int i = 1; i &lt;= m; i ++) &#123; //遍历每一列:第i列合法范围是(0~m-1列) for (int j = 0; j &lt; (1&lt;&lt;n); j ++) &#123; //遍历当前列（第i列）所有状态j for (auto k : state[j]) // 遍历第i-1列的状态k，如果“真正”可行，就转移 f[i][j] += f[i-1][k]; // 当前列的方案数就等于之前的第i-1列所有状态k的累加。 &#125; &#125; //最后答案是什么呢？ //f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。 //即整个棋盘处理完的方案数 cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125;&#125; 最短Hamilton路径 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=20,M=1&lt;&lt;N;int f[M][N],w[N][N];//w表示的是无权图int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;w[i][j]; memset(f,0x3f,sizeof(f));//因为要求最小值，所以初始化为无穷大 f[1][0]=0;//因为零是起点,所以f[1][0]=0; for(int i=0;i&lt;1&lt;&lt;n;i++)//i表示所有的情况 for(int j=0;j&lt;n;j++)//j表示走到哪一个点 if(i&gt;&gt;j&amp;1) for(int k=0;k&lt;n;k++)//k表示走到j这个点之前,以k为终点的最短距离 if(i&gt;&gt;k&amp;1) f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//更新最短距离 cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//表示所有点都走过了,且终点是n-1的最短距离 //位运算的优先级低于&#x27;+&#x27;-&#x27;所以有必要的情况下要打括号 return 0;&#125; 记忆化搜索滑雪 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=310;int n,m;int h[N][N];int f[N][N];int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;int dp(int x,int y)//求f[x][y]&#123; if(f[x][y]!=-1) return f[x][y]; f[x][y]=1;//注意这个初始化 for(int i=0;i&lt;4;i++) &#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[x][y]&gt;h[a][b]) &#123; f[x][y]=max(f[x][y],dp(a,b)+1); &#125; &#125; return f[x][y];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;h[i][j]; &#125; &#125; memset(f,-1,sizeof(f));//做下标记 int res=0; for(int i=1;i&lt;=n;i++)//遍历搜索最大值 &#123; for(int j=1;j&lt;=m;j++) &#123; res=max(res,dp(i,j)); &#125; &#125; cout&lt;&lt;res; return 0;&#125; 贪心区间问题区间贪心讨论按左端点、右端点排序，然后依次枚举每个区间 区间选点将每个区间按照右端点从小到大进行排序 从前往后枚举区间，end值初始化为无穷小 如果本次区间不能覆盖掉上次区间的右端点， ed &lt; range[i].l 说明需要选择一个新的点， res ++ ; ed = range[i].r; 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const//按照右端点排序 &#123; return r&lt;W.r; &#125;&#125;range[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;range[i].l,&amp;range[i].r); sort(range,range+n); int res=0,ed=-2e9;//ed是上一个点的下标 for(int i=0;i&lt;n;i++) &#123; if(range[i].l&gt;ed) &#123; res++; ed=range[i].r; &#125; &#125; printf(&quot;%d&quot;,res); return 0;&#125; 最大不相交区间个数和上一题代码是一样的 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const//按照右端点排序 &#123; return r&lt;W.r; &#125;&#125;range[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;range[i].l,&amp;range[i].r); sort(range,range+n); int res=0,ed=-2e9;//ed是上一个点的下标 for(int i=0;i&lt;n;i++) &#123; if(range[i].l&gt;ed) &#123; res++; ed=range[i].r; &#125; &#125; printf(&quot;%d&quot;,res); return 0;&#125; 区间分组 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=100010;int n;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const &#123; return l&lt;W.l; &#125;&#125;ranges[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;ranges[i].l,&amp;ranges[i].r); &#125; sort(ranges,ranges+n); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;heap;//小根堆 for(int i=0;i&lt;n;i++) &#123; auto r=ranges[i]; if(heap.empty()||heap.top()&gt;=r.l) heap.push(r.r);//如果空或者没有一个区间可以容纳 else&#123; heap.pop(); heap.push(r.r); &#125; &#125; printf(&quot;%d&quot;,heap.size()); return 0;&#125; 区间覆盖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;struct Range&#123; int l,r; bool operator&lt;(const Range&amp;W)const &#123; return l&lt;W.l; &#125;&#125;ranges[N];int main()&#123; int st,ed; scanf(&quot;%d%d&quot;,&amp;st,&amp;ed); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;ranges[i].l,&amp;ranges[i].r); &#125; sort(ranges,ranges+n); int res=0; bool suc=false; for(int i=0;i&lt;n;i++) &#123; int j=i,r=-2e9; while(j&lt;n&amp;&amp;ranges[j].l&lt;=st) &#123; r=max(r,ranges[j].r); j++; &#125; if(r&lt;st) &#123; res=-1; break; &#125; res++; if(r&gt;=ed) &#123; suc=true; break; &#125; st=r; i=j-1; &#125; if(suc) &#123; printf(&quot;%d&quot;,res); &#125;else printf(&quot;-1&quot;); return 0;&#125; Huffman树合并果子1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;heap; while(n--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); heap.push(x); &#125; int res=0; while(heap.size()&gt;1) &#123; int a=heap.top();heap.pop(); int b=heap.top();heap.pop(); res+=(a+b); heap.push(a+b); &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 排序不等式排队打水，护航问题 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010;int n;int t[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;t[i]); sort(t,t+n); reverse(t,t+n); LL res=0; for(int i=0;i&lt;n;i++) res+=t[i]*i; printf(&quot;%lld\\n&quot;,res); return 0;&#125; 绝对值不等式货仓选址12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;int q[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]); sort(q,q+n); int res=0; for(int i=0;i&lt;n;i++) res+=abs(q[i]-q[n/2]); printf(&quot;%d\\n&quot;,res); return 0;&#125; 推公式耍杂技的牛123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt;PII;const int N=50010;int n;PII cow[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; int s,w; scanf(&quot;%d%d&quot;,&amp;w,&amp;s); cow[i]=&#123;w+s,w&#125;; &#125; sort(cow,cow+n); int res=-2e9,sum=0; for(int i=0;i&lt;n;i++) &#123; int s=cow[i].first-cow[i].second,w=cow[i].second; res=max(res,sum-s); sum+=w; &#125; printf(&quot;%d&quot;,res); return 0;&#125; 算法复习attention： 归并排序的扫尾工作 回溯法 递归&amp;&amp;子集树框架123456789101112131415161718void backtrack(int t)&#123; if(t&gt;n) output(); else&#123; compute()//判断所需变量的计算 if(constraint(t))//约束函数 &#123; changestate(); backtrack(t+1); stateback(); &#125; if(bound(t)) &#123; backtrack(t+1); &#125; compute_back()//判断所需变量的计算 &#125;&#125; 迭代框架12345678910111213141516171819void backtrack(void)&#123; int t=1; while(t&gt;0) &#123; if(f(n,t)&lt;g(n,t)) &#123; for(int i=f(n,t);i&lt;=g(n,t);i++) &#123; if(constraint(t)&amp;&amp;bound(t)) &#123; if(solution(t)) output(); else t++; &#125; &#125; &#125; else t--; &#125;&#125; 排列树框架12345678910111213141516void backtrack(int t)&#123; if(t&gt;n) output(); else for(int i=t;i&lt;=n;i++) &#123; if(constraint(t)&amp;&amp;bound(t)) &#123; swap(x[i],x[t]); changestate(); backtrack(t+1); changestate(); swap(x[i],x[t]); &#125; &#125;&#125; 装载问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int n;int cw=0,cbest=0;int r;int c1,c2;int x[100];int bestx[100];int w[100];void backtrack(int t)&#123; if(t&gt;n) &#123; if(cw&gt;cbest) &#123; for(int i=1;i&lt;=n;i++) bestx[i]=x[i]; cbest=cw; &#125; return; &#125; r-=w[t]; if(cw+w[t]&lt;=c1) &#123; x[t]=1; cw+=w[t]; backtrack(t+1); x[t]=0; cw-=w[t]; &#125; if(cw+r&gt;cbest) &#123; x[t]=0; backtrack(t+1); &#125; r+=w[t];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c1; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]; r+=w[i]; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; return 0;&#125; input 124 10090 10 80 10 python 1234567891011121314151617181920212223242526272829303132333435n = 0c = 0w = [0]*100x = [0]*100bestx = [0]*100cbest = 0cw = 0r = 0def backtrack(t): global cw,cbest,x,bestx,r if t&gt;n: if cw&gt;cbest: bestx = x.copy() cbest = cw return r -= w[t] if cw+w[t]&lt;= c: x[t] = 1 cw+=w[t] backtrack(t+1) x[t] = 0 cw-=w[t] if cw+r&gt;cbest: x[t] = 0 backtrack(t+1) r += w[t]def main(): global n,c,w,r n,c = map(int,input().split()) w[1:n+1] = list(map(int,input().split())) r = sum(w[1:n+1]) backtrack(1) print(cbest) print(bestx[1:n+1])main() 批处理作业调度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;const int N=1010;int M[N][N];int x[N];int bestx[N];int f1,f2[N];int bestf=1000000,n,f;void backtrack(int t)&#123; if(t&gt;n) &#123; if(f&lt;bestf) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; bestf=f; &#125; return; &#125; for(int i=t;i&lt;=n;i++) &#123; f1+=M[x[i]][1];//在swap前，提前使用j f2[t]=((f2[t-1]&gt;f1)?f2[t-1]:f1)+M[x[i]][2]; f+=f2[t]; if(f&lt;bestf) &#123; swap(x[i],x[t]); backtrack(t+1); swap(x[i],x[t]); &#125; f1-=M[x[i]][1]; f-=f2[t]; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;M[i][1]&gt;&gt;M[i][2];//第i个作业在某台机器上 &#125; for(int i=1;i&lt;=n;i++) x[i]=i; backtrack(1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;bestx[i]&gt;&gt;&quot; &quot;; cout&lt;&lt;endl; cout&lt;&lt;bestf; return 0;&#125; input： 123432 13 12 3 八皇后问题1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int N=1010;int x[N];int sum,n;bool place(int t)&#123; for(int j=1;j&lt;t;j++) &#123; if(abs(j-t)==abs(x[j]-x[t])) return false; &#125; return true;&#125;void backtrack(int t)&#123; if(t&gt;n) &#123; sum++; return; &#125; for(int i=t;i&lt;=n;i++) &#123; swap(x[i],x[t]); if(place(t)) backtrack(t+1); swap(x[i],x[t]); &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; x[i]=i; &#125; backtrack(1); cout&lt;&lt;sum; return 0;&#125; input 128output 92 0-1背包问题简化版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int N=1010;int x[N],bestx[N];int bestv,cv;int cw,r;int w[N],v[N];int c,n;void backtrack(int t)&#123; if(t&gt;n) &#123; if(cv&gt;bestv) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; bestv=cv; &#125; return; &#125; r-=v[t]; if(cw+w[t]&lt;=c) &#123; x[t]=1; cv+=v[t]; cw+=w[t]; backtrack(t+1); x[t]=0; cv-=v[t]; cw-=w[t]; &#125; if(cv+r&gt;bestv) &#123; x[t]=0; backtrack(t+1); &#125; r+=v[t];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;c; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;w[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;v[i]; r+=v[i]; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;bestv; return 0;&#125; 最大团问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;const int N=1010;int G[N][N];int x[N],bestx[N];int r,cbest,cv;int n,m;bool choose(int t)&#123; for(int i=1;i&lt;t;i++) &#123; if(x[i]==1&amp;&amp;G[i][t]==0) return false; &#125; return true;&#125;void backtrack(int t)&#123; if(t&gt;n) &#123; if(cv&gt;cbest) &#123; for(int i=1;i&lt;=n;i++) &#123; bestx[i]=x[i]; &#125; cbest=cv; &#125; return; &#125; r--; if(choose(t)) &#123; cv++; x[t]=1; backtrack(t+1); cv--; x[t]=0; &#125; if(cv+r&gt;cbest) &#123; x[t]=0; backtrack(t+1); &#125; r++;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m;//顶点和边数 r=n; int u,v; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;u&gt;&gt;v; G[u][v]=1; G[v][u]=1; &#125; backtrack(1); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;cbest; return 0;&#125; input 123456785 71 21 41 52 52 33 54 5 TSP问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N=1010;int G[N][N];int x[N],bestx[N];int cbest=1000000,cw;int n;void backtrack(int t)&#123; if(t==n) &#123; if(G[x[n]][x[n-1]]&gt;0&amp;&amp;G[x[n]][1]&gt;0&amp;&amp;(cw+G[x[n]][x[n-1]]+G[x[n]][1]&lt;cbest)) &#123; for(int j=1;j&lt;=n;j++) &#123; bestx[j]=x[j]; &#125; cbest=cw+G[x[n]][x[n-1]]+G[x[n]][1]; &#125; return; &#125; for(int i=t;i&lt;=n;i++) &#123; if(G[x[t-1]][x[i]]&gt;0&amp;&amp;(cw+G[x[t-1]][x[i]]&lt;cbest)) &#123; swap(x[i],x[t]); cw+=G[x[t-1]][x[t]]; backtrack(t+1); cw-=G[x[t-1]][x[t]]; swap(x[i],x[t]); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;G[i][j]; &#125; x[i]=i; &#125; backtrack(2); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;bestx[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt;cbest; return 0;&#125; input 123454-1 30 6 430 -1 5 106 5 -1 204 10 20 -1 随机化算法数值随机化算法 投点法计算π：设有一半径为r的圆及其外切四边形，向该正方形随机地投掷n个点，设落入圆内的点数为k，由于所投入的点再正方形上均匀分布，故落入圆中的点的概率为。。，当n足够大时，k与n的比就逼近这一概率，故π=。。。 计算定积分：向单位正方形内随机地投n个点，如果有m个点落入G内，由于所投点均匀地分布在正方形上，故当n足够，可近似计算G为 解线性方程组，","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"}]}],"categories":[],"tags":[{"name":"LLM","slug":"LLM","permalink":"https://leungto.github.io/tags/LLM/"},{"name":"NL2SQL","slug":"NL2SQL","permalink":"https://leungto.github.io/tags/NL2SQL/"},{"name":"algorithm","slug":"algorithm","permalink":"https://leungto.github.io/tags/algorithm/"},{"name":"DL","slug":"DL","permalink":"https://leungto.github.io/tags/DL/"}]}