<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NLP入门</title>
    <url>/2024/04/05/NLP%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<span id="more"></span>
<blockquote>
<p>总结</p>
</blockquote>
<p>Python&amp;Pytorch</p>
<ul>
<li>python基础教程</li>
<li>python自然语言实战</li>
<li>pytorch深度学习实践</li>
</ul>
<p>Deep Learning </p>
<ul>
<li>吴恩达深度学习</li>
<li>实践：李沐/B站视频</li>
</ul>
<p>NLP</p>
<ul>
<li>CS224n</li>
</ul>
<blockquote>
<p>信息</p>
</blockquote>
<p>1.机器学习，看《机器学习实战》Peter Harrington著，并复现书中代码。</p>
<p>2.深度学习理论，看斋藤康毅的《深度学习入门——基于python的理论与实现》，并复现代码</p>
<p>3.PyTorch框架，看《Python深度学习基于Pytorch》<a href="https://www.zhihu.com/search?q=吴茂贵&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A&quot;3011738324&quot;}">吴茂贵</a>著，并复现代码。</p>
<p>4.深度学习进阶自然语言处理，看斋藤康毅的《深度学习进阶自然语言处理》，并复现代码。</p>
<p>5.看顶会顶刊论文，复现代码。如：CVPR，NIPS，AAAI，ICCV，ECCV等。</p>
<p><a href="https://blog.csdn.net/weixin_42599499/article/details/103476376">NLP算法学习路线-自己整理_nlp入门学习路线教程地址-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>NL2SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NN zero to hero (P1): micrograd</title>
    <url>/2025/04/27/NN-zero-to-hero-P1-micrograd/</url>
    <content><![CDATA[<span id="more"></span>
<blockquote>
<p><a href="https://github.com/karpathy/nn-zero-to-hero/tree/master">karpathy/nn-zero-to-hero: Neural Networks: Zero to Hero</a></p>
</blockquote>
<h3 id="1-导数-slope"><a href="#1-导数-slope" class="headerlink" title="1.导数 slope"></a>1.导数 slope</h3><p>通过下面的方法可求得导数，即(f(x+h)-f(x))/h  h趋于0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inputs</span></span><br><span class="line">a = <span class="number">2.0</span></span><br><span class="line">b = -<span class="number">3.0</span></span><br><span class="line">c = <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line">d1 = a*b + c</span><br><span class="line">c += h</span><br><span class="line">d2 = a*b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d1&#x27;</span>, d1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d2&#x27;</span>, d2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;slope&#x27;</span>, (d2 - d1)/h)</span><br></pre></td></tr></table></figure>
<h3 id="2-前向传播"><a href="#2-前向传播" class="headerlink" title="2.前向传播"></a>2.前向传播</h3><p>如果只考虑前向传播，代码的逻辑只是做类的封装，把原有的数据封装到新的<code>Value</code>类中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data + other.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data * other.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.data</span><br><span class="line">        t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = Value(<span class="number">2.0</span>)</span><br><span class="line">    b = Value(-<span class="number">3.0</span>)</span><br><span class="line">    c = Value(<span class="number">10.0</span>)</span><br><span class="line">    d = a*b + c; </span><br><span class="line">    f = Value(-<span class="number">2.0</span>)</span><br><span class="line">    L = d * f</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>为了便于之后的反向传播，我们还需要记录某个节点由哪些节点生成、以及是如何生成的，加上<code>_prev</code>属性，对应<code>_children</code>元组，表示由哪些节点操作而成，操作用<code>op</code>记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, _children=(<span class="params"></span>), _op=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self._prev = <span class="built_in">set</span>(_children) <span class="comment">#为了性能用的set</span></span><br><span class="line">        self._op = _op</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data + other.data, (self, other), <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data * other.data, (self, other), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.data</span><br><span class="line">        t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span> ,(self, ), <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = Value(<span class="number">2.0</span>)</span><br><span class="line">    b = Value(-<span class="number">3.0</span>)</span><br><span class="line">    c = Value(<span class="number">10.0</span>)</span><br><span class="line">    d = a*b + c; </span><br><span class="line">    f = Value(-<span class="number">2.0</span>)</span><br><span class="line">    L = d * f</span><br><span class="line">    draw_dot(L)</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>用<code>graphviz</code>可视化整个前向传播的过程，为了方便查看加上<code>label</code>变量，并对中间的变量进行了定义<code>e</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两个函数直接用，是用来可视化的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">root</span>):</span><br><span class="line">  <span class="comment"># builds a set of all nodes and edges in a graph</span></span><br><span class="line">  nodes, edges = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> nodes:</span><br><span class="line">      nodes.add(v)</span><br><span class="line">      <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">        edges.add((child, v))</span><br><span class="line">        build(child)</span><br><span class="line">  build(root)</span><br><span class="line">  <span class="keyword">return</span> nodes, edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_dot</span>(<span class="params">root</span>):</span><br><span class="line">  dot = Digraph(<span class="built_in">format</span>=<span class="string">&#x27;svg&#x27;</span>, graph_attr=&#123;<span class="string">&#x27;rankdir&#x27;</span>: <span class="string">&#x27;LR&#x27;</span>&#125;) <span class="comment"># LR = left to right</span></span><br><span class="line">  </span><br><span class="line">  nodes, edges = trace(root)</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">    uid = <span class="built_in">str</span>(<span class="built_in">id</span>(n))</span><br><span class="line">    <span class="comment"># for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it</span></span><br><span class="line">    dot.node(name = uid, label = <span class="string">&quot;&#123; %s | %.4f &#125;&quot;</span> % (n.label, n.data), shape=<span class="string">&#x27;record&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> n._op:</span><br><span class="line">      <span class="comment"># if this value is a result of some operation, create an op node for it</span></span><br><span class="line">      dot.node(name = uid + n._op, label = n._op)</span><br><span class="line">      <span class="comment"># and connect this node to it</span></span><br><span class="line">      dot.edge(uid + n._op, uid)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> n1, n2 <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="comment"># connect n1 to the op node of n2</span></span><br><span class="line">    dot.edge(<span class="built_in">str</span>(<span class="built_in">id</span>(n1)), <span class="built_in">str</span>(<span class="built_in">id</span>(n2)) + n2._op)</span><br><span class="line">  dot.save(<span class="string">&#x27;output.dot&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> dot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, _children=(<span class="params"></span>), _op=<span class="string">&#x27;&#x27;</span>, label=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self._prev = <span class="built_in">set</span>(_children) <span class="comment">#为了性能用的set</span></span><br><span class="line">        self._op = _op</span><br><span class="line">        self.label = label</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data + other.data, (self, other), <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Value(self.data * other.data, (self, other), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.data</span><br><span class="line">        t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span> ,(self, ), <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = Value(<span class="number">2.0</span>, label=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = Value(-<span class="number">3.0</span>, label=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    c = Value(<span class="number">10.0</span>, label=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    e = a*b; e.label = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">    d = e + c; d.label = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    f = Value(-<span class="number">2.0</span>, label=<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    L = d * f; L.label = <span class="string">&#x27;L&#x27;</span></span><br><span class="line">    draw_dot(L)</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/27/NN-zero-to-hero-P1-micrograd/image-20250428144750866.png" alt="image-20250428144750866"></p>
<p>这样我们就得到了一张不含梯度的计算图</p>
<h3 id="3-加入梯度"><a href="#3-加入梯度" class="headerlink" title="3.加入梯度"></a>3.加入梯度</h3><p>下面加入梯度（dL/dx,x当前的变量），根据链式法则，我们实际上不需要按照1中的求导方法</p>
<p><img src="/2025/04/27/NN-zero-to-hero-P1-micrograd/image-20250428144750866.png" alt="image-20250428144750866"></p>
<p>比如L的梯度就是1，因为<code>dL/dL = 1</code>,然后计算f和d，因为<code>L=f*d</code>，所以<code>dL/df = d</code>，所以<code>f.grad=4</code>,<code>d.grad=-2</code>,然后求<code>dL/dc</code>，根据链式法则，<code>dL/dc = (dL/dd) * (dd/dc) = -2*(dd/dc)</code>，因为是加法，所以<code>dd/dc = 1</code>，所以<code>dL/dc = -2</code>，同理<code>dL/de=-2</code>(由此可以看出，如果操作是<code>+</code>，那么操作数的梯度等于该操作结果的梯度,这里可能有点小问题，暂时这样看)，继续 <code>dL/da = dL/de * de/da = -2*(de/da)</code>，因为<code>e = a*b</code>, 所以<code>de/da = b =-3</code>，所以<code>dL/da = 6</code>，同理<code>dL/db = -4</code>（可以看出如果操作是<code>*</code>，操作数的梯度等于该操作结果的梯度乘以另外一个操作数）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>variable</th>
<th>grad</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>6</td>
</tr>
<tr>
<td>b</td>
<td>-4</td>
</tr>
<tr>
<td>c</td>
<td>-2</td>
</tr>
<tr>
<td>e</td>
<td>-2</td>
</tr>
<tr>
<td>f</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>-2</td>
</tr>
<tr>
<td>L</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>按照类似上面的做法，加入<code>grad</code>，每个操作在做前向传播的时候给out记录下反向传播时如何给操作节点分配梯度，在做完前向传播后，对节点进行拓扑排序，然后设置最终结果的<code>grad</code>为1，反转拓扑排序得到的列表，调用节点自己的<code>_backward</code>函数进行梯度的反向传播</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">root</span>):</span><br><span class="line">  <span class="comment"># builds a set of all nodes and edges in a graph</span></span><br><span class="line">  nodes, edges = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> nodes:</span><br><span class="line">      nodes.add(v)</span><br><span class="line">      <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">        edges.add((child, v))</span><br><span class="line">        build(child)</span><br><span class="line">  build(root)</span><br><span class="line">  <span class="keyword">return</span> nodes, edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_dot</span>(<span class="params">root</span>):</span><br><span class="line">  dot = Digraph(<span class="built_in">format</span>=<span class="string">&#x27;svg&#x27;</span>, graph_attr=&#123;<span class="string">&#x27;rankdir&#x27;</span>: <span class="string">&#x27;LR&#x27;</span>&#125;) <span class="comment"># LR = left to right</span></span><br><span class="line">  </span><br><span class="line">  nodes, edges = trace(root)</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">    uid = <span class="built_in">str</span>(<span class="built_in">id</span>(n))</span><br><span class="line">    <span class="comment"># for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it</span></span><br><span class="line">    dot.node(name = uid, label = <span class="string">&quot;&#123; %s | %.4f | grad %.4f &#125;&quot;</span> % (n.label, n.data, n.grad), shape=<span class="string">&#x27;record&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> n._op:</span><br><span class="line">      <span class="comment"># if this value is a result of some operation, create an op node for it</span></span><br><span class="line">      dot.node(name = uid + n._op, label = n._op)</span><br><span class="line">      <span class="comment"># and connect this node to it</span></span><br><span class="line">      dot.edge(uid + n._op, uid)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> n1, n2 <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="comment"># connect n1 to the op node of n2</span></span><br><span class="line">    dot.edge(<span class="built_in">str</span>(<span class="built_in">id</span>(n1)), <span class="built_in">str</span>(<span class="built_in">id</span>(n2)) + n2._op)</span><br><span class="line">  dot.save(<span class="string">&#x27;output.dot&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> dot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, _children=(<span class="params"></span>), _op=<span class="string">&#x27;&#x27;</span>, label=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self._prev = <span class="built_in">set</span>(_children) <span class="comment">#为了性能用的set</span></span><br><span class="line">        self._op = _op</span><br><span class="line">        self.label = label</span><br><span class="line">        self.grad = <span class="number">0.0</span></span><br><span class="line">        self._backward = <span class="keyword">lambda</span>: <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        out = Value(self.data + other.data, (self, other), <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">           self.grad = <span class="number">1.0</span> * out.grad</span><br><span class="line">           other.grad = <span class="number">1.0</span> * out.grad</span><br><span class="line">        out._backward = _backward</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        out = Value(self.data * other.data, (self, other), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">           self.grad = out.grad * other.data</span><br><span class="line">           other.grad = out.grad * self.data</span><br><span class="line">        out._backward = _backward</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.data</span><br><span class="line">        t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span>)</span><br><span class="line">        out = Value(t,(self, ), <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">           self.grad = (<span class="number">1</span> - t**<span class="number">2</span>) * out.grad</span><br><span class="line">        out._backward = _backward</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="comment"># 首先拓扑排序得到操作数-&gt;最终结果节点的列表</span></span><br><span class="line">      topo = []</span><br><span class="line">      visited = <span class="built_in">set</span>()</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">build_topo</span>(<span class="params">v</span>):</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">          visited.add(v)</span><br><span class="line">          <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">            build_topo(child)</span><br><span class="line">          topo.append(v)</span><br><span class="line">      build_topo(self)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 设置最终结果的grad为1，然后翻转列表调用_backward进行反向传播</span></span><br><span class="line">      self.grad = <span class="number">1.0</span></span><br><span class="line">      <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">reversed</span>(topo):</span><br><span class="line">        node._backward()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = Value(<span class="number">2.0</span>, label=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = Value(-<span class="number">3.0</span>, label=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    c = Value(<span class="number">10.0</span>, label=<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    e = a*b; e.label = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">    d = e + c; d.label = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    f = Value(-<span class="number">2.0</span>, label=<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    L = d * f; L.label = <span class="string">&#x27;L&#x27;</span></span><br><span class="line">    L.backward()</span><br><span class="line">    draw_dot(L)</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/27/NN-zero-to-hero-P1-micrograd/image-20250428155008057.png" alt="image-20250428155008057"></p>
<p>这里有个小问题，对于下面的两个实例，上述代码是有误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = Value(<span class="number">3.0</span>, label=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = a + a   ; b.label = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">b.backward()</span><br><span class="line">draw_dot(b)</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/27/NN-zero-to-hero-P1-micrograd/image-20250428155757165.png" alt="image-20250428155757165"></p>
<p>这里在做反向传播的时候，给a的梯度赋了两次值，第二次的grad=1覆盖了第一次的grad=1，而不是累加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = Value(-<span class="number">2.0</span>, label=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = Value(<span class="number">3.0</span>, label=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">d = a * b    ; d.label = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">e = a + b    ; e.label = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">f = d * e    ; f.label = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"></span><br><span class="line">f.backward()</span><br><span class="line"></span><br><span class="line">draw_dot(f)</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/27/NN-zero-to-hero-P1-micrograd/image-20250428160213646.png" alt="image-20250428160213646"></p>
<p>这种也是被覆盖了，所以梯度的计算应该是累积的，之前的<code>=</code>要改成<code>+=</code>，此外考虑一些其他的基本操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, _children=(<span class="params"></span>), _op=<span class="string">&#x27;&#x27;</span>, label=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    self.data = data</span><br><span class="line">    self.grad = <span class="number">0.0</span></span><br><span class="line">    self._backward = <span class="keyword">lambda</span>: <span class="literal">None</span></span><br><span class="line">    self._prev = <span class="built_in">set</span>(_children)</span><br><span class="line">    self._op = _op</span><br><span class="line">    self.label = label</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">    other = other <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Value) <span class="keyword">else</span> Value(other)</span><br><span class="line">    out = Value(self.data + other.data, (self, other), <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += <span class="number">1.0</span> * out.grad</span><br><span class="line">      other.grad += <span class="number">1.0</span> * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">    other = other <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Value) <span class="keyword">else</span> Value(other)</span><br><span class="line">    out = Value(self.data * other.data, (self, other), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += other.data * out.grad</span><br><span class="line">      other.grad += self.data * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)), <span class="string">&quot;only supporting int/float powers for now&quot;</span></span><br><span class="line">    out = Value(self.data**other, (self,), <span class="string">f&#x27;**<span class="subst">&#123;other&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">        self.grad += other * (self.data ** (other - <span class="number">1</span>)) * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__rmul__</span>(<span class="params">self, other</span>): <span class="comment"># other * self</span></span><br><span class="line">    <span class="keyword">return</span> self * other</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__truediv__</span>(<span class="params">self, other</span>): <span class="comment"># self / other</span></span><br><span class="line">    <span class="keyword">return</span> self * other**-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__neg__</span>(<span class="params">self</span>): <span class="comment"># -self</span></span><br><span class="line">    <span class="keyword">return</span> self * -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>): <span class="comment"># self - other</span></span><br><span class="line">    <span class="keyword">return</span> self + (-other)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>): <span class="comment"># other + self</span></span><br><span class="line">    <span class="keyword">return</span> self + other</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.data</span><br><span class="line">    t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span>)</span><br><span class="line">    out = Value(t, (self, ), <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += (<span class="number">1</span> - t**<span class="number">2</span>) * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.data</span><br><span class="line">    out = Value(math.exp(x), (self, ), <span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += out.data * out.grad <span class="comment"># <span class="doctag">NOTE:</span> in the video I incorrectly used = instead of +=. Fixed here.</span></span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">    </span><br><span class="line">    topo = []</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_topo</span>(<span class="params">v</span>):</span><br><span class="line">      <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">        visited.add(v)</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">          build_topo(child)</span><br><span class="line">        topo.append(v)</span><br><span class="line">    build_topo(self)</span><br><span class="line">    </span><br><span class="line">    self.grad = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">reversed</span>(topo):</span><br><span class="line">      node._backward()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-从神经元到MLP"><a href="#4-从神经元到MLP" class="headerlink" title="4.从神经元到MLP"></a>4.从神经元到MLP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin</span>):</span><br><span class="line">    self.w = [Value(random.uniform(-<span class="number">1</span>,<span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nin)]</span><br><span class="line">    self.b = Value(random.uniform(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    act = <span class="built_in">sum</span>((wi*xi <span class="keyword">for</span> wi,xi <span class="keyword">in</span> <span class="built_in">zip</span>(self.w,x)), self.b)</span><br><span class="line">    out = act.tanh()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.w + [self.b]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">  <span class="comment"># n个神经元组成的一层</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin, nout</span>):</span><br><span class="line">    self.neurons = [Neuron(nin) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nout)]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    outs = [n(x) <span class="keyword">for</span> n <span class="keyword">in</span> self.neurons]</span><br><span class="line">    <span class="keyword">return</span> outs[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(outs) == <span class="number">1</span> <span class="keyword">else</span> outs</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> [p <span class="keyword">for</span> neuron <span class="keyword">in</span> self.neurons <span class="keyword">for</span> p <span class="keyword">in</span> neuron.parameters()]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>:</span><br><span class="line"><span class="comment"># MLP多层感知机, nin是输入的维度，nouts是个列表，记录每层的输出维度</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin, nouts</span>):</span><br><span class="line">    sz = [nin] + nouts</span><br><span class="line">    self.layers = [Layer(sz[i],sz[i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nouts))]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">      x = layer(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> [p <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers <span class="keyword">for</span> p <span class="keyword">in</span> layer.parameters()]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-训练神经网络"><a href="#5-训练神经网络" class="headerlink" title="5.训练神经网络"></a>5.训练神经网络</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  n = MLP(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">  xs = [</span><br><span class="line">    [<span class="number">2.0</span>, <span class="number">3.0</span>, -<span class="number">1.0</span>],</span><br><span class="line">    [<span class="number">3.0</span>, -<span class="number">1.0</span>, <span class="number">0.5</span>],</span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">    [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>],</span><br><span class="line">  ]</span><br><span class="line">  ys = [<span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>] <span class="comment"># desired targets</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># forward pass</span></span><br><span class="line">    ypred = [n(x) <span class="keyword">for</span> x <span class="keyword">in</span> xs]</span><br><span class="line">    loss = <span class="built_in">sum</span>((yout - ygt)**<span class="number">2</span> <span class="keyword">for</span> ygt, yout <span class="keyword">in</span> <span class="built_in">zip</span>(ys, ypred))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># backward pass</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> n.parameters():</span><br><span class="line">      p.grad = <span class="number">0.0</span></span><br><span class="line">    loss.backward()</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># update</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> n.parameters():</span><br><span class="line">      p.data += -<span class="number">0.1</span> * p.grad</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(k, loss.data)</span><br><span class="line">  <span class="built_in">print</span>(ypred)</span><br></pre></td></tr></table></figure>
<h3 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6.完整代码"></a>6.完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">root</span>):</span><br><span class="line">  <span class="comment"># builds a set of all nodes and edges in a graph</span></span><br><span class="line">  nodes, edges = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> nodes:</span><br><span class="line">      nodes.add(v)</span><br><span class="line">      <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">        edges.add((child, v))</span><br><span class="line">        build(child)</span><br><span class="line">  build(root)</span><br><span class="line">  <span class="keyword">return</span> nodes, edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_dot</span>(<span class="params">root</span>):</span><br><span class="line">  dot = Digraph(<span class="built_in">format</span>=<span class="string">&#x27;svg&#x27;</span>, graph_attr=&#123;<span class="string">&#x27;rankdir&#x27;</span>: <span class="string">&#x27;LR&#x27;</span>&#125;) <span class="comment"># LR = left to right</span></span><br><span class="line">  </span><br><span class="line">  nodes, edges = trace(root)</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">    uid = <span class="built_in">str</span>(<span class="built_in">id</span>(n))</span><br><span class="line">    <span class="comment"># for any value in the graph, create a rectangular (&#x27;record&#x27;) node for it</span></span><br><span class="line">    dot.node(name = uid, label = <span class="string">&quot;&#123; %s | %.4f | grad %.4f &#125;&quot;</span> % (n.label, n.data, n.grad), shape=<span class="string">&#x27;record&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> n._op:</span><br><span class="line">      <span class="comment"># if this value is a result of some operation, create an op node for it</span></span><br><span class="line">      dot.node(name = uid + n._op, label = n._op)</span><br><span class="line">      <span class="comment"># and connect this node to it</span></span><br><span class="line">      dot.edge(uid + n._op, uid)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> n1, n2 <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="comment"># connect n1 to the op node of n2</span></span><br><span class="line">    dot.edge(<span class="built_in">str</span>(<span class="built_in">id</span>(n1)), <span class="built_in">str</span>(<span class="built_in">id</span>(n2)) + n2._op)</span><br><span class="line">  dot.save(<span class="string">&#x27;output.dot&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> dot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data, _children=(<span class="params"></span>), _op=<span class="string">&#x27;&#x27;</span>, label=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    self.data = data</span><br><span class="line">    self.grad = <span class="number">0.0</span></span><br><span class="line">    self._backward = <span class="keyword">lambda</span>: <span class="literal">None</span></span><br><span class="line">    self._prev = <span class="built_in">set</span>(_children)</span><br><span class="line">    self._op = _op</span><br><span class="line">    self.label = label</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Value(data=<span class="subst">&#123;self.data&#125;</span>)&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">    other = other <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Value) <span class="keyword">else</span> Value(other)</span><br><span class="line">    out = Value(self.data + other.data, (self, other), <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += <span class="number">1.0</span> * out.grad</span><br><span class="line">      other.grad += <span class="number">1.0</span> * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">    other = other <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Value) <span class="keyword">else</span> Value(other)</span><br><span class="line">    out = Value(self.data * other.data, (self, other), <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += other.data * out.grad</span><br><span class="line">      other.grad += self.data * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)), <span class="string">&quot;only supporting int/float powers for now&quot;</span></span><br><span class="line">    out = Value(self.data**other, (self,), <span class="string">f&#x27;**<span class="subst">&#123;other&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">        self.grad += other * (self.data ** (other - <span class="number">1</span>)) * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__rmul__</span>(<span class="params">self, other</span>): <span class="comment"># other * self</span></span><br><span class="line">    <span class="keyword">return</span> self * other</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__truediv__</span>(<span class="params">self, other</span>): <span class="comment"># self / other</span></span><br><span class="line">    <span class="keyword">return</span> self * other**-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__neg__</span>(<span class="params">self</span>): <span class="comment"># -self</span></span><br><span class="line">    <span class="keyword">return</span> self * -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>): <span class="comment"># self - other</span></span><br><span class="line">    <span class="keyword">return</span> self + (-other)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>): <span class="comment"># other + self</span></span><br><span class="line">    <span class="keyword">return</span> self + other</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.data</span><br><span class="line">    t = (math.exp(<span class="number">2</span>*x) - <span class="number">1</span>)/(math.exp(<span class="number">2</span>*x) + <span class="number">1</span>)</span><br><span class="line">    out = Value(t, (self, ), <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += (<span class="number">1</span> - t**<span class="number">2</span>) * out.grad</span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.data</span><br><span class="line">    out = Value(math.exp(x), (self, ), <span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_backward</span>():</span><br><span class="line">      self.grad += out.data * out.grad <span class="comment"># <span class="doctag">NOTE:</span> in the video I incorrectly used = instead of +=. Fixed here.</span></span><br><span class="line">    out._backward = _backward</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">    </span><br><span class="line">    topo = []</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_topo</span>(<span class="params">v</span>):</span><br><span class="line">      <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">        visited.add(v)</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> v._prev:</span><br><span class="line">          build_topo(child)</span><br><span class="line">        topo.append(v)</span><br><span class="line">    build_topo(self)</span><br><span class="line">    </span><br><span class="line">    self.grad = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">reversed</span>(topo):</span><br><span class="line">      node._backward()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin</span>):</span><br><span class="line">    self.w = [Value(random.uniform(-<span class="number">1</span>,<span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nin)]</span><br><span class="line">    self.b = Value(random.uniform(-<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    act = <span class="built_in">sum</span>((wi*xi <span class="keyword">for</span> wi,xi <span class="keyword">in</span> <span class="built_in">zip</span>(self.w,x)), self.b)</span><br><span class="line">    out = act.tanh()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.w + [self.b]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">  <span class="comment"># n个神经元组成的一层</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin, nout</span>):</span><br><span class="line">    self.neurons = [Neuron(nin) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nout)]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    outs = [n(x) <span class="keyword">for</span> n <span class="keyword">in</span> self.neurons]</span><br><span class="line">    <span class="keyword">return</span> outs[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(outs) == <span class="number">1</span> <span class="keyword">else</span> outs</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> [p <span class="keyword">for</span> neuron <span class="keyword">in</span> self.neurons <span class="keyword">for</span> p <span class="keyword">in</span> neuron.parameters()]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>:</span><br><span class="line"><span class="comment"># MLP多层感知机, nin是输入的维度，nouts是个列表，记录每层的输出维度</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nin, nouts</span>):</span><br><span class="line">    sz = [nin] + nouts</span><br><span class="line">    self.layers = [Layer(sz[i],sz[i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nouts))]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">      x = layer(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> [p <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers <span class="keyword">for</span> p <span class="keyword">in</span> layer.parameters()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  n = MLP(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">  xs = [</span><br><span class="line">    [<span class="number">2.0</span>, <span class="number">3.0</span>, -<span class="number">1.0</span>],</span><br><span class="line">    [<span class="number">3.0</span>, -<span class="number">1.0</span>, <span class="number">0.5</span>],</span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">    [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>],</span><br><span class="line">  ]</span><br><span class="line">  ys = [<span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>] <span class="comment"># desired targets</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># forward pass</span></span><br><span class="line">    ypred = [n(x) <span class="keyword">for</span> x <span class="keyword">in</span> xs]</span><br><span class="line">    loss = <span class="built_in">sum</span>((yout - ygt)**<span class="number">2</span> <span class="keyword">for</span> ygt, yout <span class="keyword">in</span> <span class="built_in">zip</span>(ys, ypred))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># backward pass</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> n.parameters():</span><br><span class="line">      p.grad = <span class="number">0.0</span></span><br><span class="line">    loss.backward()</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># update</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> n.parameters():</span><br><span class="line">      p.data += -<span class="number">0.1</span> * p.grad</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(k, loss.data)</span><br><span class="line">  <span class="built_in">print</span>(ypred)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm plus</title>
    <url>/2023/08/15/algorithm-plus/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h3><p><img src="/2023/08/15/algorithm-plus/image-20230816214435544.png" alt="image-20230816214435544" style="zoom:50%;"></p>
<p>因为只能从上面和左边过来，所以有状态转移方程：<code>dp[i][j]=(dp[i-1][j],dp[i][j-1])+a[i][j]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N],dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> r,c;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[r][c]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最低通信费"><a href="#最低通信费" class="headerlink" title="最低通信费"></a>最低通信费</h3><p>N*N的正方形方格，左上角进右下角出，题目条件总路径长度为2*N+1，即只能向下或者向右走，递推方程为<code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);<span class="comment">//边界处理</span></span><br><span class="line">    <span class="comment">//处理dp[1][1]</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>NN zero to hero (P2): makemore-bigram</title>
    <url>/2025/04/29/NN-zero-to-hero-P2-makemore/</url>
    <content><![CDATA[<h3 id="makemore"><a href="#makemore" class="headerlink" title="makemore"></a>makemore</h3><p>makemore是个二元语言模型，也就是上下文长度只有1，根据前一个字符预测后一个字符是什么，已有数据集<code>names.txt</code>记录了一些人名，现在希望利用模型得到一些人的名称</p>
<h3 id="基于统计的方法"><a href="#基于统计的方法" class="headerlink" title="基于统计的方法"></a>基于统计的方法</h3><p>基于统计的方法对数据集中连续的字符对进行统计，得到一张表，通过这张表，可知某个字符i后，字符j的出现次数，基于这张表，可计算出字符i后，字符j的出现概率，然后通过概率抽样的方法得到下一个字符</p>
<p>对于数据集中的每个句子，在前面和后面分别加上<code>.</code>符号，所以第一个字符是抽样<code>.</code>字符后字符出现概率得到的，如果抽样抽到了<code>.</code>，则说明句子结束</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">N = torch.zeros((<span class="number">27</span>,<span class="number">27</span>),dtype=torch.int32)</span><br><span class="line">words = <span class="built_in">open</span>(<span class="string">&quot;names.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).read().splitlines()</span><br><span class="line">chars = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&quot;&quot;</span>.join(words))))</span><br><span class="line">stoi = &#123;s:i+<span class="number">1</span> <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars)&#125;</span><br><span class="line">stoi[<span class="string">&#x27;.&#x27;</span>] = <span class="number">0</span></span><br><span class="line">itos = &#123;i:s <span class="keyword">for</span> s,i <span class="keyword">in</span> stoi.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计字母对的出现次数</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ch1,ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">        N[stoi[ch1],stoi[ch2]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">plt.imshow(N, cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">        chstr = itos[i] + itos[j]</span><br><span class="line">        plt.text(j, i, chstr, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        plt.text(j, i, N[i, j].item(), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;bigram.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/29/NN-zero-to-hero-P2-makemore/image-20250506193942162.png" alt="image-20250506193942162"></p>
<p>上面的table显示了字符对的出现频率，其中<code>..</code>出现了0次，因为数据集中没有空的句子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P = (N+<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">P /= P.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    out = []</span><br><span class="line">    ix = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = P[ix]</span><br><span class="line">        ix = torch.multinomial(p, num_samples=<span class="number">1</span>, replacement=<span class="literal">True</span>).item() <span class="comment">#根据概率采样</span></span><br><span class="line">        out.append(itos[ix])</span><br><span class="line">        <span class="keyword">if</span> ix == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(out))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用构建好的概率模型进行推理，P对原先的N的概率模型进行了平滑处理，因为一些字符对在N中完全没有出现过，这样使这样的字符对也能被取到，此外在一些数学计算上也避免出现异常，下面是生成的一些名字，还怪正常的哈哈</p>
<p><img src="/2025/04/29/NN-zero-to-hero-P2-makemore/image-20250506195144111.png" alt="image-20250506195144111" style="zoom:50%;"></p>
<p>采用损失函数统计模型的好坏，也就是对于数据集中的每个句子，我们希望概率模型的预测结果和真实结果一致，用损失展示模型的好坏</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GOAL: maximize likelihood of the data w.r.t. model parameters (statistical modeling)</span></span><br><span class="line"><span class="comment"># equivalent to maximizing the log likelihood (because log is monotonic)</span></span><br><span class="line"><span class="comment"># equivalent to minimizing the negative log likelihood</span></span><br><span class="line"><span class="comment"># equivalent to minimizing the average negative log likelihood</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log(a*b*c) = log(a) + log(b) + log(c)</span></span><br><span class="line"></span><br><span class="line">log_likelihood = <span class="number">0.0</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ch1,ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">        p = P[stoi[ch1], stoi[ch2]]</span><br><span class="line">        log_likelihood += torch.log(p)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;log_likelihood=&#125;</span>&#x27;</span>)</span><br><span class="line">nll = -log_likelihood</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nll=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nll/n&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果模型完全预测正确，也就是对应项<code>p=1</code>，此时log值为0，最终的损失为0，否则<code>p</code>越小，对应的<code>log</code>越负，负<code>log</code>结果得到的损失越大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_likelihood=tensor(-559951.5625)</span><br><span class="line">nll=tensor(559951.5625)</span><br><span class="line">2.4543561935424805</span><br></pre></td></tr></table></figure>
<h3 id="采用神经网络"><a href="#采用神经网络" class="headerlink" title="采用神经网络"></a>采用神经网络</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create the training set of bigrams (x,y)</span></span><br><span class="line">xs, ys = [], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:<span class="number">1</span>]:</span><br><span class="line">  chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span> ch1, ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">    ix1 = stoi[ch1]</span><br><span class="line">    ix2 = stoi[ch2]</span><br><span class="line">    <span class="built_in">print</span>(ch1, ch2)</span><br><span class="line">    xs.append(ix1)</span><br><span class="line">    ys.append(ix2)</span><br><span class="line">    </span><br><span class="line">xs = torch.tensor(xs)</span><br><span class="line">ys = torch.tensor(ys)</span><br><span class="line">W = torch.randn((<span class="number">27</span>, <span class="number">27</span>)) <span class="comment"># 27个神经元（一排）</span></span><br><span class="line"></span><br><span class="line">xenc = F.one_hot(xs, num_classes=<span class="number">27</span>).<span class="built_in">float</span>()</span><br><span class="line">logist = xenc @ W</span><br><span class="line">counts = torch.exp(logist)</span><br><span class="line">probs = counts / counts.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(probs.shape)</span><br><span class="line">nlls = torch.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  <span class="comment"># i-th bigram:</span></span><br><span class="line">  x = xs[i].item() <span class="comment"># input character index</span></span><br><span class="line">  y = ys[i].item() <span class="comment"># label character index</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;--------&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;bigram example <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;itos[x]&#125;</span><span class="subst">&#123;itos[y]&#125;</span> (indexes <span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;input to the neural net:&#x27;</span>, x)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;output probabilities from the neural net:&#x27;</span>, probs[i])</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;label (actual next character):&#x27;</span>, y)</span><br><span class="line">  p = probs[i, y]</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;probability assigned by the net to the the correct character:&#x27;</span>, p.item())</span><br><span class="line">  logp = torch.log(p)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;log likelihood:&#x27;</span>, logp.item())</span><br><span class="line">  nll = -logp</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;negative log likelihood:&#x27;</span>, nll.item())</span><br><span class="line">  nlls[i] = nll</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;average negative log likelihood, i.e. loss =&#x27;</span>, nlls.mean().item())</span><br></pre></td></tr></table></figure>
<p>W是已有的神经网络，这里是个参数随机初始化的一排27个神经元组成的神经网络，输出27个维度，后接softmax操作（先经过exp，然后经过归一化），得到类似于统计方法的概率分布。可以看做经过神经网络得到的是出现次数log后的结果，exp之后得到了计数，归一化得到了概率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------- !!! OPTIMIZATION !!! yay, but this time actually --------------</span></span><br><span class="line"><span class="comment"># create the dataset</span></span><br><span class="line">xs, ys = [], []</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">  chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span> ch1, ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">    ix1 = stoi[ch1]</span><br><span class="line">    ix2 = stoi[ch2]</span><br><span class="line">    xs.append(ix1)</span><br><span class="line">    ys.append(ix2)</span><br><span class="line">xs = torch.tensor(xs)</span><br><span class="line">ys = torch.tensor(ys)</span><br><span class="line">num = xs.nelement()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number of examples: &#x27;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the &#x27;network&#x27;</span></span><br><span class="line">W = torch.randn((<span class="number">27</span>, <span class="number">27</span>),  requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gradient descent</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">  <span class="comment"># forward pass</span></span><br><span class="line">  xenc = F.one_hot(xs, num_classes=<span class="number">27</span>).<span class="built_in">float</span>() <span class="comment"># input to the network: one-hot encoding</span></span><br><span class="line">  logits = xenc @ W <span class="comment"># predict log-counts</span></span><br><span class="line">  counts = logits.exp() <span class="comment"># counts, equivalent to N</span></span><br><span class="line">  probs = counts / counts.<span class="built_in">sum</span>(<span class="number">1</span>, keepdims=<span class="literal">True</span>) <span class="comment"># probabilities for next character</span></span><br><span class="line">  loss = -probs[torch.arange(num), ys].log().mean() + <span class="number">0.01</span>*(W**<span class="number">2</span>).mean()</span><br><span class="line">  <span class="built_in">print</span>(loss.item())</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># backward pass</span></span><br><span class="line">  W.grad = <span class="literal">None</span> <span class="comment"># set to zero the gradient</span></span><br><span class="line">  loss.backward()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># update</span></span><br><span class="line">  W.data += -<span class="number">50</span> * W.grad</span><br></pre></td></tr></table></figure>
<p>训练神经网络，完成了整个步骤，这里的loss除了负log的损失之外，为了让模型平滑（类似于之前的P=N+1的效果），加入了正则化项<code>0.01*(W**2).mean()</code>，让W的参数不要太大</p>
<hr>
<p>所有的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">N = torch.zeros((<span class="number">27</span>,<span class="number">27</span>),dtype=torch.int32)</span><br><span class="line">words = <span class="built_in">open</span>(<span class="string">&quot;names.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).read().splitlines()</span><br><span class="line">chars = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(<span class="string">&quot;&quot;</span>.join(words))))</span><br><span class="line">stoi = &#123;s:i+<span class="number">1</span> <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars)&#125;</span><br><span class="line">stoi[<span class="string">&#x27;.&#x27;</span>] = <span class="number">0</span></span><br><span class="line">itos = &#123;i:s <span class="keyword">for</span> s,i <span class="keyword">in</span> stoi.items()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计字母对的出现次数</span></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ch1,ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">        N[stoi[ch1],stoi[ch2]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">plt.imshow(N, cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">        chstr = itos[i] + itos[j]</span><br><span class="line">        plt.text(j, i, chstr, ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;bottom&quot;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        plt.text(j, i, N[i, j].item(), ha=<span class="string">&quot;center&quot;</span>, va=<span class="string">&quot;top&quot;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.savefig(&#x27;bigram.png&#x27;)</span></span><br><span class="line"></span><br><span class="line">P = (N+<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">P /= P.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    out = []</span><br><span class="line">    ix = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = P[ix]</span><br><span class="line">        ix = torch.multinomial(p, num_samples=<span class="number">1</span>, replacement=<span class="literal">True</span>).item() <span class="comment">#根据概率采样</span></span><br><span class="line">        out.append(itos[ix])</span><br><span class="line">        <span class="keyword">if</span> ix == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(out))</span><br><span class="line"></span><br><span class="line"><span class="comment"># GOAL: maximize likelihood of the data w.r.t. model parameters (statistical modeling)</span></span><br><span class="line"><span class="comment"># equivalent to maximizing the log likelihood (because log is monotonic)</span></span><br><span class="line"><span class="comment"># equivalent to minimizing the negative log likelihood</span></span><br><span class="line"><span class="comment"># equivalent to minimizing the average negative log likelihood</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log(a*b*c) = log(a) + log(b) + log(c)</span></span><br><span class="line"></span><br><span class="line">log_likelihood = <span class="number">0.0</span></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ch1,ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">        p = P[stoi[ch1], stoi[ch2]]</span><br><span class="line">        log_likelihood += torch.log(p)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;log_likelihood=&#125;</span>&#x27;</span>)</span><br><span class="line">nll = -log_likelihood</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nll=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nll/n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;========================================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the training set of bigrams (x,y)</span></span><br><span class="line">xs, ys = [], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:<span class="number">1</span>]:</span><br><span class="line">  chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span> ch1, ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">    ix1 = stoi[ch1]</span><br><span class="line">    ix2 = stoi[ch2]</span><br><span class="line">    <span class="built_in">print</span>(ch1, ch2)</span><br><span class="line">    xs.append(ix1)</span><br><span class="line">    ys.append(ix2)</span><br><span class="line">    </span><br><span class="line">xs = torch.tensor(xs)</span><br><span class="line">ys = torch.tensor(ys)</span><br><span class="line">W = torch.randn((<span class="number">27</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xenc = F.one_hot(xs, num_classes=<span class="number">27</span>).<span class="built_in">float</span>()</span><br><span class="line">logist = xenc @ W</span><br><span class="line">counts = torch.exp(logist)</span><br><span class="line">probs = counts / counts.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(probs.shape)</span><br><span class="line">nlls = torch.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  <span class="comment"># i-th bigram:</span></span><br><span class="line">  x = xs[i].item() <span class="comment"># input character index</span></span><br><span class="line">  y = ys[i].item() <span class="comment"># label character index</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;--------&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&#x27;bigram example <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;itos[x]&#125;</span><span class="subst">&#123;itos[y]&#125;</span> (indexes <span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;input to the neural net:&#x27;</span>, x)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;output probabilities from the neural net:&#x27;</span>, probs[i])</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;label (actual next character):&#x27;</span>, y)</span><br><span class="line">  p = probs[i, y]</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;probability assigned by the net to the the correct character:&#x27;</span>, p.item())</span><br><span class="line">  logp = torch.log(p)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;log likelihood:&#x27;</span>, logp.item())</span><br><span class="line">  nll = -logp</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;negative log likelihood:&#x27;</span>, nll.item())</span><br><span class="line">  nlls[i] = nll</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;average negative log likelihood, i.e. loss =&#x27;</span>, nlls.mean().item())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================&#x27;</span>)</span><br><span class="line"><span class="comment"># --------- !!! OPTIMIZATION !!! yay, but this time actually --------------</span></span><br><span class="line"><span class="comment"># create the dataset</span></span><br><span class="line">xs, ys = [], []</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">  chs = [<span class="string">&#x27;.&#x27;</span>] + <span class="built_in">list</span>(w) + [<span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span> ch1, ch2 <span class="keyword">in</span> <span class="built_in">zip</span>(chs, chs[<span class="number">1</span>:]):</span><br><span class="line">    ix1 = stoi[ch1]</span><br><span class="line">    ix2 = stoi[ch2]</span><br><span class="line">    xs.append(ix1)</span><br><span class="line">    ys.append(ix2)</span><br><span class="line">xs = torch.tensor(xs)</span><br><span class="line">ys = torch.tensor(ys)</span><br><span class="line">num = xs.nelement()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number of examples: &#x27;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the &#x27;network&#x27;</span></span><br><span class="line">W = torch.randn((<span class="number">27</span>, <span class="number">27</span>),  requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># gradient descent</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">  <span class="comment"># forward pass</span></span><br><span class="line">  xenc = F.one_hot(xs, num_classes=<span class="number">27</span>).<span class="built_in">float</span>() <span class="comment"># input to the network: one-hot encoding</span></span><br><span class="line">  logits = xenc @ W <span class="comment"># predict log-counts</span></span><br><span class="line">  counts = logits.exp() <span class="comment"># counts, equivalent to N</span></span><br><span class="line">  probs = counts / counts.<span class="built_in">sum</span>(<span class="number">1</span>, keepdims=<span class="literal">True</span>) <span class="comment"># probabilities for next character</span></span><br><span class="line">  loss = -probs[torch.arange(num), ys].log().mean() + <span class="number">0.01</span>*(W**<span class="number">2</span>).mean()</span><br><span class="line">  <span class="built_in">print</span>(loss.item())</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># backward pass</span></span><br><span class="line">  W.grad = <span class="literal">None</span> <span class="comment"># set to zero the gradient</span></span><br><span class="line">  loss.backward()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># update</span></span><br><span class="line">  W.data += -<span class="number">50</span> * W.grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    out = []</span><br><span class="line">    ix = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># ----------</span></span><br><span class="line">        <span class="comment"># BEFORE:</span></span><br><span class="line">        <span class="comment">#p = P[ix]</span></span><br><span class="line">        <span class="comment"># ----------</span></span><br><span class="line">        <span class="comment"># NOW:</span></span><br><span class="line">        xenc = F.one_hot(torch.tensor([ix]), num_classes=<span class="number">27</span>).<span class="built_in">float</span>()</span><br><span class="line">        logits = xenc @ W <span class="comment"># predict log-counts</span></span><br><span class="line">        counts = logits.exp() <span class="comment"># counts, equivalent to N</span></span><br><span class="line">        p = counts / counts.<span class="built_in">sum</span>(<span class="number">1</span>, keepdims=<span class="literal">True</span>) <span class="comment"># probabilities for next character</span></span><br><span class="line">        <span class="comment"># ----------</span></span><br><span class="line">        </span><br><span class="line">        ix = torch.multinomial(p, num_samples=<span class="number">1</span>, replacement=<span class="literal">True</span>).item()</span><br><span class="line">        out.append(itos[ix])</span><br><span class="line">        <span class="keyword">if</span> ix == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(out))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>algorithm</title>
    <url>/2022/12/14/algorithm/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ul>
<li>c++里面1e7和1e8的复杂度大概1s能够计算得到</li>
<li>10的9次方以内或者32位整数用int存放，10的18次方以内或者64位整数用long long 存放</li>
<li>小写字母比大写字母的ASCII大32</li>
<li>%d-整数；%s-字符串（字符数组），%f-浮点数，%c-char</li>
<li>对于四舍五入的处理：可以直接进行判断，也可以使用浮点数的round函数</li>
<li>自建数据结构一定要考虑初始化</li>
<li>C++位运算的优先级比加减乘除的优先级低，所以遇到位运算和加减乘除一起的，要加个括号。</li>
<li>注意要不要用long long </li>
</ul>
<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><p>分治</p>
<ol>
<li><p>确定分界点 q[l]，q[(l+r)/2],q[r],随机，使其值为x</p>
</li>
<li><p>调整范围  （左半边&lt;=x）（右半边&gt;=x），<strong>注意分界点不一定是x</strong></p>
</li>
<li>递归处理左右两段</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="comment">//分治法思想</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//双指针</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//取中间作为基准</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);<span class="comment">//左右指针移动</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//递归处理左右部分</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">q, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    x = q[l + r &gt;&gt; <span class="number">1</span>]</span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    j = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[i] &gt;= x:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[j] &lt;= x:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            q[i], q[j] = q[j], q[i]</span><br><span class="line">    quick_sort(q, l, j)</span><br><span class="line">    quick_sort(q, j + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    quick_sort(data, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, data))))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a>第k个数</h3><p>注意这个代码左边&lt;=x, 右边&gt;=x, 但分界点不一定=x ，模拟一下<code>3 4 2 8 9 5 7</code>，这个代码可能和有些不一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span><span class="comment">//基于快排</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];<span class="comment">//数组中只有一个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//快排按基准划分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j - l + <span class="number">1</span> &gt;= k) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, l, j, k);<span class="comment">//若左半部分元素个数大于等于k，搜左边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));<span class="comment">//否则搜右边，更新搜索第k - (j - l + 1)个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>, k) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">q, l, r, k</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span> q[l]</span><br><span class="line">    x = q[l + r &gt;&gt; <span class="number">1</span>]</span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    j = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[i] &gt;= x:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[j] &lt;= x:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            q[i], q[j] = q[j], q[i]</span><br><span class="line">    <span class="keyword">if</span> j - l + <span class="number">1</span> &gt;= k:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(q, l, j, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(q, j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    data = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="built_in">print</span>(quick_sort(data, <span class="number">0</span>, n - <span class="number">1</span>, k))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);<span class="comment">//分别对左右部分进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//进行合并</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<span class="comment">//合并剩余部分</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<span class="comment">//重新拷贝到原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：python的最后收尾有更加简单的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">q, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">    i = l</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    merge_sort(q, l, mid)</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> q[i] &lt;= q[j]:</span><br><span class="line">            tmp.append(q[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(q[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    tmp += q[i : mid + <span class="number">1</span>]</span><br><span class="line">    tmp += q[j : r + <span class="number">1</span>]</span><br><span class="line">    q[l : r + <span class="number">1</span>] = tmp[:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    merge_sort(data, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, data))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>其实在计算的过程中可以想象，只需要给后半段的每一个值计算一个逆序对数量，如果碰到q[i]&gt;q[j]，则由于前半段已经排好序，所以i~mid都是比j要大的，j位置上的逆序对数量可以计算得到，如果q[i]&lt;=q[j],说明j位置上的逆序对需要暂缓计算（因为1~i上的值都比j小，构不成逆序对，所以j在等待一个i+k，使得q[i+k]&gt;q[j]，然后j的逆序对数量就是i+k~mid了），如果没有等到这个i+k，则说明没有逆序对值</p>
<blockquote>
<p>注意边界条件&gt;=,写错了可就EML</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">q, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">    i = l</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    result = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="number">1</span>, r)</span><br><span class="line">    tmp = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> q[i] &lt;= q[j]:</span><br><span class="line">            tmp.append(q[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(q[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            result = result + mid - i + <span class="number">1</span></span><br><span class="line">    tmp += q[i : mid + <span class="number">1</span>]</span><br><span class="line">    tmp += q[j : r + <span class="number">1</span>]</span><br><span class="line">    q[l : r + <span class="number">1</span>] = tmp[:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="built_in">print</span>(merge_sort(data, <span class="number">0</span>, n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<span class="comment">//这里lr无所谓，最后l=r</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">q, n, k</span>):</span><br><span class="line">    l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> q[mid] &gt;= k:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> q[l] != k:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-1 -1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(l, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[mid] &lt;= k:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        binary_search(data, n, k)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="整数二分总结"><a href="#整数二分总结" class="headerlink" title="整数二分总结"></a>整数二分总结</h3><p>整数二分法：有单调性可以二分，无单调性也可能可以。主要是否存在一种性质能把区间分成两半——边界</p>
<p>二分可以求这个划分的边界，存在左半部分的右边界和右半部分的左边界，有两套模板，选择的时候判断性质把mid放在left还是right上</p>
<p>二分每次都覆盖最终的结果，最后只剩一个数的时候就是结果</p>
<p>二分模板一共有两个，分别适用于不同情况。<br>算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。</p>
<p>版本1<br>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本2<br>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//需要加一，否则可能出现死循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个总区间，经由我们的 check 函数判断后，可分成两部分，<br>这边以o作 true，…..作 false 示意较好识别</p>
<p>如果我们的目标是下面这个v，那麽就必须使用模板 1</p>
<p>…………….vooooooooo</p>
<p>假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用模板 2</p>
<p>oooooooov……………….</p>
<p>所以下次可以观察 check 属性再与模板1 or 2 互相搭配就不会写错啦</p>
<h3 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;<span class="comment">//边界的选择</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)<span class="comment">//注意对浮点数的处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &gt;= x) r = mid;<span class="comment">//类似于整数二分</span></span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, l);<span class="comment">//注意浮点保留小数位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/qq_29874741/article/details/94626531">(c语言printf()输出格式大全_printf输出格式_rusty_knife的博客-CSDN博客</a></p>
</blockquote>
<p>double输出为<code>%lf</code></p>
<p>python</p>
<p><a href="https://blog.csdn.net/Catherinyy/article/details/115265609">python print（）函数控制输出格式_python 打印格式格式-CSDN博客</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">x</span>):</span><br><span class="line">    l = -<span class="number">10000</span></span><br><span class="line">    r = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">while</span> r - l &gt;= <span class="number">1e-8</span>:</span><br><span class="line">        mid = (l+r)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">if</span> mid**<span class="number">3</span> &gt;= x:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    x = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line">    result = binary_search(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(result))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="浮点二分总结"><a href="#浮点二分总结" class="headerlink" title="浮点二分总结"></a>浮点二分总结</h3><p>浮点二分是类似于整数二分的，且其无需考虑+1-1的，需要注意：</p>
<ul>
<li>while的条件，<code>r-l&gt;精度*10^-2^</code>，比如题目要求精度是-6次，<code>r-l&gt;1e-8</code></li>
<li>r和l直接取边界值即可</li>
</ul>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><blockquote>
<p>tips：</p>
<ul>
<li>注意处理进位，包括最高位的进位</li>
<li>借位的处理，借位不是t/10，而是正负判定赋值</li>
<li>注意是否需要处理前导0,注意乘法是不是可以乘以0</li>
</ul>
</blockquote>
<p>string的存储：”12345”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ul>
<li>存储时使用数组存储（可用vector），从个位开始存储，如数12345，在数组里的存储方式为：（为了方便加法）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组的第X位</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储的数字</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>运算的方法：模拟人工加法，每一位的结果等于两个数该位的结果加上低位的进位</li>
</ul>
<p>不压位代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);<span class="comment">//让A总是更长</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t); <span class="comment">//注意处理最后的进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压位代码</p>
<p>压位能减小所需空间，高精度加法可以压9位，乘法可以压4位，压9位就是数组的一位表示原数的9位（int范围的限制）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">1000000000</span>;<span class="comment">//压9位，加法进位的时候是需要余base</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % base);</span><br><span class="line">        t /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;<span class="comment">//s记录当前位数字，j为当前压了几位，t为辅助乘数量级</span></span><br><span class="line">        s += (a[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (b[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();<span class="comment">//单独输出最高位(因为无需补高位0)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%09d&quot;</span>, C[i]);<span class="comment">//需要补高位0，限制在9位</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然python自带大整数计算，但是还是模拟一下算法思想：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">A,B</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A)&lt;<span class="built_in">len</span>(B):</span><br><span class="line">        <span class="keyword">return</span> add(B,A)</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        t += A[i]</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            t += B[i]</span><br><span class="line">        result.append(t%<span class="number">10</span>)</span><br><span class="line">        t = t // <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> t :</span><br><span class="line">        result.append(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">list</span>(<span class="built_in">input</span>())))</span><br><span class="line">    B = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">list</span>(<span class="built_in">input</span>())))</span><br><span class="line">    A.reverse()</span><br><span class="line">    B.reverse()</span><br><span class="line">    C = add(A,B)</span><br><span class="line">    C.reverse()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,C))))</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><ul>
<li>需要首先保证<code>sub(A,B)</code>中有<code>A&gt;=B</code></li>
<li>然后逐位作差，注意借位</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><span class="comment">//判断是否有 A&gt;=B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();<span class="comment">//首先判断位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//然后从高位起开始判断</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//若相等，也返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><span class="comment">//作差，此时已经保证A &gt;= B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )<span class="comment">//t表示借位</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B)) C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="keyword">else</span> C = <span class="built_in">sub</span>(B, A), cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;<span class="comment">//注意对符号的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">A, B</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) != <span class="built_in">len</span>(B):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(A) &gt; <span class="built_in">len</span>(B)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> A[i] != B[i]:</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">A, B</span>):</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        t = A[i] - t</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(B):</span><br><span class="line">            t -= B[i]</span><br><span class="line">        result.append((t + <span class="number">10</span>) % <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(result) &gt; <span class="number">1</span> <span class="keyword">and</span> result[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        result.pop()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>()))</span><br><span class="line">    B = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>()))</span><br><span class="line">    A.reverse()</span><br><span class="line">    B.reverse()</span><br><span class="line">    <span class="keyword">if</span> cmp(A, B):</span><br><span class="line">        C = sub(A, B)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        C = sub(B, A)</span><br><span class="line">    C.reverse()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, C)))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><ul>
<li>首先注意进位的处理，类似加法</li>
<li>其次注意处理前导0</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )<span class="comment">//处理进位，||t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;<span class="comment">//A的每一位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//b为0，前导0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种方法不太好记忆，也可以采用下面这种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t+=A[i]*b;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)<span class="comment">//处理余下的进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>()==<span class="number">0</span>&amp;&amp;res.<span class="built_in">size</span>()&gt;<span class="number">1</span>) res.<span class="built_in">pop_back</span>();<span class="comment">//处理乘以0后的前导0</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    C=<span class="built_in">dot</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">A, b</span>):</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">        t += A[i] * b</span><br><span class="line">        result.append(t % <span class="number">10</span>)</span><br><span class="line">        t = t // <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span> t:</span><br><span class="line">        result.append(t % <span class="number">10</span>)</span><br><span class="line">        t = t // <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(result) &gt; <span class="number">1</span> <span class="keyword">and</span> result[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        result.pop()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>()))</span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    A.reverse()</span><br><span class="line">    C = mul(A, b)</span><br><span class="line">    C.reverse()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, C)))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><ul>
<li>类似于人做除法，从高位开始除，注意对余数的处理</li>
<li>除完后得到的是从0开始高位——低位的格式，进行反转</li>
<li>处理前导0</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, B, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">A, B</span>):</span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        r = r * <span class="number">10</span> + A[i]</span><br><span class="line">        result.append(r // B)</span><br><span class="line">        r %= B</span><br><span class="line">    result.reverse()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(result) &gt; <span class="number">1</span> <span class="keyword">and</span> result[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        result.pop()</span><br><span class="line">    <span class="keyword">return</span> result, r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>()))</span><br><span class="line">    B = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    C, r = div(A, B)</span><br><span class="line">    C.reverse()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, C)))</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><ul>
<li>$S_i=a_1+a_2+…+a_i$</li>
<li><p>$sum(l,r)=S_r-S_{l-1}$</p>
</li>
<li><p>为了能统一格式，输入可以从1开始，然后<code>s[i] = s[i - 1] + a[i]</code>这一操作就也可以从1开始了</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;  iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i]; <span class="comment">// 前缀和的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]); <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要原来的数组，也可以直接用<code>a</code>数组自己来变换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]+a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> st,ed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">        cout&lt;&lt;a[ed]-a[st<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">a = [<span class="number">0</span>]*N</span><br><span class="line">s = [<span class="number">0</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    a[<span class="number">1</span>:n+<span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s[i] = s[i-<span class="number">1</span>] + a[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        l,r = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(s[r]-s[l-<span class="number">1</span>])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><ul>
<li>$S[i][j]$存储包括$a[i][j]$的左上侧元素的和</li>
<li>$S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]$</li>
<li>查询$(x_1,y_1)$和$(x_2,y_2)$范围内元素的和（包括这两个点），$S[x_2][y_2]-S[x_2][y_1-1]-S[x_1-1][y_2]+S[x_1-1][y_1-1]$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">a = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">s = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m, q = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        a[i][<span class="number">1</span> : m + <span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        x1, y1, x2, y2 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><ul>
<li><p>差分的核心操作是：在数组<code>a[L:R]</code>上全都加上c，等价于<code>b[l]+=c</code>,<code>b[R+1]-=c</code></p>
</li>
<li><p>差分是前缀和的逆运算，即构造数组b，使得a数组是其前缀和数组</p>
</li>
<li>差分的数组b不需要显示计算，可以理解为a数组原本是全0，然后在a数组上插入数，即在<code>a[i,i]上插入a[i][i]</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span><span class="comment">//等价在a上的[l,r]区间的数都加上c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">还见过另外一种差分方法：</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];</span></span><br><span class="line"><span class="comment">for (int i = n; i; i -- ) a[i] -= a[i - 1];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">a = [<span class="number">0</span>] * N</span><br><span class="line">b = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">l, r, c</span>):</span><br><span class="line">    b[l] += c</span><br><span class="line">    b[r + <span class="number">1</span>] -= c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a[<span class="number">1</span> : n + <span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        insert(i, i, a[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        l, r, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        insert(l, r, c)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        b[i] = b[i] + b[i - <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, b[<span class="number">1</span> : n + <span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><ul>
<li>核心思想：给定原矩阵<code>a[i,j]</code>，构造差分矩阵<code>b[i,j]</code>，使得a是b的前缀和</li>
<li>核心操作：给以(x1,y1)为左上角,(x2,y2)为右下角的子矩阵中的所有数加上c，其对于差分矩阵的影响是</li>
<li><code>S[x1,y1]+=c;S[x1,y2+1]-=c;S[x2+1,y1]-=c;S[x2+1,y2+1]+=c</code></li>
<li>同样不需要显式构造差分矩阵，借助核心操作可完成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">a = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">b = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">x1, y1, x2, y2, c</span>):</span><br><span class="line">    b[x1][y1] += c</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m, q = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        a[i][<span class="number">1</span> : m + <span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            insert(i, j, i, j, a[i][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        x1, y1, x2, y2, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        insert(x1, y1, x2, y2, c)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, b[i][<span class="number">1</span> : m + <span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><ul>
<li>归并排序双指针指向两个数组，快排双指针指向一个数组</li>
<li>核心思想：将朴素的二重循环优化到$O(n)$</li>
<li>写的时候首先写朴素的二重循环（先枚举终点，再枚举起点），然后考虑i,j之间的关系，是否存在单调的关系</li>
</ul>
<p>!!!模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i&amp;&amp;<span class="built_in">check</span>(i,j)) j++;</span><br><span class="line">    <span class="comment">//具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], s[N];<span class="comment">//s用来做hash的，表示某个数的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )<span class="comment">//考虑右边界为i的最长子序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        s[q[i]] ++ ;<span class="comment">//由于左侧一定是不重复的，所以只需要考虑进入的数是否重复</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; i &amp;&amp; s[q[i]] &gt; <span class="number">1</span>) s[q[j ++ ]] -- ;<span class="comment">//若重复则紧缩左边界以达到去重目的</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);<span class="comment">//去重后取最大值作为输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python ：直接开数组的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">s = [<span class="number">0</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s[data[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;i <span class="keyword">and</span> s[data[i]] &gt; <span class="number">1</span>:</span><br><span class="line">            s[data[j]] -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, i-j+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>python：采用内置字典的写法</p>
<blockquote>
<p>dict.fromkeys([],0) 初始化dict</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    d = <span class="built_in">dict</span>.fromkeys(data,<span class="number">0</span>)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        d[data[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> d[data[i]]&gt;<span class="number">1</span> <span class="keyword">and</span> j&lt;i:</span><br><span class="line">            d[data[j]] -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h3><p>考虑单调性去优化二重朴素循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">while</span>(j&lt;m&amp;&amp;a[i]+b[j]&lt;x) j++;</span><br><span class="line">     <span class="keyword">if</span>(a[i]+b[j]==x)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    j = m - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> a[i] + b[j] &gt; x <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a[i] + b[j] == x:</span><br><span class="line">            <span class="built_in">print</span>(i, j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) i ++ ;</span><br><span class="line">        j ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == n) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">        <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>求n的第k位数字：<code>n&gt;&gt;k&amp;1</code></p>
<p>返回n的最后一位：<code>lowbit(n)=n&amp;-n</code>，如：</p>
<p>x=1010，lowbit(x)=10</p>
<p>x=101000，lowbit(x)=1000</p>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= i &amp; -i) s ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            x = x - (x&amp;-x)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(res,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>当值域跨度大，但点分布比较稀疏时可用离散化，如给定数-1e10,-1,1e10，该数上所在位置对应一个数，此时可用一个数组中存储上述列举的稀疏的数，一个数组来存储对应的数</p>
<p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p>
<p>离散化首先需要排序去重：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 排序：<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>())</span><br><span class="line"><span class="number">2.</span> 去重：alls.<span class="built_in">earse</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">/*返回去重最后一位数，外层alls.erase()删去从alls中去重的最后一位数到alls后面的重复数的最后一位（也就是把unique操作中移到alls末尾的重复数全部删掉）*/</span></span><br></pre></td></tr></table></figure>
<p>unique()函数的底层原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>])<span class="comment">//如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];<span class="comment">//每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;<span class="comment">//返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><p>建立x-&gt;value的映射，但是又不能是数组那种直接hash，所以做法是把所有可能的下标都记录下来，去重后，然后再建立一个新的数组来存放固定好x后的他们的value值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="comment">//这里可以直接从1开始是因为find函数返回时从1开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：因为把query的下标都加入了，所以这里的find函数一定能找到相同值，如果不插入的话，就需要写两个find函数分别查找大于等于l的下标和小于等于r的下标了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">k, num</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(k) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k[mid] &gt;= num:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    add = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    query = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    d = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> add:</span><br><span class="line">        d[item[<span class="number">0</span>]] = d.get(item[<span class="number">0</span>], <span class="number">0</span>) + item[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> query:</span><br><span class="line">        d[item[<span class="number">0</span>]] = d.get(item[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">        d[item[<span class="number">1</span>]] = d.get(item[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">    d = <span class="built_in">sorted</span>(d.items())</span><br><span class="line">    k = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> d]</span><br><span class="line">    v = [<span class="number">0</span>] + [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> d]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">        v[i] = v[i - <span class="number">1</span>] + v[i]</span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> query:</span><br><span class="line">        l = find(k, pair[<span class="number">0</span>])</span><br><span class="line">        r = find(k, pair[<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(v[r] - v[l - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st=<span class="number">-2e9</span>,ed=<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(item.first&gt;ed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);<span class="comment">//把上一个块压入</span></span><br><span class="line">            st=item.first,ed=item.second;<span class="comment">//开启一个新的块</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed=<span class="built_in">max</span>(ed,item.second);<span class="comment">//不能开启新的块,拓展该块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论上述何种情况，最后一个块都尚未压入</span></span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    segs=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    vector&lt;PII&gt;segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout&lt;&lt;segs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">data</span>):</span><br><span class="line">    data.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    st, ed = -<span class="number">2e9</span>, -<span class="number">2e9</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">0</span>] &gt; ed:</span><br><span class="line">            <span class="keyword">if</span> st != -<span class="number">2e9</span>:</span><br><span class="line">                res.append([st, ed])</span><br><span class="line">            st, ed = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ed = <span class="built_in">max</span>(ed, item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> st != -<span class="number">2e9</span>:</span><br><span class="line">        res.append([st, ed])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    data = merge(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(data))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>一般单链表的实现：指针+结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但在笔试题里面不怎么用，因为new的时候耗时比较高，在面试中常用</p>
<blockquote>
<p>单链表，用得最多的是邻接表（n个链表），可用于存储树和图</p>
<p>双链表，用于优化某些问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head,idx,e[N],ne[N];</span><br><span class="line"><span class="comment">//分别为头指针,idx为下一个能放入的点,e数组存储值,ne数组存储next节点。null用-1表示</span></span><br></pre></td></tr></table></figure>
<p>下面是单链表的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">e = [<span class="number">0</span>]*N</span><br><span class="line">ne = [<span class="number">0</span>]*N</span><br><span class="line">head,idx = -<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_to_head</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> idx,head</span><br><span class="line">    e[idx]=x</span><br><span class="line">    ne[idx]=head</span><br><span class="line">    head = idx</span><br><span class="line">    idx +=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">k,x</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    e[idx] = x</span><br><span class="line">    ne[idx] = ne[k]</span><br><span class="line">    ne[k]=idx</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">k</span>):</span><br><span class="line">    ne[k]=ne[ne[k]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> idx,head</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>]==<span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            add_to_head(x)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            k = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                head = ne[head]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                remove(k-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k,x = <span class="built_in">int</span>(op[<span class="number">1</span>]),<span class="built_in">int</span>(op[<span class="number">2</span>])</span><br><span class="line">            add(k-<span class="number">1</span>,x)</span><br><span class="line">    i = head</span><br><span class="line">    <span class="keyword">while</span> i!=-<span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(e[i],end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        i = ne[i]</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标k后面插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">insert</span>(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;e[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">e = [<span class="number">0</span>] * N</span><br><span class="line">l = [<span class="number">0</span>] * N</span><br><span class="line">r = [<span class="number">0</span>] * N</span><br><span class="line">idx = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">k, x</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    e[idx] = x</span><br><span class="line">    l[r[k]] = idx</span><br><span class="line">    r[idx] = r[k]</span><br><span class="line">    l[idx] = k</span><br><span class="line">    r[k] = idx</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">k</span>):</span><br><span class="line">    l[r[k]] = l[k]</span><br><span class="line">    r[l[k]] = r[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    init()</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&quot;L&quot;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            insert(<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&quot;R&quot;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            insert(l[<span class="number">1</span>], x)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">            k = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            remove(k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&quot;IL&quot;</span>:</span><br><span class="line">            k, x = <span class="built_in">int</span>(op[<span class="number">1</span>]), <span class="built_in">int</span>(op[<span class="number">2</span>])</span><br><span class="line">            insert(l[k + <span class="number">1</span>], x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, x = <span class="built_in">int</span>(op[<span class="number">1</span>]), <span class="built_in">int</span>(op[<span class="number">2</span>])</span><br><span class="line">            insert(k + <span class="number">1</span>, x)</span><br><span class="line">    i = r[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(e[i], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        i = r[i]</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">// *********栈</span></span><br><span class="line"><span class="type">int</span> stk[N],tt;<span class="comment">//tt表示栈顶(是指向一个元素的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure>
<h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            stk[++tt]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;(tt?<span class="string">&quot;NO&quot;</span>:<span class="string">&quot;YES&quot;</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;stk[tt]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：借助python特性简化一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    stk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            stk.append(x)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;pop&#x27;</span>:</span><br><span class="line">            stk.pop()</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;empty&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(stk) <span class="keyword">else</span> <span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(stk[-<span class="number">1</span>])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>如果所有字符的运算顺序都相同，也就是说从左往右算和从右往左算都无区别，那我们可以将所有数字压进栈中，所有操作符压进栈中，然后做<code>eval</code>操作，但是并不是所有情况我们都可以从后往前直接算的</p>
<ul>
<li>如果前面运算符的优先级高的话或者相等（运算符优先级相等的话从左往右算），我们必须先算前面的操作，如<code>3*5-2</code>，就不能先算5-2</li>
<li>如果前面有括号，就必须先算括号里的，如<code>(3-2)*5</code>，就不能先算2*5</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();<span class="comment">//b是右边的</span></span><br><span class="line">    <span class="keyword">auto</span> a=num.<span class="built_in">top</span>();num.<span class="built_in">pop</span>();<span class="comment">//a是左边的</span></span><br><span class="line">    <span class="keyword">auto</span> c=op.<span class="built_in">top</span>();op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>) x=a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) x=a-b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>) x=a*b;</span><br><span class="line">    <span class="keyword">else</span> x=a/b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;<span class="comment">//优先级定义</span></span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c=str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))<span class="comment">//数字则构造数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>,j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;str.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">isdigit</span>(str[j]))<span class="comment">//构造x</span></span><br><span class="line">                x=x*<span class="number">10</span>+str[j++]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);<span class="comment">//处理括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>)<span class="comment">//处理括号前算的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//处理优先级前算的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>()&amp;&amp;op.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;pr[op.<span class="built_in">top</span>()]&gt;=pr[c]) <span class="built_in">eval</span>();<span class="comment">//算完前面的</span></span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">while</span>(op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();<span class="comment">//接下来就没有异常情况了，可以直接算了</span></span><br><span class="line">    cout&lt;&lt;num.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pr = &#123;<span class="string">&quot;+&quot;</span>: <span class="number">1</span>, <span class="string">&quot;-&quot;</span>: <span class="number">1</span>, <span class="string">&quot;*&quot;</span>: <span class="number">2</span>, <span class="string">&quot;/&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">num = []</span><br><span class="line">op = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myeval</span>():</span><br><span class="line">    b = num.pop()</span><br><span class="line">    a = num.pop()</span><br><span class="line">    c = op.pop()</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        x = a + b</span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        x = a - b</span><br><span class="line">    <span class="keyword">elif</span> c == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        x = a * b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(a / b)</span><br><span class="line">    num.append(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    exp = <span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(exp):</span><br><span class="line">        <span class="keyword">if</span> exp[i].isdigit():</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(exp) <span class="keyword">and</span> exp[j].isdigit():</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            num.append(<span class="built_in">int</span>(exp[i:j]))</span><br><span class="line">            i = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> exp[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            op.append(exp[i])</span><br><span class="line">        <span class="keyword">elif</span> exp[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            <span class="keyword">while</span> op[-<span class="number">1</span>] != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                myeval()</span><br><span class="line">            op.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(op) <span class="keyword">and</span> op[-<span class="number">1</span>] != <span class="string">&quot;(&quot;</span> <span class="keyword">and</span> pr[op[-<span class="number">1</span>]] &gt;= pr[exp[i]]:</span><br><span class="line">                myeval()</span><br><span class="line">            op.append(exp[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(op):</span><br><span class="line">        myeval()</span><br><span class="line">    <span class="built_in">print</span>(num[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>栈和队列书写思路对比：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">// *********栈</span></span><br><span class="line"><span class="type">int</span> stk[N],tt;<span class="comment">//tt表示栈顶(是指向一个元素的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">//*********队列</span></span><br><span class="line"><span class="type">int</span> q[N],hh,tt=<span class="number">-1</span>;<span class="comment">//hh为队头，tt为队尾(包含元素的),hh为队头(同样包含元素),队头在低位，队尾在高位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//取出队尾元素</span></span><br><span class="line">q[tt]</span><br></pre></td></tr></table></figure>
<p>模拟队列操作代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[ ++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) hh ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (hh &lt;= tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python版本</p>
<p>写法1：时间复杂度比较高，因为append(op[1])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        ch = op[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">            q.append(op[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;empty&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(q) <span class="keyword">else</span> <span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> ch == <span class="string">&#x27;pop&#x27;</span>:</span><br><span class="line">            q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(q[<span class="number">0</span>])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>写法2：降低了时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q = []</span><br><span class="line">def main():</span><br><span class="line">    hh,tt = 0,-1</span><br><span class="line">    num = int(input())</span><br><span class="line">    for i in range(num):</span><br><span class="line">        op = input().split()</span><br><span class="line">        ch = op[0]</span><br><span class="line">        if ch == &#x27;push&#x27;:</span><br><span class="line">            tt += 1</span><br><span class="line">            q.append(op[1])</span><br><span class="line">        elif ch == &#x27;pop&#x27;:</span><br><span class="line">            hh += 1</span><br><span class="line">        elif ch == &#x27;empty&#x27;:</span><br><span class="line">            print(&#x27;NO&#x27; if tt&gt;=hh else &#x27;YES&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(q[hh])</span><br><span class="line">main()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>写法三：python库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    q = deque()</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">            q.append(op[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;pop&#x27;</span>:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;empty&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(q) <span class="keyword">else</span> <span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(q[<span class="number">0</span>])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>若<code>a[x]&gt;=a[y]</code>且<code>x&gt;y</code>，则<code>a[x]</code>可以被替换为y，故如果用stk栈结构来存储一个数前面的数：</p>
<p>若当前数下标为5，目前栈内的数下标为1~4，由上述说法可知，左侧标的三个红色圈的数都是无效的，故可被替换为新的数，最终形成红色的线，实质上是维持栈中元素随着下标单调递增，不能出现下折或者直线的情况</p>
<p><img src="/2022/12/14/algorithm/image-20230116154159337.png" alt="image-20230116154159337" style="zoom:80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;<span class="comment">//若队列不为空，且栈顶大于等于x，栈顶将不会再被用到</span></span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);<span class="comment">//若找到stk[tt]&lt;x,满足单调栈</span></span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">stk = [<span class="number">0</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tt = -<span class="number">1</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    lst = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">while</span> tt&gt;=<span class="number">0</span> <span class="keyword">and</span> stk[tt]&gt;= lst[i]:</span><br><span class="line">            tt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tt &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(stk[tt],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        tt += <span class="number">1</span></span><br><span class="line">        stk[tt] = lst[i]</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="滑动队列"><a href="#滑动队列" class="headerlink" title="滑动队列"></a>滑动队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i-k+1~i是当前队列</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;<span class="comment">//首先踢掉不在队列中的</span></span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;<span class="comment">//保持队头到队尾递增</span></span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        <span class="comment">//前面一截是不够队列的</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;</span><br><span class="line">         <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;</span><br><span class="line">         q[++tt]=i;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1000010</span></span><br><span class="line">q = [<span class="number">0</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    hh,tt = <span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">    n,k = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> tt&gt;=hh <span class="keyword">and</span> q[hh]&lt;i-k+<span class="number">1</span>:</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tt&gt;=hh <span class="keyword">and</span> a[q[tt]]&gt;=a[i]:</span><br><span class="line">            tt -= <span class="number">1</span></span><br><span class="line">        tt += <span class="number">1</span></span><br><span class="line">        q[tt] = i</span><br><span class="line">        <span class="keyword">if</span> i-k+<span class="number">1</span>&gt;=<span class="number">0</span>:</span><br><span class="line">            res.append(a[q[hh]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,res)))</span><br><span class="line">    res.clear()</span><br><span class="line">    hh,tt = <span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> tt&gt;=hh <span class="keyword">and</span> q[hh]&lt;i-k+<span class="number">1</span>:</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tt&gt;=hh <span class="keyword">and</span> a[q[tt]]&lt;=a[i]:</span><br><span class="line">            tt -= <span class="number">1</span></span><br><span class="line">        tt += <span class="number">1</span></span><br><span class="line">        q[tt] = i</span><br><span class="line">        <span class="keyword">if</span> i-k+<span class="number">1</span>&gt;=<span class="number">0</span>:</span><br><span class="line">            res.append(a[q[hh]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,res)))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>deque：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">q = deque()</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,k = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> <span class="keyword">and</span> i-k+<span class="number">1</span>&gt;q[<span class="number">0</span>]:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> <span class="keyword">and</span> a[q[-<span class="number">1</span>]]&gt;=a[i]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i-k+<span class="number">1</span>&gt;=<span class="number">0</span>:</span><br><span class="line">            res.append(a[q[<span class="number">0</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,res)))</span><br><span class="line">    res.clear()</span><br><span class="line">    q.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> <span class="keyword">and</span> i-k+<span class="number">1</span>&gt;q[<span class="number">0</span>]:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> <span class="keyword">and</span> a[q[-<span class="number">1</span>]]&lt;=a[i]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i-k+<span class="number">1</span>&gt;=<span class="number">0</span>:</span><br><span class="line">            res.append(a[q[<span class="number">0</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,res)))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>前后缀等长相等</p>
<p><code>p[1,j]=p[i-j+1,i]</code></p>
<p>首先明确前后缀的含义，然后明确next数组的含义</p>
<p>注意总是用i和j+1进行匹配</p>
<p><img src="/2022/12/14/algorithm/image-20230831165116969.png" alt="image-20230831165116969" style="zoom:50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> p[N],s[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;<span class="comment">//习惯从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//i从2开始是因为如果第一位不匹配无法再退了,该循环计算ne[i]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j=ne[j];<span class="comment">//如果j还有退路,即&gt;0,且需要退,则退</span></span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;<span class="comment">//若匹配上了</span></span><br><span class="line">        ne[i]=j;<span class="comment">//记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)<span class="comment">//进行匹配,从待匹配串的第一位开始匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i-n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    p = <span class="string">&#x27; &#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    ne = [<span class="number">0</span>] * N</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> p[i]!=p[j+<span class="number">1</span>]:</span><br><span class="line">            j = ne[j]</span><br><span class="line">        <span class="keyword">if</span> p[i] == p[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        ne[i] = j</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> s[i]!=p[j+<span class="number">1</span>]:</span><br><span class="line">            j = ne[j]</span><br><span class="line">        <span class="keyword">if</span> s[i] == p[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == n:</span><br><span class="line">            <span class="built_in">print</span>(i-n+<span class="number">1</span>-<span class="number">1</span>,end =<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j = ne[j] <span class="comment"># 借助已有优势继续匹配</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><blockquote>
<p>Trie：高效地存储和查找字符串，是一个集合的数据结构</p>
</blockquote>
<p>Trie树中有个二维数组 son[N][26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1][0]=2表示1结点的一个值为a的子结点为结点2;如果son[1][0] = 0，则意味着没有值为a子结点。这里的son[N]/[26]相当于链表中的ne[N]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//从根结点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u =str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; <span class="comment">//没有该子结点就创建一个</span></span><br><span class="line">        p = son[p][u]; <span class="comment">//走到p的子结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; <span class="comment">// cnt相当于链表中的e[idx]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树字符串统计"><a href="#Trie树字符串统计" class="headerlink" title="Trie树字符串统计"></a>Trie树字符串统计</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>*str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>) son[p][u]=++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span>*str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">son = [[<span class="number">0</span>]*<span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">cnt = [<span class="number">0</span>]*N</span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    p = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> exp:</span><br><span class="line">        u = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> son[p][u] == <span class="number">0</span>:</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            son[p][u] = idx</span><br><span class="line">        p = son[p][u]</span><br><span class="line">    cnt[p] += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> exp:</span><br><span class="line">        u = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> son[p][u] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = son[p][u]</span><br><span class="line">    <span class="keyword">return</span> cnt[p]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        op,ch = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            insert(ch)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = query(ch)</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h3><p>有点贪心的味道</p>
<p>这道题的启示是：字典树不单单可以高效存储和查找字符串集合,还可以存储二进制数字<br>思路:将每个数以二进制方式存入字典树,找的时候从最高位去找有无该位的异.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">3100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>],idx,a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            p=son[p][!u];</span><br><span class="line">        &#125;<span class="keyword">else</span> p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">search</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">3100010</span></span><br><span class="line">son = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        u = exp&gt;&gt;i&amp;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> son[p][u] == <span class="number">0</span>:</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            son[p][u] = idx</span><br><span class="line">        p = son[p][u]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        u = exp&gt;&gt;i&amp;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> son[p][<span class="number">1</span>^u] == <span class="number">0</span>:</span><br><span class="line">            p = son[p][u]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span>&lt;&lt;i</span><br><span class="line">            p = son[p][<span class="number">1</span>^u]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    lst = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        insert(item)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">        res = <span class="built_in">max</span>(res,query(item))</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合中</li>
</ol>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储他的父节点，<code>p[x]</code>表示x的父节点</p>
<p>问题一：如何判断树根：<code>if(p[x]==x)</code></p>
<p>问题二：如何求x的集合编号：<code>while(p[x]!=x) x=p[x];</code></p>
<p>问题三：如何合并两个集合：假设p[x]是x的集合编号，p[y]是y的集合编号。合并：<code>p[x]=y</code></p>
<p>近乎<code>O(1)</code>的效率完成上述两个操作</p>
<p>优化——路径压缩：对问题二找根的过程进行优化，一旦往上走的过程中找到根节点，则把路径上所有节点的的根节点指向根（这样就能实现<code>O(1)</code>）</p>
<h3 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//寻找x点的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//开始时每个点都是独立的</span></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)<span class="comment">//进行m个操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">p = [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">while</span> p[x]!=x:</span><br><span class="line">        p[x] = p[p[x]]</span><br><span class="line">        x = p[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        op,a,b = <span class="built_in">input</span>().split()</span><br><span class="line">        a,b =<span class="built_in">int</span>(a),<span class="built_in">int</span>(b)</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            p[find(a)] = find(b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h3><p>与上题类似，不同之处需要记录数量，这里规定只有根节点的数量属性是有效的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];<span class="comment">//cnt记录数量，只对根节点有效</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        cnt[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>)<span class="comment">//连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(a!=b)</span><br><span class="line">            &#123;</span><br><span class="line">                p[a]=b;</span><br><span class="line">                cnt[b]+=cnt[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;Q1&quot;</span>)<span class="comment">//查询是否连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//查询连通集</span></span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">p = [<span class="number">0</span>]*N</span><br><span class="line">cnt = [<span class="number">1</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">while</span> p[x]!=x:</span><br><span class="line">        p[x] = p[p[x]]</span><br><span class="line">        x = p[x]</span><br><span class="line">    <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            a = find(<span class="built_in">int</span>(op[<span class="number">1</span>]))</span><br><span class="line">            b = find(<span class="built_in">int</span>(op[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">if</span> a!=b:</span><br><span class="line">                p[a] = b</span><br><span class="line">                cnt[b] += cnt[a]</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;Q1&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> find(<span class="built_in">int</span>(op[<span class="number">1</span>])) == find(<span class="built_in">int</span>(op[<span class="number">2</span>])):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(cnt[find(<span class="built_in">int</span>(op[<span class="number">1</span>]))])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><blockquote>
<p>find(x)有两个功能： 1 路径压缩, 2 更新 d[x]<br>假设有一棵树 a -&gt; b -&gt; c -&gt; d， 根节点为 d。d[b]一开始等于 b、c 之间的距离，再执行完路径压缩命令之后，d[b] 等于b、d之间的距离。 d[a] += d[b]: 为了确保d[a]等于 节点a、d的距离，d[b]必须等于b 、d的距离，所以要先调用find(b)更新d[b]， 同时p[x] = find(b)会改变p[x]的值，结果就会变成d[a] += d[d],所以先用一个变量把p[a]的值存起来。 关键就是既要先执行find(p[x])， 又要让d[x] += d[p[x]]中p[x]的值保持不变，所以代码还可以这么写</p>
</blockquote>
<p>这道题的插入方式需要注意，且使用距离来体现与根节点的关系，d%3的情况如下：</p>
<ul>
<li>=0，则与根节点同类型</li>
<li>=1，一层节点，可以吃掉根节点，可以被二层节点吃</li>
<li>=2，二层节点，可以吃掉一层节点，可以被零层节点（根节点同类型）吃</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;n||y&gt;n) res++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> px=<span class="built_in">find</span>(x),py=<span class="built_in">find</span>(y);<span class="comment">//找到x和y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">1</span>)<span class="comment">//两者同类</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若相同根，说明之前构造过，则若不同类(d[x]-d[y]%3!=0)</span></span><br><span class="line">                <span class="comment">//则是非法的</span></span><br><span class="line">                <span class="keyword">if</span>(px==py&amp;&amp;(d[x]-d[y])%<span class="number">3</span>) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px!=py)</span><br><span class="line">                &#123;<span class="comment">//若不同根，说明这是第一次，需要进行构造</span></span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    d[px]=d[y]-d[x];<span class="comment">//需要弥补x-&gt;px-&gt;y的第二段的长度d[x]+d[px]=d[y]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//为2的情况，x可以吃y</span></span><br><span class="line">            <span class="comment">//若px==py，说明之前构造过，则若不是x吃y的关系((d[x]-d[y]-1)%3)=0</span></span><br><span class="line">            <span class="comment">//则是非法的</span></span><br><span class="line">                <span class="keyword">if</span>(px==py&amp;&amp;(d[x]-d[y]<span class="number">-1</span>)%<span class="number">3</span>) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px!=py)</span><br><span class="line">                &#123;<span class="comment">//若是不同根，说明这是第一次，需要进行构造</span></span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    <span class="comment">//满足d[y]+1=d[x]+d[px],即将x的根节点作为y的根节点的子节点之后</span></span><br><span class="line">                    <span class="comment">//还要满足吃的关系（x比y下一层）</span></span><br><span class="line">                    d[px]=d[y]+<span class="number">1</span>-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种更加容易理解的做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取输入的 N 和 K</span></span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化并查集和关系数组</span></span><br><span class="line">    parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]  <span class="comment"># 父节点数组</span></span><br><span class="line">    relation = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># 关系数组，0: 同类, 1: 吃父节点, 2: 被父节点吃</span></span><br><span class="line">    false_count = <span class="number">0</span>  <span class="comment"># 假话计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找函数，带路径压缩和关系更新</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">            original_parent = parent[x]  <span class="comment"># 记录原来的父节点</span></span><br><span class="line">            parent[x] = find(parent[x])  <span class="comment"># 递归找到根节点</span></span><br><span class="line">            <span class="comment"># 更新关系：当前节点的关系 = (当前节点与原来父节点的关系 + 原来父节点与根节点的关系) % 3</span></span><br><span class="line">            relation[x] = (relation[x] + relation[original_parent]) % <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> parent[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并函数，处理两种关系（同类或捕食）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x, y, d</span>):</span><br><span class="line">        root_x = find(x)  <span class="comment"># 找到 x 的根节点</span></span><br><span class="line">        root_y = find(y)  <span class="comment"># 找到 y 的根节点</span></span><br><span class="line">        <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">            <span class="comment"># 如果 x 和 y 已经在同一个集合中，检查关系是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (relation[x] - relation[y] + <span class="number">3</span>) % <span class="number">3</span> != d - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 冲突，返回 False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 不冲突，返回 True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 x 和 y 不在同一个集合中，合并它们</span></span><br><span class="line">            parent[root_x] = root_y  <span class="comment"># 将 root_x 的父节点设为 root_y</span></span><br><span class="line">            <span class="comment"># 更新 root_x 与 root_y 的关系</span></span><br><span class="line">            <span class="comment"># 关系公式：(relation[y] - relation[x] + d - 1 + 3) % 3</span></span><br><span class="line">            relation[root_x] = (relation[y] - relation[x] + d - <span class="number">1</span> + <span class="number">3</span>) % <span class="number">3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理每一条声明</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        d, x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 检查是否超出范围</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; n <span class="keyword">or</span> y &gt; n:</span><br><span class="line">            false_count += <span class="number">1</span>  <span class="comment"># 超出范围，假话</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 检查是否是自己吃自己</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">2</span> <span class="keyword">and</span> x == y:</span><br><span class="line">            false_count += <span class="number">1</span>  <span class="comment"># 自己吃自己，假话</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 尝试合并 x 和 y 的集合，如果返回 False 则表示冲突</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> union(x, y, d):</span><br><span class="line">            false_count += <span class="number">1</span>  <span class="comment"># 冲突，假话</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出假话的总数</span></span><br><span class="line">    <span class="built_in">print</span>(false_count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>整理一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">50010</span></span><br><span class="line">p = [<span class="number">0</span>] * N</span><br><span class="line">r = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> p[x] != x:</span><br><span class="line">        p_x = p[x]</span><br><span class="line">        p[x] = find(p[x])</span><br><span class="line">        r[x] = (r[x] + r[p_x] + <span class="number">3</span>) % <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">op, a, b</span>):</span><br><span class="line">    ra = find(a)</span><br><span class="line">    rb = find(b)</span><br><span class="line">    <span class="keyword">if</span> ra == rb:</span><br><span class="line">        <span class="keyword">if</span> (r[a] - r[b] + <span class="number">3</span>) % <span class="number">3</span> != op - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p[ra] = rb</span><br><span class="line">        r[ra] = (r[b] - r[a] + op - <span class="number">1</span> + <span class="number">3</span>) % <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        op, a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> a &gt; n <span class="keyword">or</span> b &gt; n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> op == <span class="number">2</span> <span class="keyword">and</span> a == b:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> union(op, a, b):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>如何手写一个堆？</p>
<ol>
<li>插入一个数 </li>
<li>求集合当中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素</li>
<li>修改任意一个元素</li>
</ol>
<p>堆——完全二叉树，除了最后一排节点都是非空的，最后一排节点从左到右排列</p>
<p>小根堆——每个点都是小于左右儿子的（可知根节点是堆里面的最小值）</p>
<p><img src="/2022/12/14/algorithm/image-20230308233940858.png" alt="image-20230308233940858"></p>
<p>存储方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1(根节点)</th>
<th>2(根节点左儿子)</th>
<th>3(根节点右儿子)</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>节点x的左儿子：2x</p>
<p>节点x的右儿子：2x+1</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何手写一个堆？完全二叉树 5个操作</span></span><br><span class="line"><span class="comment">//1. 插入一个数         heap[ ++ size] = x; up(size);</span></span><br><span class="line"><span class="comment">//2. 求集合中的最小值   heap[1]</span></span><br><span class="line"><span class="comment">//3. 删除最小值         heap[1] = heap[size]; size -- ;down(1);</span></span><br><span class="line"><span class="comment">//4. 删除任意一个元素   heap[k] = heap[size]; size -- ;up(k); down(k);</span></span><br><span class="line"><span class="comment">//5. 修改任意一个元素   heap[k] = x; up(k); down(k);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//h[i] 表示第i个结点存储的值，i从1开始，2*i是左子节点，2*i + 1是右子节点</span></span><br><span class="line"><span class="comment">//size 既表示堆里存储的元素个数，又表示最后一个结点的下标</span></span><br><span class="line"><span class="type">int</span> h[N], siz; <span class="comment">//堆有两个变量h[N]，size; 这里的size和文件里有冲突，只能改成siz了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;<span class="comment">//t存储三个结点中存在的最小的结点的下标，初始化为当前结点u</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= siz &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>; <span class="comment">// 左子节点存在并且小于当前结点，更新t的下标</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= siz &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//右子节点存在并且小于当前结点，更新t的下标</span></span><br><span class="line">    <span class="keyword">if</span> (t != u)<span class="comment">//如果t==u意味着不用变动，u就是三个结点中拥有最小值的结点下标，否则交换数值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t); <span class="comment">//交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]); </span><br><span class="line">    siz = n; <span class="comment">//初始化size,表示堆里有n 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i --) <span class="built_in">down</span>(i); <span class="comment">//把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉</span></span><br><span class="line">	<span class="comment">//这里无需对所有节点进行down操作，只需要对前n/2个节点进行即可，叶子节点无需再进行down了</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[siz];</span><br><span class="line">        siz --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">h = [<span class="number">0</span>]*N</span><br><span class="line">siz = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">global</span> siz</span><br><span class="line">    t = u</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>*u&lt;=siz <span class="keyword">and</span> h[<span class="number">2</span>*u]&lt;h[t]:</span><br><span class="line">        t = <span class="number">2</span>*u</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>*u+<span class="number">1</span>&lt;=siz <span class="keyword">and</span> h[<span class="number">2</span>*u+<span class="number">1</span>]&lt;h[t]:</span><br><span class="line">        t = <span class="number">2</span>*u + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> t!=u:</span><br><span class="line">        h[t],h[u] = h[u],h[t]</span><br><span class="line">        down(t)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> siz</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    siz = n</span><br><span class="line">    h[<span class="number">1</span>:n+<span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        down(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">print</span>(h[<span class="number">1</span>],end =<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        h[<span class="number">1</span>] = h[siz]</span><br><span class="line">        siz -= <span class="number">1</span></span><br><span class="line">        down(<span class="number">1</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>由于题目要求修改和删除第k个插入的，所以要加入存储映射，为了便于在up、down过程中修改映射，需要两个数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],cnt;</span><br><span class="line"><span class="comment">//ph[i]=j表示第i个插入的数在堆中下标为j</span></span><br><span class="line"><span class="comment">//hp[i]=j表示堆中下标为i的数是第j个插入的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<span class="comment">//交换a、b下标，需要修改ph</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);<span class="comment">//因为下标改了，也需要修改hp</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=cnt&amp;&amp;h[u*<span class="number">2</span>]&lt;h[t]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=cnt&amp;&amp;h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span>&amp;&amp;h[u]&lt;h[u/<span class="number">2</span>])<span class="comment">//有根节点且根节点值没有满足最小堆要求</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,u/<span class="number">2</span>);</span><br><span class="line">        u&gt;&gt;=<span class="number">1</span>;<span class="comment">//u=u/2;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            cnt++;</span><br><span class="line">            m++;<span class="comment">//用m作为下标，因为cnt会减少而m不会减少</span></span><br><span class="line">            ph[m]=cnt,hp[cnt]=m;<span class="comment">//cnt为在堆中下标，而m为第几个插入的数</span></span><br><span class="line">            h[cnt]=x;<span class="comment">//插在最后的位置，然后向上up</span></span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cnt);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k=ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k,cnt);</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">h = [<span class="number">0</span>]*N</span><br><span class="line">hp = [<span class="number">0</span>]*N</span><br><span class="line">ph = [<span class="number">0</span>]*N</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">a,b</span>):</span><br><span class="line">    ph[hp[a]],ph[hp[b]] = ph[hp[b]],ph[hp[a]]</span><br><span class="line">    hp[a],hp[b] = hp[b],hp[a]</span><br><span class="line">    h[a],h[b] = h[b],h[a]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">while</span> u//<span class="number">2</span> <span class="keyword">and</span> h[u]&lt;h[u//<span class="number">2</span>]:</span><br><span class="line">        swap(u,u//<span class="number">2</span>)</span><br><span class="line">        u = u//<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    t = u</span><br><span class="line">    <span class="keyword">if</span> u*<span class="number">2</span>&lt;=cnt <span class="keyword">and</span> h[u*<span class="number">2</span>]&lt;h[t]:</span><br><span class="line">        t = u*<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> u*<span class="number">2</span>+<span class="number">1</span>&lt;=cnt <span class="keyword">and</span> h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t]:</span><br><span class="line">        t = u*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> t!=u:</span><br><span class="line">        swap(u,t)</span><br><span class="line">        down(t)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            h[cnt] = x</span><br><span class="line">            ph[m] = cnt</span><br><span class="line">            hp[cnt] = m</span><br><span class="line">            up(cnt)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;PM&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(h[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] == <span class="string">&#x27;DM&#x27;</span>:</span><br><span class="line">            swap(<span class="number">1</span>,cnt)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">            down(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> op[<span class="number">0</span>] ==<span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            k = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">            idx = ph[k]</span><br><span class="line">            swap(idx,cnt)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">            down(idx)</span><br><span class="line">            up(idx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k,x = <span class="built_in">map</span>(<span class="built_in">int</span>,op[<span class="number">1</span>:])</span><br><span class="line">            idx = ph[k]</span><br><span class="line">            h[idx] = x</span><br><span class="line">            down(idx)</span><br><span class="line">            up(idx)</span><br><span class="line">main()      </span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h3><p>求质数的方法：</p>
<p><img src="/2022/12/14/algorithm/image-20230309152402474.png" alt="image-20230309152402474"></p>
<p>关于哈希函数对应的数组的大小：如果用拉链法，则和数多少差不多即可，如果用开放寻址法，则设置为该数的两倍</p>
<p>开放寻址法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200003</span>,null=<span class="number">0x3f3f3f3f</span>;<span class="comment">//设置长度为两倍，设置空标志</span></span><br><span class="line"><span class="comment">//注意null四个3f，memset对字节做的</span></span><br><span class="line"><span class="type">int</span> h[N];<span class="comment">//开放寻址法类似于找坑位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//寻找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">while</span>(h[t]!=null&amp;&amp;h[t]!=x)<span class="comment">//当前坑位被占，需要向后寻找</span></span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t==N) t=<span class="number">0</span>;<span class="comment">//循环查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;<span class="comment">//不一定找对！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);<span class="comment">//设置空标志位</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    string op;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>) h[<span class="built_in">find</span>(x)]=x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[<span class="built_in">find</span>(x)]==null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拉链法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//h数组类似于head指针的数组</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//头插法</span></span><br><span class="line">    <span class="type">int</span> k=(x%N+N)%N;<span class="comment">//哈希函数值,需要处理负数</span></span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=h[k];</span><br><span class="line">    h[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">//类似于单链表init的时候要将head初始化为-1</span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python的defaultdict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        num = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            d[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> d[num] == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>拉链法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100003</span></span><br><span class="line">h = [-<span class="number">1</span>]*N</span><br><span class="line">e = [<span class="number">0</span>]*N</span><br><span class="line">ne = [<span class="number">0</span>]*N</span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    k = num%N</span><br><span class="line">    e[idx] = num</span><br><span class="line">    ne[idx] = h[k]</span><br><span class="line">    h[k] = idx</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">num</span>):</span><br><span class="line">    k = num%N</span><br><span class="line">    i = h[k]</span><br><span class="line">    <span class="keyword">while</span> i!=-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> e[i] == num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = ne[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        num = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            insert(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(num):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>寻址法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">200003</span></span><br><span class="line">null = <span class="number">0x3f3f3f3f</span></span><br><span class="line">h = [null]*N</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    k = x % N</span><br><span class="line">    <span class="keyword">while</span> h[k]!=null <span class="keyword">and</span> h[k]!=x:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == N:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        op = <span class="built_in">input</span>().split()</span><br><span class="line">        num = <span class="built_in">int</span>(op[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            k = find(num)</span><br><span class="line">            h[k] = num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = find(num)</span><br><span class="line">            <span class="keyword">if</span> h[k]!=null:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>前求字符串的前缀哈希值</p>
<p>h[i]字符串前i位字符串对应的哈希值</p>
<p>我们将字符串当做一个p进制的数来看待</p>
<p>在字符串哈希中，我们没有处理冲突，靠经验定理来保证不冲突，将字符串看做是p进制的数</p>
<p>根据经验定理，p取131或者1331，得到的数模上2的64次方，可保证完全散列，由于数据类型<code>unsigned int</code>的值域恰好为2的64次方，故可以直接使用<code>unsigned int</code>存储，溢出即为取模</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,P=<span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N],p[N];<span class="comment">//p数组存储每一位上的基本单元</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*P+str[i];<span class="comment">//直接用的ASCII码</span></span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">P = <span class="number">131</span></span><br><span class="line">Q = <span class="number">1</span>&lt;&lt;<span class="number">64</span></span><br><span class="line">h = [<span class="number">0</span>]*N</span><br><span class="line">p = [<span class="number">0</span>]*N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">l,r</span>):</span><br><span class="line">    <span class="keyword">return</span> (h[r] - h[l-<span class="number">1</span>]*p[r-l+<span class="number">1</span>])%Q</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> P</span><br><span class="line">    <span class="keyword">global</span> Q</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        h[i] = (h[i-<span class="number">1</span>]*P + <span class="built_in">ord</span>(s[i]))%Q</span><br><span class="line">        p[i] = p[i-<span class="number">1</span>]*P % Q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        l1,r1,l2,r2 = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> find(l1,r1) == find(l2,r2):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Yes&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;No&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><p>1.DFS：递归结束条件的选择+状态标记+递归后的恢复<br>2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态<br>3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路<br>4.树和图的存储：邻接表 h[N], e[N], ne[N], idx<br>5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可</p>
<p>点的数量和边的数量，若点的数量的平方与边的数量大致相同，则为稠密图</p>
<p>邻接矩阵去重边用<code>min</code>，邻接表里面无需去重边</p>
<p>无向图存储的时候边的数量要开成给定边数量的一倍大小</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="排列数字"><a href="#排列数字" class="headerlink" title="排列数字"></a>排列数字</h3><p>典型排列树，但是需要按照字典序来做，下面这种做法会有些不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        <span class="built_in">DFS</span>(t+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=i;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acwing提供的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> state)</span><span class="comment">//用整型数state记录每个数的使用情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(state&gt;&gt;i&amp;<span class="number">1</span>))<span class="comment">//检查某个数是否被用过</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[u]=i+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>,state+(<span class="number">1</span>&lt;&lt;i));<span class="comment">//注意这里并没有改变源state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h3><p>排列树，dg和udg用来判断是否在对角线上有冲突，主对角线检查下标y-x+n是否冲突，副对角线检查x+y是否冲突</p>
<p>同时由于对角线数量是n的两倍左右，N数量要开两倍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> x[N],dg[N],udg[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==x[i]) <span class="built_in">printf</span>(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        <span class="keyword">if</span>(!dg[t+x[t]]&amp;&amp;!udg[n+x[t]-t])</span><br><span class="line">        &#123;</span><br><span class="line">            dg[t+x[t]]=udg[n+x[t]-t]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            dg[t+x[t]]=udg[n+x[t]-t]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acwing解法，差不多</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>分支限界框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue Q;</span><br><span class="line"><span class="type">int</span> bestw;</span><br><span class="line">Node k=<span class="keyword">new</span> <span class="built_in">node</span>();<span class="comment">//初始化根节点</span></span><br><span class="line">set k;<span class="comment">//设置k,假设k有属性cw,level</span></span><br><span class="line">Q.<span class="built_in">push</span>(k);</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    Node cn = Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> level=cn.level;</span><br><span class="line">    <span class="keyword">if</span>(level&gt;n)&#123;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node:cn的后继)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(约束函数/限界函数)</span><br><span class="line">        &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            set tmp;<span class="comment">//设置tmp参数</span></span><br><span class="line">            Q.<span class="built_in">push</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS相对而言更简单，通常无需考虑level和一些剪枝</p>
<h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>首先用回溯法做了一遍，果然超时了，回溯剪枝不够强大</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cw,cbest=<span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n&amp;&amp;y==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw&lt;cbest) cbest=cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cw&gt;cbest) <span class="keyword">return</span>;</span><br><span class="line">    a[x][y]=<span class="number">1</span>;</span><br><span class="line">    cw++;</span><br><span class="line">    <span class="keyword">if</span>(!a[x][y<span class="number">-1</span>]) <span class="built_in">dfs</span>(x,y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!a[x][y+<span class="number">1</span>]) <span class="built_in">dfs</span>(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!a[x+<span class="number">1</span>][y]) <span class="built_in">dfs</span>(x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="keyword">if</span>(!a[x<span class="number">-1</span>][y]) <span class="built_in">dfs</span>(x<span class="number">-1</span>,y);</span><br><span class="line">    a[x][y]=<span class="number">0</span>;</span><br><span class="line">    cw--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">1</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;cbest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遂使用可爱的BFS！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];<span class="comment">//g数组记录地图,d数组记录走到此处的距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始化根节点</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//小技巧</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())<span class="comment">//若队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();<span class="comment">//取队列元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//扩展</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=t.first+dx[i];</span><br><span class="line">            <span class="type">int</span> y=t.second+dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;g[x][y]==<span class="number">0</span>&amp;&amp;d[x][y]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y]=d[t.first][t.second]+<span class="number">1</span>;<span class="comment">//配置扩展节点</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);<span class="comment">//加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><p>主要难点在于状态的表示和转换上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; d;</span><br><span class="line">    q.<span class="built_in">push</span>(state);<span class="comment">//初始根节点</span></span><br><span class="line">    d[state]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//移动的小tip</span></span><br><span class="line">    </span><br><span class="line">    string end=<span class="string">&quot;12345678x&quot;</span>;<span class="comment">//终结状态</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())<span class="comment">//若队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t==end) <span class="keyword">return</span> d[t];<span class="comment">//取出后进行判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> distance=d[t];<span class="comment">//取节点距离方便后面扩展</span></span><br><span class="line">        <span class="type">int</span> k=t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//方便修改和表示状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x=k/<span class="number">3</span>,y=k%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">3</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]);</span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))</span><br><span class="line">                &#123;</span><br><span class="line">                    d[t]=distance+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[<span class="number">3</span>*a+b],t[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    string state;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        state+=*s;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>(state)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h2><p>树和图的存储方式，树是特殊的图，故介绍图的存储方式</p>
<p>图：有向图、无向图</p>
<p>有向图：a-&gt;b</p>
<p>无向图：a-&gt;b,b-&gt;a</p>
<p>故只需要考虑有向图的存储方式</p>
<ul>
<li>领接矩阵：a-&gt;b，g[a][b]=w，记录边权，不能存储重边（a-&gt;b有多条边，但也可以直接选一条）</li>
<li>邻接表：</li>
</ul>
<p><img src="/2022/12/14/algorithm/image-20230311111455881.png" alt="image-20230311111455881" style="zoom:50%;"><img src="/2022/12/14/algorithm/image-20230311111508913.png" alt="image-20230311111508913" style="zoom:50%;"></p>
<p>（数组建立邻接表） 树/图的dfs<br>//邻接表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树/图的bfs模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要标记数组st[N],  遍历节点的每个相邻的便</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;<span class="comment">//搜索节点u对应的节点</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 标记一下，记录为已经被搜索过了，下面进行搜索过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>本题的本质是树的dfs， 每次dfs可以确定以u为重心的最大连通块的节点数，并且更新一下ans。</p>
<p>也就是说，dfs并不直接返回答案，而是在每次更新中迭代一次答案。</p>
<p>这样的套路会经常用到，在 树的dfs 题目中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> ans=N;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u]=<span class="literal">true</span>;<span class="comment">//标记已经遍历完</span></span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;<span class="comment">//如果遍历过，则继续遍历下一个子节点</span></span><br><span class="line">        <span class="type">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//子节点的子树的节点数量</span></span><br><span class="line">        size=<span class="built_in">max</span>(size,s);<span class="comment">//计算子树节点的最大值</span></span><br><span class="line">        sum+=s;<span class="comment">//为了计算当前节点所在子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    size=<span class="built_in">max</span>(size,n-sum<span class="number">-1</span>);<span class="comment">//去掉当前节点后连通块的最大节点数</span></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,size);<span class="comment">//选择最小值</span></span><br><span class="line">    <span class="keyword">return</span> sum+<span class="number">1</span>;<span class="comment">//返回的应该是当前节点和以其为根节点的子树的全部节点的个数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树与图的广度优先遍历"><a href="#树与图的广度优先遍历" class="headerlink" title="树与图的广度优先遍历"></a>树与图的广度优先遍历</h2><h3 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="有向图的拓扑序列"><a href="#有向图的拓扑序列" class="headerlink" title="有向图的拓扑序列"></a>有向图的拓扑序列</h3><p>有向图才有拓扑序，并非所有图都有拓扑序列，有向无环图一定存在一个入度为0的点，一定存在拓扑序列</p>
<p>所谓拓扑序列，要求A-&gt;B，A在拓扑序列中要求排列在B前面，所有的边都由前指向后</p>
<p>可所有知入度为0的节点可作为拓扑序列的最前位置，思路如下：</p>
<p><img src="/2022/12/14/algorithm/image-20230311174125677.png" alt="image-20230311174125677" style="zoom: 50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">//队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;<span class="comment">//队头，队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//首先将所有入度为0的点加入队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[++tt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q[hh++];<span class="comment">//弹出队首元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])<span class="comment">//遍历其在图中相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(--d[j]==<span class="number">0</span>)<span class="comment">//如果入度为0，则加入队列中</span></span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>;<span class="comment">//所有节点都入队过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">topsort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>稠密图用领接矩阵，稀疏图用邻接链表</p>
<p><img src="/2022/12/14/algorithm/image-20230311205637682.png" alt="image-20230311205637682"></p>
<h3 id="朴素版本"><a href="#朴素版本" class="headerlink" title="朴素版本"></a>朴素版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"></span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小堆优化"><a href="#最小堆优化" class="headerlink" title="最小堆优化"></a>最小堆优化</h3><p>priority_queue的定义方法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//本题使用pair来做，pair的first含义为距离，second含义为编号</span></span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);<span class="comment">//先设置为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//起点设置为0</span></span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;<span class="comment">//定义最小堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);<span class="comment">//到第一个节点的距离时0</span></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();<span class="comment">//取堆顶节点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver=t.second,distance=t.first;<span class="comment">//取节点对应的节点编号和距离</span></span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;<span class="comment">//若已经扩展过，则无需扩展</span></span><br><span class="line">        st[ver]=<span class="literal">true</span>;<span class="comment">//扩展该节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];<span class="comment">//取节点编号</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[ver]+w[i])<span class="comment">//更新其后继节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[ver]+w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);<span class="comment">//加入到队列中</span></span><br><span class="line">                <span class="comment">//注意这里没有删掉以前这个节点在队列中的信息，因为是优先队列</span></span><br><span class="line">                <span class="comment">//且每个节点也只能扩展一次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>可以处理负权重的情况，可以检测负环但是时间复杂度较高</p>
<blockquote>
<p>串联：由于这个算法的特性决定，每次更新得到的必然是在多考虑 1 条边之后能得到的全局的最短路。而串联指的是一次更新之后考虑了不止一条边：由于使用了松弛，某节点的当前最短路依赖于其所有入度的节点的最短路；假如在代码中使用dist[e.b]=min(dist[e.b],dist[e.a] + e.c);，我们无法保证dist[e.a]是否也在本次循环中被更新，如果被更新了，并且dist[e.b] &gt; dist[e.a] + e.c，那么会造成当前节点在事实上“即考虑了一条从某个节点指向a的边，也考虑了a-&gt;b”，共两条边。而使用dist[e.b]=min(dist[e.b],last[e.a] + e.c);，可以保证a在dist更新后不影响对b的判定，因为后者使用last数组，保存着上一次循环中的dist的值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];<span class="comment">//是用来避免串联影响的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e=edges[j];</span><br><span class="line">            dist[e.b]=<span class="built_in">min</span>(dist[e.b],last[e.a]+e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<span class="comment">//n个点m条边k步</span></span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        edges[i]=&#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dist[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p>改进bellman_ford算法，dist[v]=dist[w]+w仅当前面的节点w的dist发生变化才更新，具体而言需要用广搜来做</p>
<p>还是基于bellman方程来做的，但是只动态加入前继节点改变的后继：<code>dist[x]=dist[t]+w[i]</code></p>
<h3 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h3><p><a href="https://www.acwing.com/solution/content/9306/">AcWing 851. SPFA算法 - AcWing</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],ne[N],w[N],e[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],ne[M],w[M],e[M],idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题一：为什么dt数组不用初始化为0x3f3f3f3f，以及为什么初始化要把所有点入队？<br>答：dt数组的初始值是多少都不影响，因为dt数组在这里记录的不是最短路径。首先，我们理解初始化时为什么把所有点都加入队列中，在求1开始到n的最短路时，我们只把1入队了且让dt[1] = 0，目的是让1成为开始时唯一一个更新了dt数组的点，然后在根据已更新dt数组的这些点去更新他的出边（这就是spfa改良bellman的精髓）。但是负环可能不在点1的后继上（可以自行构造，把1放在拓扑图的中断位置，负环在点1的前面），所以要把所有点入队。所有看到这就懂了，dt数组的意义不是记录最短路径，而且来更新后继节点的，如果某个点的dt更新过了，那么就可以用这个点来更新他的后继节点（在求最短路问题里，一个点距离初始点的距离边短了，是不是尝试用这个点去更新他的后继节点，可能使得后继节点的最短距离也变小）。</p>
<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Floyd求最短路"><a href="#Floyd求最短路" class="headerlink" title="Floyd求最短路"></a>Floyd求最短路</h3><p>三重循环！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化图</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) d[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        d[a][b]=<span class="built_in">min</span>(d[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//floyd</span></span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="comment">//轮询</span></span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> t=d[a][b];</span><br><span class="line">        <span class="keyword">if</span>(t&gt;INF/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title></a><img src="/2022/12/14/algorithm/image-20230316203824250.png" alt="image-20230316203824250"></h2><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="Prim算法求最小生成数"><a href="#Prim算法求最小生成数" class="headerlink" title="Prim算法求最小生成数"></a>Prim算法求最小生成数</h3><p>朴素版本：类似于dijkstra算法</p>
<p>思路：</p>
<ul>
<li>与dijkstra不同，prim需要迭代n次</li>
<li>最小生成树是针对无向图的，所以在读入边的时候，需要赋值两次</li>
<li>要先累加再更新，避免t有自环，影响答案的正确性。后更新不会影响后面的结果么？不会的，因为dist[i]为i到集合S的距离，当t放入集合后，其dist[t]就已经没有意义了，再更新也不会影响答案的正确性。</li>
<li>需要特判一下第一次迭代，在我们没有做特殊处理时，第一次迭代中所有点到集合S的距离必然为无穷大，而且不会进行更新(也没有必要)，所以不需要将这条边(第一次迭代时，找到的距离集合S最短的边)累加到答案中，也不能认定为图不连通。</li>
<li>如果需要设置起点为i的话，在初始化dist数组之后，dist[i] = 0即可，这样也可以省去每轮迭代中的两个if判断。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],dist[N],n,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">            &#123;</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[t]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=<span class="built_in">min</span>(dist[i],g[t][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="求最小生成数"><a href="#求最小生成数" class="headerlink" title="求最小生成数"></a>求最小生成数</h3><ul>
<li>将所有边按权重从小到大排序 $O(nlogn)$</li>
<li>枚举每条边<code>a,b</code>，权重c；if<code>a,b</code>不连通，将这条边也加入集合（并查集的使用） $(1)$</li>
</ul>
<p>稀疏图里用kruskal</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//每个节点的爷</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Edge&amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;<span class="comment">//重载方便排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//并查集找爷</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//你我都是爷</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w;</span><br><span class="line">        a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;<span class="comment">//连通</span></span><br><span class="line">            res+=w;<span class="comment">//加上这条边</span></span><br><span class="line">            cnt++;<span class="comment">//又连通了一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;<span class="comment">//有节点没有加进来，说明图不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/14/algorithm/image-20230730163510347.png" alt="image-20230730163510347"></p>
<h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><p>一个图是二分图，当前仅当图中不含奇数环（由于图中不含奇数环，所以染色过程一定没有矛盾）</p>
<p>二分图指图能分为两个集合，每个集合内部没有边，边都在集合之间（用两种颜色染色）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> colour[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colour[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!colour[j])<span class="comment">//若没有染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//因为i染了c，所以后继要染相反的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(colour[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果染了和i相同的颜色，则冲突</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果未发生冲突，则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!colour[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>姑娘 j 遇到新的追求者的心理活动：如果原来的男朋友有备胎，我就绿他，如果没有，那我看他太可怜了，就一直跟他在一起吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n1,n2,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//为男生x找女生</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];<span class="comment">//女生的编号</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])<span class="comment">//这个女生之前没有尝试匹配过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j]=<span class="literal">true</span>;<span class="comment">//现在尝试过了</span></span><br><span class="line">            <span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">find</span>(match[j]))<span class="comment">//如果喜欢的女生单身,或者能变成前任</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;<span class="comment">//为男生找到女生</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><ol>
<li>数论</li>
<li>组合计数</li>
<li>高斯消元</li>
<li>简单博弈论</li>
</ol>
<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>定义：在大于1的整数中，如果值包含1和本身这两个约数，就被称之为质数，或者叫素数</p>
<p>所有小于等于1的数既不是质数也不是合数</p>
<p>（1）质数的判定——试除法</p>
<p>（2）分解质因数——试除法：从小到达枚举所有数，</p>
<h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><p>只枚举较小的约数以减小时间复杂度，时间复杂度$O(sqrt(n))$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_prime</span>(m)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因子"><a href="#分解质因子" class="headerlink" title="分解质因子"></a>分解质因子</h3><p>质因数是指，能够被n 整除（也就是他的约数或者叫因子），并且本身是质数的数。</p>
<ul>
<li><p>我们可以从前往后去筛，而不需要判断这个数是否是质数，举个例子n=12,那么2到12之间一共有2,3,4,5,6,7,8,9,10,11 这几个数，当i=2时，会筛掉2,4,6这几个数（前提是这几个数是ta的约数），4这个合数就是 2*2 被筛掉了 ，6同理，也就是合数等于质数和质数的乘积,不用担心该因子不是质数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n/=i;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,s);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>n中至多只包含一个大于sqrt(n)的质因子，故可以先枚举小于sqrt(n)的质因子，然后单独考虑那个大于sqrt(n)的质因子</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i,s++;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;<span class="comment">//剩下一个大于根号x的质因子（该数得是大于1的）</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="built_in">divide</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><p>埃式筛法：<strong>当一个数是质数时</strong>（因为合数等价于用其质因子筛，对于合数我们可以直接跳过），即未被筛，则加入，同时用他向后筛他的倍数，可以想象，以他为因数的合数会被筛掉，如果后面的某个数未被筛，说明他前面的数都不是他的因数，满足质数定义，故有效。埃氏筛法复杂度差不多n，但是还是比n大一点</p>
<p>线性筛法：复杂度就是n</p>
<blockquote>
<p><img src="/2022/12/14/algorithm/image-20230318143606944.png" alt="image-20230318143606944"></p>
</blockquote>
<p>埃式筛法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;<span class="comment">//若为合数</span></span><br><span class="line">        primes[cnt++]=i;<span class="comment">//若为质数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j+=i)<span class="comment">//筛掉质数的倍数，如i=2,筛掉4,6等等</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性筛法：</p>
<p>线性筛法的原理：n只会被最小质因子筛掉</p>
<ul>
<li>本来我们应该对每个质数像埃氏筛法一样去筛，去把他的所有倍数找出来，但我们也可以不这样，可以并行地做，让相同的i乘以primes[j]来筛，但是是否需要让i乘以每个primes[j]来筛呢，如果i%primes[j]成立，说明primesj是i的最小质因子，我们希望每个数都被其最小质因子筛，所以i*primes[j+1]筛掉这个任务应该交给k*primes[j]来完成，同理接下来的i*primes[j+x]…，所以就不需要再循环下去了，break</li>
<li>那一上来把primes[j]<em>i筛了合适吗，这个是能保证最小筛吗，如果j大于0，也就是不是第一次循环，假设现在是c+1次循环，那么在第c次判断的时候通过判断可知i%primes[c]!=0,故可知i的最小质因数大于primes[c]，数i\</em>primes[c+1]的最小质因数要么是i要么是primes[c+1]，如果是第一次循环，那么primes[j]为2，其为最小的质数，用其筛掉的数一定能保证原则<code>用最小质因数筛</code></li>
<li><strong>我们筛的时候总是用最小质因数来筛，并且筛的是i*primes[j]，这个数筛的时候是归为用primes[j]作为最小质因数来筛的</strong>，因为如果归为i，i如果是合数的话，那么应该由i的最小质因数来筛，如果是质数的话，那么i刚刚加入primes数组中，按照顺序(i这个质数)<em>(primes这个质数)，显然primes这个质数更小，所以也是归为primes这个质数来筛的，所以i\</em>primes[j]来筛总是归为primes[j]作为最小质因数来筛</li>
<li>所以当不满足这个条件的时候，也就是i*primes[j]不能归为primes[j]时，那么一定是i为合数，即由i的最小质因子来筛，因为如果是质数的话按照上一条，仍然归结为primes[j]，也就是说i的最小质因子小于等于primes[j]吧，所以我们为了满足黑体加粗的规则，在等于的时候就跳出循环</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;            <span class="comment">// 存质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )          <span class="comment">// 结束的条件是：primes[j] * i &lt;= n, 最多筛到n</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;                   <span class="comment">// 把合数 primes[j] * i 筛了</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//遍历的过程中把归结为以i的最小质因子的可能去掉               </span></span><br><span class="line">            <span class="comment">// 若 i 为 primes[j] 的合数, 在筛prime[j] * i之前就已经把i筛掉了</span></span><br><span class="line">            <span class="comment">// i都被筛了，比i大的 primes[j]的倍数也在之前被筛了</span></span><br><span class="line">            <span class="comment">// 因为 i = primes[j] * k, primes[j] &lt; i, k &lt; i.</span></span><br><span class="line">            <span class="comment">// 而 i &lt; n, 若 i - n之间还存在prims[j]* (k + 1) == x &lt; n 的话</span></span><br><span class="line">            <span class="comment">// i &lt; x &lt; n，循环结束时可以筛到n，故primes[j]的k + 1倍 x会被筛掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><p>（1）试除法求一个数的所有约数 只需要枚举较小的约束，较大的那个可以直接计算出来</p>
<p>（2）约束个数 int范围内约数最多的是1500左右</p>
<p>（3）约束之和</p>
<p><img src="/2022/12/14/algorithm/image-20230318151937617.png" alt="image-20230318151937617"></p>
<p>约束之和展开即可呀，每个括号里选一个就行了~</p>
<p>（4）最大公约数 欧几里得算法（辗转相除法）</p>
<h3 id="约束个数"><a href="#约束个数" class="headerlink" title="约束个数"></a>约束个数</h3><p>先把每个数分解为质因子表达式，然后用上面的公式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>,mode=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;primes;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)<span class="comment">//把每个数分解成质因子表达式</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res=<span class="number">1</span>;<span class="comment">//注意是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:primes) res=res*(p.second+<span class="number">1</span>)%mode;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约束之和"><a href="#约束之和" class="headerlink" title="约束之和"></a>约束之和</h3><p>主要是$1+P+P^2…$的处理采用<code>t=t*p+1</code>的方式完成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a = p.first, b = p.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b -- ) t = (t * a + <span class="number">1</span>) % mod;</span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x/i;i++)<span class="comment">//枚举较小者即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i!=x/i) res.<span class="built_in">push_back</span>(x/i);<span class="comment">//避免两个相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">auto</span> res=<span class="built_in">get_divisors</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:res) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p><img src="/2022/12/14/algorithm/image-20230803100601905.png" alt="image-20230803100601905"></p>
<p>欧几里得算法，时间复杂度$log(n)$</p>
<p>注意: d|a的含义是a能被d整除，即a/d</p>
<p>基于如下原理：d|a,d|b,则有d|ax+by，所以a和b的最大公约数(a,b)也可以表示为(b,a-c*b)，可知假设(a,b)值为k，k一定都整除b和a-c*b，特殊的，这里的c取[a/b]，故有(a,b)=(b,a%b)，如果b为0，则由于0可以被任何数整除，0/k=0,所以最大公约数返回a（也就是说任何的数都是0的约数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;<span class="comment">//若b为0，则返回a(0可以整除任何数),否则返回(b,a%b)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">gcd</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="欧拉函数-1"><a href="#欧拉函数-1" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>互质：公约数只有1的两个整数</p>
<p>欧拉函数就是求出1~N中与N互质的数的个数，比如6与1,5互质，故欧拉函数值为2</p>
<p><img src="/2022/12/14/algorithm/image-20230803102654370.png" alt="image-20230803102654370"></p>
<p>欧拉公式原理：上面的公式展开就是下面的容斥原理，比如1/p1这个项前面是负号，两个的话是正号。。。。</p>
<p><img src="/2022/12/14/algorithm/image-20230318164700758.png" alt="image-20230318164700758" style="zoom:50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里没存质因数，因为没必要</span></span><br><span class="line">    <span class="type">int</span> res=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);<span class="comment">//先除后乘，避免计算过程中溢出</span></span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;<span class="comment">//除尽</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res/x*(x<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">phi</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>如果要求1~N中每一个数的欧拉函数，如果用公式来算，分解质因数n次将复杂度变成$O(n*sqrt(n))$，而筛法求每个数的欧拉函数的时间复杂度为$O(n)$</p>
<p>在线性筛法的过程中顺便把欧拉函数求出来，注意欧拉函数的定义，1~N中与N互质的数的个数</p>
<ol>
<li><p>若i是质数，那么i与前i-1个数均互质，这是质数的定义（质数只有他自己和1两个因子），故其phi值为i-1</p>
</li>
<li><p>primes[j]*i的phi值</p>
<ol>
<li><p>如果i%primes[j]==0，按照线性筛法，此时primes[j]恰好是i的最小质因数，所以按照公式可知：phi[i%primes[j]]=primes[j]*phi[i]</p>
<p><img src="/2022/12/14/algorithm/image-20230803110959261.png" alt="image-20230803110959261" style="zoom:50%;"></p>
</li>
<li><p>如果i%primes[j]!=0，按照线性筛法，此时i的最小质因子大于primes，故需要分别计算i和primes[j]的质因子</p>
</li>
</ol>
<p><img src="/2022/12/14/algorithm/image-20230803111634276.png" alt="image-20230803111634276" style="zoom:50%;"></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">int</span> euler[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_euler</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])<span class="comment">//是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            euler[i]=i<span class="number">-1</span>;<span class="comment">//质数和其前面的数互质</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)<span class="comment">//对于该数与质数的乘数，向后筛</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=primes[j]*i;</span><br><span class="line">            st[t]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="comment">//eulaer中已经包含了1/primes[j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t]=euler[i]*primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//未包含</span></span><br><span class="line">            euler[t]=euler[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">get_euler</span>(n);</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=euler[i];</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉函数的一个运用，因为a和n互质，假设1~n中与n互质的数为a1,a2,…a_phi(n),将这些数乘以a后也将与n互质（只有1这一个公因子），而在模n的情况下这两种应该是等价的(模n之后)，所以乘起来，可得上面的公式,如5^2^=25%6=1，其中phi(6)=2</p>
<p><img src="/2022/12/14/algorithm/image-20230803113942758.png" alt="image-20230803113942758" style="zoom: 50%;"></p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>原理：</p>
<p><img src="/2022/12/14/algorithm/image-20230803115223198.png" alt="image-20230803115223198" style="zoom: 50%;"></p>
<p><img src="/2022/12/14/algorithm/image-20230318191702495.png" alt="image-20230318191702495"></p>
<p>例子：</p>
<p><img src="/2022/12/14/algorithm/image-20230803115210828.png" alt="image-20230803115210828" style="zoom:50%;"></p>
<h3 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h3><p>若求A的B次方的后几位数，则这里的后几位数就是q</p>
<p>LL res = 1 % p;<br>注意这个式子！！！，当a=5,b=0,p=1这种情况下是会出错的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res=<span class="number">1</span>%q;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把b转换为二进制</span></span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%q;</span><br><span class="line">        a=a*(LL)a%q;<span class="comment">//a变成其平方</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qmi</span>(a,b,q));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><p>在欧几里得算法那节我们知道了费马定理：<strong>注意条件是a和p互质且p是质数</strong>，如果a是p的倍数，快速幂是无法求的</p>
<p><img src="/2022/12/14/algorithm/image-20230803113942758.png" alt="image-20230803113942758" style="zoom: 50%;"></p>
<p><img src="/2022/12/14/algorithm/image-20230319114751648.png" alt="image-20230319114751648"></p>
<p>b的逆元就是上面的x，最终通过费马定理转换为求<code>b^(n-2)%n</code>，转变为快速幂</p>
<p>注意这里a和n要求互质，否则结果是<code>impossible</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*(LL)a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(a%p==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qmi</span>(a,p<span class="number">-2</span>,p));<span class="comment">//a^(p-2)%p;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>欧几里得算法：</p>
<p>基于如下原理：d|a,d|b,则有d|ax+by，所以a和b的最大公约数(a,b)也可以表示为(b,a-c*b)，可知假设(a,b)值为k，k一定都整除b和a-c*b，特殊的，这里的c取[a/b]，故有(a,b)=(b,a%b)，如果b为0，则由于0可以被任何数整除，0/k=0,所以最大公约数返回a（也就是说任何的数都是0的约数）</p>
<p>裴蜀定理：对于任意正整数a,b，一定存在非零整数x，y，使得ax+by=(a,b)的最大公约数</p>
<p>最大公约数就是最大公因数，扩展欧几里得就是构造x和y，利用的是递归的思想</p>
<p>当b为0时，可以轻易写出来，当b不为0时，找到前后两层的递归关系</p>
<h3 id="扩展欧几里得算法-1"><a href="#扩展欧几里得算法-1" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><img src="/2022/12/14/algorithm/image-20230804104602951.png" alt="image-20230804104602951"></p>
<p>x、y并不唯一，算法求出其一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)<span class="comment">//如果b为0，则最大公约数就是a</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是递归两层间的关系</span></span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);<span class="comment">//已经求得by+(a%b)x=d的解y,x，现在根据已经求得的解求ax+by=d的解x和y</span></span><br><span class="line">    <span class="comment">//扩展欧几里得</span></span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p><img src="/2022/12/14/algorithm/image-20230804111200034.png" alt="image-20230804111200034" style="zoom: 50%;"></p>
<p>根据欧几里得算法，对于ax+my=d，其中d是a和m的最大公约数，一定在一些条件下有解，但是题目给出的是b，所以不一定有解，有解的条件是b能够被d整除，并且可知实际的x值会因此而扩大b/d倍</p>
<p><img src="/2022/12/14/algorithm/image-20230319190625005.png" alt="image-20230319190625005"></p>
<p>线性同余方程求的是这个x，思路是用扩展欧几里得首先求a和m的最大公约数d，然后把求得的x扩展b/d倍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a,b,m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;m);</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">exgcd</span>(a,m,x,y);</span><br><span class="line">        <span class="keyword">if</span>(b%d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//要求能整除最大公约数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(LL)b/d*x%m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设某个特解为ax0+by0=n；<br>那这个也等同于 a（x0+bt）+b（y0-at）=n;<br>x的通解为 x=x0+b*t;<br>最后取模可以求最小的解</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="表达整数的奇怪方式"><a href="#表达整数的奇怪方式" class="headerlink" title="表达整数的奇怪方式"></a>表达整数的奇怪方式</h3><p><img src="/2022/12/14/algorithm/image-20230804123142955.png" alt="image-20230804123142955" style="zoom:67%;"></p>
<p>按照上图的步骤来求：</p>
<ul>
<li>首先化为k1a1-k2a2=m2-m1形式，这个形式做两件事情，第一件事情是判断是否有解，有解等价于(m2-m1)是(a1,a2)的倍数，第二件事情是根据扩展欧几里得算法求出k1</li>
<li>但是为了题目的x的最小条件，我们需要根据扩展欧几里得的通解形式缩小k1，这也是一步</li>
<li>在求出k1之后我们就可以求x了，x=a1k1+m1+</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    LL x=<span class="number">0</span>,m1,a1;</span><br><span class="line">    cin&gt;&gt;a1&gt;&gt;m1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        LL m2,a2;</span><br><span class="line">        cin&gt;&gt;a2&gt;&gt;m2;</span><br><span class="line">        LL k1,k2;</span><br><span class="line">        LL d=<span class="built_in">exgcd</span>(a1,a2,k1,k2);</span><br><span class="line">        <span class="keyword">if</span>((m2-m1)%d)&#123;</span><br><span class="line">            x=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">        k1*=(m2-m1)/d;<span class="comment">//因为等式右边是m2-m1而不是最大公约数，所以需要扩展</span></span><br><span class="line">        LL t=a2/d;<span class="comment">//上图下面的通解形式</span></span><br><span class="line">        <span class="comment">//将解变成一个最小的正整数解</span></span><br><span class="line">        k1=(k1%t+t)%t;</span><br><span class="line"></span><br><span class="line">        x=k1*a1+m1;<span class="comment">//求得x</span></span><br><span class="line">        <span class="comment">//下面就是把两个式子统一为一个式子继续合并</span></span><br><span class="line">        <span class="comment">//更新a和m，k只是个变量，不用管，取余的时候会自动消失</span></span><br><span class="line">        m1=k1*a1+m1;</span><br><span class="line">        a1=<span class="built_in">abs</span>(a1/d*a2);<span class="comment">//最小公倍数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">-1</span>) x=(m1%a1+a1)%a1;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>高斯消元解线性方程组</p>
<p>线性方程组有三种情况的解，先将矩阵化为上三角</p>
<ol>
<li>如果出现左侧和右侧都是0的行，说明方程组中该方程可以被其他方程表出，故方程组有无穷解</li>
<li>如果出现左侧全为0右侧不为0的行，则方程组无解</li>
<li>否则就是有唯一解，通过初等行变换，高斯消元的方法求解</li>
</ol>
<p><img src="/2022/12/14/algorithm/image-20230805110013261.png" alt="image-20230805110013261" style="zoom:67%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span>  <span class="comment">// 高斯消元，答案存于a[i][n]中，0 &lt;= i &lt; n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )<span class="comment">//依次处理吧各列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )  <span class="comment">// 找绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;<span class="comment">//如果最大的行都是0，说明全是0，该列无法用于行的固定</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);  <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];  <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )  <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)<span class="comment">//如果固定的行数小于n，则说明有一些行左侧全是0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )<span class="comment">//检查这些行右边是不是0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//求唯一解，需要再化为最简式，即系数矩阵化为单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];<span class="comment">//第i行需要减的数与第i行的非首位和该首位对应的列的首位有关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><p>求组合数有多种方式，需要根据题目数据范围来选择合适的做法</p>
<p><img src="/2022/12/14/algorithm/image-20230320120740137.png" alt="image-20230320120740137"></p>
<p>求组合数有多种方式，要根据数据的范围选择</p>
<h3 id="求组合数1"><a href="#求组合数1" class="headerlink" title="求组合数1"></a>求组合数1</h3><p>考虑打表的方式直接弄出来，直接预处理出来每一个数，复杂度O(n^2^)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"><span class="comment">//单独把c_ij处理出来</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j]=<span class="number">1</span>;<span class="comment">//边界条件，当j为0时</span></span><br><span class="line">            <span class="keyword">else</span> c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求组合数2"><a href="#求组合数2" class="headerlink" title="求组合数2"></a>求组合数2</h3><p>预处理出来阶乘，用公式计算组合数，但是不存在除法分开取模的特征，所以要计算逆元来做，所以预处理出来一个数的阶乘和他的逆元</p>
<p><img src="/2022/12/14/algorithm/image-20230805113411772.png" alt="image-20230805113411772" style="zoom:50%;"></p>
<p>处理出来数的阶乘，和数的逆元的相乘结果</p>
<p>两个long long级别的数相乘就要mod一次了~，复杂度O(NlogN)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fact[N],infact[N];<span class="comment">//阶乘和逆元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=(LL)res*a%p;</span><br><span class="line">        a=(LL)a*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//预处理出阶乘和逆元</span></span><br><span class="line">    fact[<span class="number">0</span>]=infact[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//1的阶乘和逆元都是本身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i]=(LL)fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        infact[i]=(LL)infact[i<span class="number">-1</span>]*<span class="built_in">qmi</span>(i,mod<span class="number">-2</span>,mod)%mod;<span class="comment">//前面那个乘上i的逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="求组合数3"><a href="#求组合数3" class="headerlink" title="求组合数3"></a>求组合数3</h3><p>采用lucus定理来做：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/8148298/">AcWing 887. 求组合数 III - AcWing</a></p>
<p>关键的一步是来凑出b0+b1*p1+…凑出来b</p>
<p><img src="/2022/12/14/algorithm/image-20230806095717752.png" alt="image-20230806095717752"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=(LL) res*a%p;</span><br><span class="line">        a=(LL)a*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span><span class="comment">//直接求组合数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=a;i&lt;=b;i++,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res=(LL)res*j%p;<span class="comment">//a~a-b+1</span></span><br><span class="line">        res=(LL)res*<span class="built_in">qmi</span>(i,p<span class="number">-2</span>,p)%p;<span class="comment">//b的阶乘的逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a,LL b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;p&amp;&amp;b&lt;p) <span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);<span class="comment">//均不满足则直接求</span></span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a%p,b%p,p)*<span class="built_in">lucas</span>(a/p,b/p,p)%p;<span class="comment">//lucas定理是个递归的过程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    LL a,b;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lucas</span>(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求组合数4"><a href="#求组合数4" class="headerlink" title="求组合数4"></a>求组合数4</h3><p>要求求准确的解，而不是模一个数，可以直接用公式来计算，涉及到高精度乘法和高精度除法，效率较低</p>
<p>方法是先将<code>C(a,b)</code>分解质因数<code>a!/((a-b)!*(b!))</code>，然后只用高精度乘法来做即可<a href="https://www.acwing.com/solution/content/26559/">AcWing 888. 求组合数 IV(高精度-素数组合) - AcWing</a></p>
<ul>
<li>首先筛1~a之间的所有质数</li>
<li>再求每个质数的次数</li>
<li>用高精度乘法将上述质数乘上</li>
</ul>
<p>这里计算每个质数的次数的方法如下：</p>
<p><img src="/2022/12/14/algorithm/image-20230806110437230.png" alt="image-20230806110437230" style="zoom:50%;"></p>
<p>以2为例：</p>
<p><img src="/2022/12/14/algorithm/image-20230806111033816.png" alt="image-20230806111033816" style="zoom:50%;"></p>
<p>其实代码里面更好理解，就是不断地除p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span><span class="comment">//计算n的阶乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=n/p;</span><br><span class="line">        n/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t+=a[i]*b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(a);<span class="comment">//求1~a之间的质数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=primes[i];<span class="comment">//第i个质数</span></span><br><span class="line">        sum[i]=<span class="built_in">get</span>(a,p)-<span class="built_in">get</span>(a-b,p)-<span class="built_in">get</span>(b,p);<span class="comment">//求这个质数的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;sum[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">mul</span>(res,primes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="满足条件的01序列"><a href="#满足条件的01序列" class="headerlink" title="满足条件的01序列"></a>满足条件的01序列</h3><p>参考：<a href="https://www.acwing.com/solution/content/8907/">AcWing 889. 满足条件的01序列 - AcWing</a>，即求卡特兰数</p>
<p>注意快速幂求逆元的条件，要求mod为质数</p>
<p>问题转换为从0，0走到n，n的满足一定条件的路径，将序列中0看成向右走，1看成向上走，最终走到(n,n)位置，但是题目要求序列前缀中0的个数要不少于1的个数，所以x&gt;=y，也就是说不能碰到红色的线，那如何求碰到红色线的路径数量呢，任何一个碰到红线然后到达(n,n)的路径通过红线进行镜像处理，最终一定会镜像到达(n-1,n+1)这个点的一条路径，所以只需要求出从(0,0)到达(n-1,n+1)这个点的路径数量，然后相减即可</p>
<p><img src="/2022/12/14/algorithm/image-20230325205418891.png" alt="image-20230325205418891"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=(LL)res*a%p;</span><br><span class="line">        a=(LL)a*a%p;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a=n*<span class="number">2</span>,b=n;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&gt;a-b;i--) res=(LL)res*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=b;i++) res=(LL)res*<span class="built_in">qmi</span>(i,mod<span class="number">-2</span>,mod)%mod;<span class="comment">//逆元</span></span><br><span class="line">    res=(LL)res*<span class="built_in">qmi</span>(n+<span class="number">1</span>,mod<span class="number">-2</span>,mod)%mod;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img src="/2022/12/14/algorithm/image-20230807094630758.png" alt="image-20230807094630758"></p>
<p>实现的时候以位运算的方式实现，假设有n个数m个类别，则从1~2^m^-1进行枚举，每一位上表示该位上的集合是否取，在枚举的过程中计算上述等式</p>
<h3 id="能被整除的数"><a href="#能被整除的数" class="headerlink" title="能被整除的数"></a>能被整除的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//m个质数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) cin&gt;&gt;p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)<span class="comment">//1~2^m,看做是2进制串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="comment">//计算其中1的个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((LL)t*p[j]&gt;n)<span class="comment">//选择的质数不符合要求</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t=<span class="number">-1</span>;<span class="comment">//做个标记然后退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t*=p[j];</span><br><span class="line">                s++;<span class="comment">//集合中元素的数量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s%<span class="number">2</span>) res+=n/t;<span class="comment">//奇数个数为加</span></span><br><span class="line">            <span class="keyword">else</span> res-=n/t;<span class="comment">//偶数个数为减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><p>若一个游戏满足：</p>
<p>由两名玩家交替行动<br>在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关<br>不能行动的玩家判负<br>则称该游戏为一个<strong>公平组合游戏</strong>。</p>
<p>尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。</p>
<h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>ai是每堆中数量</p>
<p>先手必胜状态：先手操作完，可以走到某一个必败状态（给对方留下必败状态）<br>先手必败状态：先手操作完，走不到任何一个必败状态（队首不处于必败态，自己处于）<br>先手必败状态：a1 ^ a2 ^ a3 ^ … ^an = 0<br>先手必胜状态：a1 ^ a2 ^ a3 ^ … ^an ≠ 0</p>
<p>证明：</p>
<ol>
<li>对于先手，如果遇到全0的局面，则败</li>
<li>如果先手遇到异或不为0的情况，假设异或结果为x，假设x的最高位1所在位为k，则至少存在ai第k位为1，ai异或x&lt;ai,所以在取的过程中可以将ai取为(ai异或x)的状态，因为x是a1~an的异或，将ai取完之后一定能将异或结果转为0，后手必败，先手必胜</li>
<li>如果先手遇到异或为0的情况，则无论怎么取，异或结果都不是0.也就是对手必胜态，反证法：假设取完后异或结果为0，取的项ai变成了ai’,则将前后两次项进行异或：a1\^a2…\^ai\^an  ^  a1\^a2\^…\^ai‘\^an=ai\^ai’，如果是0，则ai=ai’,则不满足取这一动作，故不可能为0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,tmp,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        x^=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="台阶-Nim游戏"><a href="#台阶-Nim游戏" class="headerlink" title="台阶-Nim游戏"></a>台阶-Nim游戏</h3><p>如果先手时奇数台阶上的值的异或值为0，则先手必败，反之必胜</p>
<p>注意判断奇数的处理:<code>i&amp;1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) res^=x;<span class="comment">//奇数台阶上的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合-Nim游戏"><a href="#集合-Nim游戏" class="headerlink" title="集合-Nim游戏"></a>集合-Nim游戏</h3><p><a href="https://www.acwing.com/solution/content/13191/">AcWing 893. 集合-Nim游戏 - AcWing</a></p>
<p>用到了sg数组，sg数组通过mex函数定义，sg=mex{sg(后继)}，即在后继中未出现的最小的非负整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>,M=<span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[N],f[M];<span class="comment">//分别存储可拿的石子数量和每堆石子数量</span></span><br><span class="line"><span class="comment">//记忆化搜索，注意到相同的x得到的值应该是一样的，sg的树结构画起来是一样的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//根据sg的定义求sg值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x];<span class="comment">//记忆化搜索</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//对每种取法进行讨论</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=s[i];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=sum) S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x-sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;;i++)<span class="comment">//按照sg的定义向后寻找未出现的非0整数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(i))</span><br><span class="line">        <span class="keyword">return</span> f[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//将每个有向图顶点sg值异或</span></span><br><span class="line">        res^=<span class="built_in">sg</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拆分-Nim游戏"><a href="#拆分-Nim游戏" class="headerlink" title="拆分-Nim游戏"></a>拆分-Nim游戏</h3><p>sg(b1,b2)=sg(b1)$\and$sg(b2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)<span class="comment">//两堆的所有结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            set.<span class="built_in">insert</span>(<span class="built_in">sg</span>(i)^<span class="built_in">sg</span>(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;;i++)<span class="comment">//按照sg的定义，去mex，未出现的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.<span class="built_in">count</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> f[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        res^=<span class="built_in">sg</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>DP需要注意初始化——from xiao</p>
</blockquote>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>0-1背包问题：每件物品最多使用一次</p>
<p>完全背包问题：每件物品有无限个</p>
<p>多重背包问题：每件物品有s[i]个，有一种优化计算方式</p>
<p>分组背包问题：有多个组，每组里只能选一个</p>
<p><img src="/2022/12/14/algorithm/image-20230807212651662.png" alt="image-20230807212651662"></p>
<p>优化和变形都是在原方程基础上进行的等价变形，降维的时候如果用到的是上一层的状态，就要逆序枚举，如果用到的是本层的状态，就要顺序枚举</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p><img src="/2022/12/14/algorithm/image-20230807215110433.png" alt="image-20230807215110433" style="zoom:80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> V[N],W[N];</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;V[i]&gt;&gt;W[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=V[i]) dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-V[i]]+W[i]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    V = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    W = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        V[i],W[i] = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j&gt;=V[i]:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-V[i]]+W[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="built_in">print</span>(dp[n][m])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>降维后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> V[N],W[N];</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;V[i]&gt;&gt;W[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=V[i];j--)<span class="comment">//注意逆序，因为dp[j-v]项需要用到之前的项，如果正序计算，会被提前覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    V = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    W = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        V[i],W[i] = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j&gt;=V[i]:</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i])</span><br><span class="line">    <span class="built_in">print</span>(dp[m])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>每个物品无数个</p>
<p><img src="/2022/12/14/algorithm/image-20230807214845030.png" alt="image-20230807214845030" style="zoom:50%;"></p>
<p>朴素做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*w[i]&lt;=j;k++)<span class="comment">//类似于dp数组的方法来计算</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-k*w[i]]+k*v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][c];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化做法：替换公式</p>
<p><img src="/2022/12/14/algorithm/image-20230807233458009.png" alt="image-20230807233458009" style="zoom:80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][c];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终极优化：替换公式+降维 ，注意是顺序的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&lt;=m;j++)<span class="comment">//注意这里是顺序的，因为用的j-v是i作为前项的，是更新覆盖之后的</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    V = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    W = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp = [<span class="number">0</span>]*(m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        V[i],W[i] = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j&gt;=V[i]:</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i])</span><br><span class="line">    <span class="built_in">print</span>(dp[m])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>每个物品有限个，具体有s[i]个</p>
<p><img src="/2022/12/14/algorithm/image-20230808092846993.png" alt="image-20230808092846993"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="type">int</span> V[N],S[N],W[N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;V[i]&gt;&gt;W[i]&gt;&gt;S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=S[i]&amp;&amp;j&gt;=k*V[i];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-k*V[i]]+k*W[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制优化</p>
<p>优化的思想：将第i组可拿的s[i]个物品进行拆分，按照二进制进行打包成一个物品，只需要对拆分后的$log(s)$个物品进行选或者不选，就能等效于对s[i]个物品选的数量，具体将s[i]个物品拆分成: 1 , 2 , 4 , 2^k^ , c ,其中1+2+4+…+2^k^&lt;=s[i]，但k+1次方不满足该条件，c是s[i]-(1+2+4+…+2^k^)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20000</span>,M=<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> V[N],W[N];</span><br><span class="line"><span class="type">int</span> n,v;</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="type">int</span> a,b,s;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            V[cnt]=a*k;</span><br><span class="line">            W[cnt]=b*k;</span><br><span class="line">            s=s-k;</span><br><span class="line">            k=k*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            V[cnt]=s*a;</span><br><span class="line">            W[cnt]=s*b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=V[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">         f[j]=<span class="built_in">max</span>(f[j],f[j-V[i]]+W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>分成多个组，每组之中只能选0个或者1个</p>
<p><img src="/2022/12/14/algorithm/image-20230808101054769.png" alt="image-20230808101054769" style="zoom: 67%;"></p>
<p>二维dp：</p>
<p>降维优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>线性指递推有个模糊的顺序，如背包问题的二维表从左到右</p>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="/2022/12/14/algorithm/image-20230808110244360.png" alt="image-20230808110244360" style="zoom: 50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )<span class="comment">//因为递推式需要用到[i-1,j-1]和[i-1,j]项,故需要初始化为负无穷,避免选择该路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长上升子序列一"><a href="#最长上升子序列一" class="headerlink" title="最长上升子序列一"></a>最长上升子序列一</h3><p><img src="/2022/12/14/algorithm/image-20230808165203445.png" alt="image-20230808165203445" style="zoom:50%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长上升子序列贰"><a href="#最长上升子序列贰" class="headerlink" title="最长上升子序列贰"></a>最长上升子序列贰</h3><p>采用类似单调队列的样子，s[i]存储长度为i的最长上升子序列的最小的末尾元素，可证明s存储的结果一定是严格单调递增的，证明：</p>
<p>假设s[i]=s[i+1],则可知对于长度为i+1的子序列，其最小的末尾元素是s[i+1]，那这个序列的第i个元素一定小于s[i+1]，与s[i]=s[i+1]不符，故可证；若s[i]&gt;s[i+1]，同理可证</p>
<p>所以s数组一定是单调递增的，当插入一个新的数h时，先找到最大的比h小的数s[k]，可知由于s[k]是长度为k的子序列中末尾元素最小的，所以h与该序列拼接可以得到一个长度为k+1的子序列，所以我们需要将其与s[k+1]的大小进行比较，判断是否能替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=cnt;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)<span class="comment">//等价于找到第一个比x大的进行替换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&gt;=x) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    f[++cnt]=a[<span class="number">1</span>];<span class="comment">//从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;f[cnt]) f[++cnt]=a[i]; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> idx=<span class="built_in">find</span>(a[i]);<span class="comment">//找到f中第一个大于等于a[i]的用a[i]替换</span></span><br><span class="line">            f[idx]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>书上的解释是：</p>
<p><img src="/2022/12/14/algorithm/image-20230808170842735.png" alt="image-20230808170842735"></p>
<p><img src="/2022/12/14/algorithm/image-20230808170813016.png" alt="image-20230808170813016"></p>
<p><img src="/2022/12/14/algorithm/image-20230808171041152.png" alt="image-20230808171041152"></p>
<p>注意这里的f[i-1,j]是包含01和00的，而不是准确表示出第j个一定选，也就是说f[i-1,j]项与f[i-1,j-1]重叠，但由于求的是max，所以不要求不重复，由于f[i-1,j]和f[i,j-1]包含了f[i-1,j-1]，所以无需再比较f[i-1,j-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">char</span> b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><img src="/2022/12/14/algorithm/image-20230809092357983.png" alt="image-20230809092357983"></p>
<p><img src="/2022/12/14/algorithm/image-20230809092419161.png" alt="image-20230809092419161" style="zoom:67%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p>区间 DP 常用模版</p>
<p>所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1），从小区间到大区间，以使得大区间能使用小区间的解</p>
<p>模板代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上循环模式是因为要保证计算dp[i][j]时其依赖的较小的区间的dp值已经计算得到了</p>
<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p><img src="/2022/12/14/algorithm/image-20230808173441832.png" alt="image-20230808173441832" style="zoom: 67%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=i+len<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r]=<span class="built_in">min</span>(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h3><p><strong>方法一</strong></p>
<p>转换为完全背包问题，f[i][j]表示用前i个数凑出j的方案数，易知根据最后一个数的多少进行划分计算最后求和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k*i&lt;=j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j-k*i])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用一下变形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i][j] = f[i - 1][j] + f[i][j - i]</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] % mod; <span class="comment">// 特殊 f[0][0] = 1</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) f[i][j] = (f[i - <span class="number">1</span>][j] + f[i][j - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>降维——最终写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=(dp[j]+dp[j-i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p><img src="/2022/12/14/algorithm/image-20230809103010960.png" alt="image-20230809103010960" style="zoom:50%;"></p>
<p>状态表示：<br>f[i][j]表示总和为i，总个数为j的方案数</p>
<p>状态转移方程：<br>f[i][j] = f[i - 1][j - 1] + f[i - j][j];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><p>分情况讨论</p>
<p>问题转换为求1~n这些数中数字i出现的次数，假设n一共有7位，如abcdefg，现在我们考虑第4位（d）上数字i出现的次数，我们构造的数为xxxiyyy</p>
<ol>
<li>若d不为0，xxx取000~abc-1，yyy对于每种xxx的取法都可以取000~999,故为abc*1000</li>
<li>若d为0，则xxx不能取000，因为000 0 123写做123，实际上不会写出这个0，所以这里xxx只能取001~abc-1，yyy取000~999,故为(abc-1)*1000</li>
<li>若XXX取abc，此时若d&gt;i，则yyy可取000~999,故为1000</li>
<li>若XXX取abc，此时若d=i，则yyy可取000~efg，故为efg+1，若d&lt;i不能取</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dgt</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 计算整数n有多少位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) ++ res, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> <span class="comment">// 计算从1到n的整数中数字i出现多少次 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, d = <span class="built_in">dgt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= d; ++ j) <span class="comment">// 从右到左第j位上 数字i出现多少次 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// l和r是第j位左边和右边的整数 (视频中的abc和efg); dj是第j位的数字</span></span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">pow</span>(<span class="number">10</span>, j - <span class="number">1</span>), l = n / p / <span class="number">10</span>, r = n % p, dj = n / p % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 计算第j位左边的整数小于l (视频中l = 000 ~ abc - 1)的情况 左边不等于abc的时候 说明都是比abc小的数字  </span></span><br><span class="line">        <span class="keyword">if</span> (i) res += l * p; <span class="comment">//如果不是统计数字0 左边直接乘p就行了 n=ab3xxx p=1000  </span></span><br><span class="line"><span class="comment">//n=1236055 6000-6999这里1000  第j位上的6出现了p次 但是左边还有16000-16999 26000-26999 36000-36999...1226000-1226999 共左边数字l（即123）个 所以是l*p </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!i &amp;&amp; l) res += (l - <span class="number">1</span>) * p; <span class="comment">// 统计的数字i = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1) </span></span><br><span class="line"><span class="comment">//少了0000-0999的一种情况 从10000-10999 开始 ... 1220000-1220999 13000-13999 共(l-1)次 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算第j位左边的整数等于l (视频中l = abc)的情况 只会和*j位后面的数*有关</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面就是l的左边相等的情况 对第j位上 不会多算6000-6999 ...1226000-1226999里面的任意个集合 123开始的情况</span></span><br><span class="line">        <span class="keyword">if</span> ( (dj &gt; i) &amp;&amp; (i || l) ) res += p;<span class="comment">//第j位比现在统计的数字大 就可以直接加上p中情况 </span></span><br><span class="line"><span class="comment">// n=1236055  则有1235000-1235999 999+1种情况 即p种 </span></span><br><span class="line"><span class="comment">//当统计的数字i==0 且 l==0， 举例  n=123456 l==0 第j位为1  就是p=100000 此时000000-099999是不成立的 因为我要统计第j位为i的时候 有多少个这样的 数 而此时   000000-099999 显然和 100000-199999 第j-1位为2的时候重复了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( (dj == i) &amp;&amp; (i || l) ) res += r + <span class="number">1</span>;<span class="comment">//这是r有多少个 就是多少个+1</span></span><br><span class="line"><span class="comment">//if(dj==i) n=1236055  1236000-1236055   即55+1种情况</span></span><br><span class="line"><span class="comment">//当统计的数字i==0 且 l==0， 举例  n=123456 l==0且i==0 就是000000 -0123456 而这个时候显然和 第j-1的位的时候重复了100000-109999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if(dj&gt;i) n=1236000 则有1237000-1237999 所以是0 </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b , a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i) cout &lt;&lt; <span class="built_in">cnt</span>(b, i) - <span class="built_in">cnt</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><p><img src="/2022/12/14/algorithm/image-20230811153912998.png" alt="image-20230811153912998" style="zoom: 67%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span>&lt;&lt; N;  </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M] ;<span class="comment">// 第一维表示列， 第二维表示所有可能的状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[M];  <span class="comment">//存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;int &gt; state[M];  //二维数组记录合法的状态</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">state</span>(M);  <span class="comment">//两种写法等价:二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123; <span class="comment">//读入n和m，并且不是两个0即合法输入就继续读入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一部分：预处理1</span></span><br><span class="line">        <span class="comment">//对于每种状态，先预处理每列不能有奇数个连续的0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span> ;<span class="comment">//记录连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> isValid = <span class="literal">true</span>; <span class="comment">// 某种状态没有奇数个连续的0则标记为true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123; <span class="comment">//遍历这一列，从上到下</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ( (i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;  </span><br><span class="line">                     <span class="comment">//i &gt;&gt; j位运算，表示i（i在此处是一种状态）的二进制数的第j位； </span></span><br><span class="line">                     <span class="comment">// &amp;1为判断该位是否为1，如果为1进入if</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123; </span><br><span class="line">                    <span class="comment">//这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法</span></span><br><span class="line">                        isValid =<span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; </span><br><span class="line"></span><br><span class="line">                    cnt = <span class="number">0</span>; <span class="comment">// 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。</span></span><br><span class="line">                    <span class="comment">//其实清不清零没有影响</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> cnt ++; <span class="comment">//否则的话该位还是0，则统计连续0的计数器++。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)  isValid = <span class="literal">false</span>; <span class="comment">//最下面的那一段判断一下连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            st[i]  = isValid; <span class="comment">//状态i是否有奇数个连续的0的情况,输入到数组st中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二部分：预处理2</span></span><br><span class="line">        <span class="comment">// 经过上面每种状态 连续0的判断，已经筛掉一些状态。</span></span><br><span class="line">        <span class="comment">//下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j ++) &#123; <span class="comment">//对于第i列的所有状态</span></span><br><span class="line">            state[j].<span class="built_in">clear</span>(); <span class="comment">//清空上次操作遗留的状态，防止影响本次状态。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k ++) &#123; <span class="comment">//对于第i-1列所有状态</span></span><br><span class="line">                <span class="keyword">if</span> ((j &amp; k ) == <span class="number">0</span> &amp;&amp; st[ j | k]) </span><br><span class="line">                <span class="comment">// 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) </span></span><br><span class="line">                <span class="comment">//解释一下st[j | k] </span></span><br><span class="line">                <span class="comment">//已经知道st[]数组表示的是这一列没有连续奇数个0的情况，</span></span><br><span class="line">                <span class="comment">//我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，</span></span><br><span class="line">                <span class="comment">//还要考虑自己这一列（i-1列）横插到第i列的</span></span><br><span class="line">                <span class="comment">//比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，</span></span><br><span class="line">                <span class="comment">//那么合在第i-1列，到底有多少个1呢？</span></span><br><span class="line">                <span class="comment">//自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101</span></span><br><span class="line">                <span class="comment">//这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的</span></span><br><span class="line"></span><br><span class="line">                    state[j].<span class="built_in">push_back</span>(k);  </span><br><span class="line">                    <span class="comment">//二维数组state[j]表示第j行， </span></span><br><span class="line">                    <span class="comment">//j表示 第i列“真正”可行的状态，</span></span><br><span class="line">                    <span class="comment">//如果第i-1列的状态k和j不冲突则压入state数组中的第j行。</span></span><br><span class="line">                    <span class="comment">//“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三部分：dp开始</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);  </span><br><span class="line">        <span class="comment">//全部初始化为0，因为是连续读入，这里是一个清空操作。</span></span><br><span class="line">        <span class="comment">//类似上面的state[j].clear()</span></span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;<span class="comment">// 这里需要回忆状态表示的定义</span></span><br><span class="line">        <span class="comment">//按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。</span></span><br><span class="line">        <span class="comment">//首先，这里没有-1列，最少也是0列。</span></span><br><span class="line">        <span class="comment">//其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123; <span class="comment">//遍历每一列:第i列合法范围是(0~m-1列)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); j ++) &#123;  <span class="comment">//遍历当前列（第i列）所有状态j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])    <span class="comment">// 遍历第i-1列的状态k，如果“真正”可行，就转移</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];    <span class="comment">// 当前列的方案数就等于之前的第i-1列所有状态k的累加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后答案是什么呢？</span></span><br><span class="line">        <span class="comment">//f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。</span></span><br><span class="line">        <span class="comment">//即整个棋盘处理完的方案数</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h3><p><img src="/2022/12/14/algorithm/image-20230811112610131.png" alt="image-20230811112610131"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][N],w[N][N];<span class="comment">//w表示的是无权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">      cin&gt;&gt;w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="comment">//因为要求最小值，所以初始化为无穷大</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//因为零是起点,所以f[1][0]=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//i表示所有的情况</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//j表示走到哪一个点</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//k表示走到j这个点之前,以k为终点的最短距离</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">         f[i][j]=<span class="built_in">min</span>(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+w[k][j]);<span class="comment">//更新最短距离</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//表示所有点都走过了,且终点是n-1的最短距离</span></span><br><span class="line">    <span class="comment">//位运算的优先级低于&#x27;+&#x27;-&#x27;所以有必要的情况下要打括号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p><img src="/2022/12/14/algorithm/image-20230811153845644.png" alt="image-20230811153845644" style="zoom: 80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//求f[x][y]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    f[x][y]=<span class="number">1</span>;<span class="comment">//注意这个初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">1</span>&amp;&amp;a&lt;=n&amp;&amp;b&gt;=<span class="number">1</span>&amp;&amp;b&lt;=m&amp;&amp;h[x][y]&gt;h[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            f[x][y]=<span class="built_in">max</span>(f[x][y],<span class="built_in">dp</span>(a,b)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;h[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));<span class="comment">//做下标记</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历搜索最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">dp</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p>区间贪心讨论按左端点、右端点排序，然后依次枚举每个区间</p>
<h3 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h3><p>将每个区间按照右端点从小到大进行排序</p>
<p>从前往后枚举区间，end值初始化为无穷小</p>
<p>如果本次区间不能覆盖掉上次区间的右端点， ed &lt; range[i].l</p>
<p>说明需要选择一个新的点， res ++ ; ed = range[i].r;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range&amp;W)<span class="type">const</span><span class="comment">//按照右端点排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,ed=<span class="number">-2e9</span>;<span class="comment">//ed是上一个点的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(range[i].l&gt;ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed=range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大不相交区间个数"><a href="#最大不相交区间个数" class="headerlink" title="最大不相交区间个数"></a>最大不相交区间个数</h3><p>和上一题代码是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range&amp;W)<span class="type">const</span><span class="comment">//按照右端点排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r&lt;W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,ed=<span class="number">-2e9</span>;<span class="comment">//ed是上一个点的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(range[i].l&gt;ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            ed=range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><p><img src="/2022/12/14/algorithm/image-20230331203155127.png" alt="image-20230331203155127" style="zoom:80%;"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range&amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ranges[i].l,&amp;ranges[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges,ranges+n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;heap;<span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r=ranges[i];</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>()||heap.<span class="built_in">top</span>()&gt;=r.l) heap.<span class="built_in">push</span>(r.r);<span class="comment">//如果空或者没有一个区间可以容纳</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><p><img src="/2022/12/14/algorithm/image-20230401191424007.png" alt="image-20230401191424007"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range&amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  l&lt;W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ranges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st,ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ranges[i].l,&amp;ranges[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges,ranges+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> suc=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=i,r=<span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n&amp;&amp;ranges[j].l&lt;=st)</span><br><span class="line">        &#123;</span><br><span class="line">            r=<span class="built_in">max</span>(r,ranges[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;st)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=ed)</span><br><span class="line">        &#123;</span><br><span class="line">            suc=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st=r;</span><br><span class="line">        i=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(suc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><h3 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;heap;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        res+=(a+b);</span><br><span class="line">        heap.<span class="built_in">push</span>(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h2><p>排队打水，护航问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">    <span class="built_in">sort</span>(t,t+n);</span><br><span class="line">    <span class="built_in">reverse</span>(t,t+n);</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) res+=t[i]*i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h2><h3 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="built_in">sort</span>(q,q+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) res+=<span class="built_in">abs</span>(q[i]-q[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h2><h3 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII cow[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w,&amp;s);</span><br><span class="line">        cow[i]=&#123;w+s,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(cow,cow+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">-2e9</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s=cow[i].first-cow[i].second,w=cow[i].second;</span><br><span class="line">        res=<span class="built_in">max</span>(res,sum-s);</span><br><span class="line">        sum+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法复习"><a href="#算法复习" class="headerlink" title="算法复习"></a>算法复习</h1><p>attention：</p>
<ul>
<li>归并排序的扫尾工作</li>
</ul>
<p>回溯法</p>
<h2 id="递归-amp-amp-子集树框架"><a href="#递归-amp-amp-子集树框架" class="headerlink" title="递归&amp;&amp;子集树框架"></a>递归&amp;&amp;子集树框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n) <span class="built_in">output</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">compute</span>()<span class="comment">//判断所需变量的计算</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">constraint</span>(t))<span class="comment">//约束函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">changestate</span>();</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">stateback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bound</span>(t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">compute_back</span>()<span class="comment">//判断所需变量的计算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代框架"><a href="#迭代框架" class="headerlink" title="迭代框架"></a>迭代框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(n,t)&lt;<span class="built_in">g</span>(n,t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">f</span>(n,t);i&lt;=<span class="built_in">g</span>(n,t);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">constraint</span>(t)&amp;&amp;<span class="built_in">bound</span>(t))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">solution</span>(t)) <span class="built_in">output</span>();</span><br><span class="line">                    <span class="keyword">else</span> t++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排列树框架"><a href="#排列树框架" class="headerlink" title="排列树框架"></a>排列树框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n) <span class="built_in">output</span>();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">constraint</span>(t)&amp;&amp;<span class="built_in">bound</span>(t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">            <span class="built_in">changestate</span>();</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">changestate</span>();</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cw=<span class="number">0</span>,cbest=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> c1,c2;</span><br><span class="line"><span class="type">int</span> x[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> bestx[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw&gt;cbest)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) bestx[i]=x[i];</span><br><span class="line">            cbest=cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r-=w[t];</span><br><span class="line">    <span class="keyword">if</span>(cw+w[t]&lt;=c1)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">1</span>;</span><br><span class="line">        cw+=w[t];</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        cw-=w[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cw+r&gt;cbest)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r+=w[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">        r+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 100</span><br><span class="line">90 10 80 10</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line">w = [<span class="number">0</span>]*<span class="number">100</span></span><br><span class="line">x = [<span class="number">0</span>]*<span class="number">100</span></span><br><span class="line">bestx = [<span class="number">0</span>]*<span class="number">100</span></span><br><span class="line">cbest = <span class="number">0</span></span><br><span class="line">cw = <span class="number">0</span></span><br><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">global</span> cw,cbest,x,bestx,r</span><br><span class="line">    <span class="keyword">if</span> t&gt;n:</span><br><span class="line">        <span class="keyword">if</span> cw&gt;cbest:</span><br><span class="line">            bestx = x.copy()</span><br><span class="line">            cbest = cw</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    r -= w[t]</span><br><span class="line">    <span class="keyword">if</span> cw+w[t]&lt;= c:</span><br><span class="line">        x[t] = <span class="number">1</span></span><br><span class="line">        cw+=w[t]</span><br><span class="line">        backtrack(t+<span class="number">1</span>)</span><br><span class="line">        x[t] = <span class="number">0</span></span><br><span class="line">        cw-=w[t]</span><br><span class="line">    <span class="keyword">if</span> cw+r&gt;cbest:</span><br><span class="line">        x[t] = <span class="number">0</span></span><br><span class="line">        backtrack(t+<span class="number">1</span>)</span><br><span class="line">    r += w[t]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> n,c,w,r</span><br><span class="line">    n,c = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">    w[<span class="number">1</span>:n+<span class="number">1</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    r = <span class="built_in">sum</span>(w[<span class="number">1</span>:n+<span class="number">1</span>])</span><br><span class="line">    backtrack(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(cbest)</span><br><span class="line">    <span class="built_in">print</span>(bestx[<span class="number">1</span>:n+<span class="number">1</span>])</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h2 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> M[N][N];</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="type">int</span> bestx[N];</span><br><span class="line"><span class="type">int</span> f1,f2[N];</span><br><span class="line"><span class="type">int</span> bestf=<span class="number">1000000</span>,n,f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f&lt;bestf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[i]=x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            bestf=f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f1+=M[x[i]][<span class="number">1</span>];<span class="comment">//在swap前，提前使用j</span></span><br><span class="line">        f2[t]=((f2[t<span class="number">-1</span>]&gt;f1)?f2[t<span class="number">-1</span>]:f1)+M[x[i]][<span class="number">2</span>];</span><br><span class="line">        f+=f2[t];</span><br><span class="line">        <span class="keyword">if</span>(f&lt;bestf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        f1-=M[x[i]][<span class="number">1</span>];</span><br><span class="line">        f-=f2[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;M[i][<span class="number">1</span>]&gt;&gt;M[i][<span class="number">2</span>];<span class="comment">//第i个作业在某台机器上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        x[i]=i;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;bestx[i]&gt;&gt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;bestf;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="type">int</span> sum,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">place</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;t;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(j-t)==<span class="built_in">abs</span>(x[j]-x[t]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">place</span>(t)) <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">output 92</span><br></pre></td></tr></table></figure>
<h2 id="0-1背包问题简化版本"><a href="#0-1背包问题简化版本" class="headerlink" title="0-1背包问题简化版本"></a>0-1背包问题简化版本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> x[N],bestx[N];</span><br><span class="line"><span class="type">int</span> bestv,cv;</span><br><span class="line"><span class="type">int</span> cw,r;</span><br><span class="line"><span class="type">int</span> w[N],v[N];</span><br><span class="line"><span class="type">int</span> c,n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv&gt;bestv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[i]=x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            bestv=cv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r-=v[t];</span><br><span class="line">    <span class="keyword">if</span>(cw+w[t]&lt;=c)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">1</span>;</span><br><span class="line">        cv+=v[t];</span><br><span class="line">        cw+=w[t];</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        cv-=v[t];</span><br><span class="line">        cw-=w[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cv+r&gt;bestv)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    r+=v[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">        r+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;bestv;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> G[N][N];</span><br><span class="line"><span class="type">int</span> x[N],bestx[N];</span><br><span class="line"><span class="type">int</span> r,cbest,cv;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">choose</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==<span class="number">1</span>&amp;&amp;G[i][t]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv&gt;cbest)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[i]=x[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cbest=cv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">choose</span>(t))</span><br><span class="line">    &#123;</span><br><span class="line">        cv++;</span><br><span class="line">        x[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">        cv--;</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cv+r&gt;cbest)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="comment">//顶点和边数</span></span><br><span class="line">    r=n;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u][v]=<span class="number">1</span>;</span><br><span class="line">        G[v][u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;cbest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="TSP问题"><a href="#TSP问题" class="headerlink" title="TSP问题"></a>TSP问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> G[N][N];</span><br><span class="line"><span class="type">int</span> x[N],bestx[N];</span><br><span class="line"><span class="type">int</span> cbest=<span class="number">1000000</span>,cw;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[x[n]][x[n<span class="number">-1</span>]]&gt;<span class="number">0</span>&amp;&amp;G[x[n]][<span class="number">1</span>]&gt;<span class="number">0</span>&amp;&amp;(cw+G[x[n]][x[n<span class="number">-1</span>]]+G[x[n]][<span class="number">1</span>]&lt;cbest))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[j]=x[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cbest=cw+G[x[n]][x[n<span class="number">-1</span>]]+G[x[n]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[x[t<span class="number">-1</span>]][x[i]]&gt;<span class="number">0</span>&amp;&amp;(cw+G[x[t<span class="number">-1</span>]][x[i]]&lt;cbest))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">            cw+=G[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line">            <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">            cw-=G[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line">            <span class="built_in">swap</span>(x[i],x[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;G[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        x[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl&lt;&lt;cbest;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-1</span> <span class="number">30</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">30</span> <span class="number">-1</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">-1</span> <span class="number">20</span></span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">20</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h3><p>数值随机化算法</p>
<p>投点法计算π：设有一半径为r的圆及其外切四边形，向该正方形随机地投掷n个点，设落入圆内的点数为k，由于所投入的点再正方形上均匀分布，故落入圆中的点的概率为。。，当n足够大时，k与n的比就逼近这一概率，故π=。。。</p>
<p>计算定积分：向单位正方形内随机地投n个点，如果有m个点落入G内，由于所投点均匀地分布在正方形上，故当n足够，可近似计算G为</p>
<p>解线性方程组，</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>dive into deep learning</title>
    <url>/2023/07/22/dive-into-deep-learning/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h3><blockquote>
<p>【PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】】 </p>
<p><a href="https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=f21aab4ae7e1148acd5e06c0dddddfd9">https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=f21aab4ae7e1148acd5e06c0dddddfd9</a></p>
</blockquote>
<h3 id="1-环境管理"><a href="#1-环境管理" class="headerlink" title="1.环境管理"></a>1.环境管理</h3><p>建立不同的python版本环境（anaconda prompt）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch python=3.6 #创建一个名为pytorch的环境</span><br></pre></td></tr></table></figure>
<p>激活/进入特定环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></table></figure>
<p>环境下的工具包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>
<p>安装pytorch工具包</p>
<p>在pytorch官网按照环境复制命令在特定环境进行下载</p>
<p>安装完之后检查pytorch安装情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>
<p>两个工具：pycharm和jupyter</p>
<p>pycharm创建项目记得勾选对应的interpreter(如：D:\Users\lzh\anaconda3\envs\pytorch)</p>
<p>jupyter选择环境：在prompt下命令行开启jupyter：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install nb_conda</span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>jupyter shift+enter执行并编辑下一行</p>
<h3 id="2-两个函数"><a href="#2-两个函数" class="headerlink" title="2.两个函数"></a>2.两个函数</h3><p><img src="/2023/07/22/dive-into-deep-learning/image-20240129230520456.png" alt="image-20240129230520456"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir(torch) #dir(package)</span><br><span class="line">dir(torch.cuda)</span><br><span class="line">dir(torch.cuda.is_available) #输出是双下划线，双下划线表示不可修改，此时不能进一步打开了，就是函数了</span><br><span class="line">help(torch.cuda.is_available)</span><br></pre></td></tr></table></figure>
<h3 id="3-数据的加载"><a href="#3-数据的加载" class="headerlink" title="3.数据的加载"></a>3.数据的加载</h3><p>两个类：</p>
<ul>
<li><p>Dataset：提供一种方式去获取数据及其label。提取数据，进行编号，数据对应label</p>
<ul>
<li>如何获取每一个数据及其label</li>
<li>告诉我们总共有多少的数据</li>
</ul>
</li>
<li><p>Dataloader：为网络提供不同的数据形式。送进网络之前进行打包和压缩</p>
</li>
</ul>
<p>如果文件夹名称就是label：</p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240130124045068.png" alt="image-20240130124045068"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,root_dir,label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir,self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir,self.label_dir,img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;hymenoptera_data/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br></pre></td></tr></table></figure>
<p>如果分开了img和label：</p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240130130301999.png" alt="image-20240130130301999"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,root_dir,image_dir,label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.image_dir = image_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.img_path = os.path.join(self.root_dir, self.image_dir)</span><br><span class="line">        self.label_path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_name = os.listdir(self.img_path)</span><br><span class="line">        self.label_name = os.listdir(self.label_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_path = os.path.join(self.img_path,self.img_name[idx])</span><br><span class="line">        label_path = os.path.join(self.label_path, self.label_name[idx])</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        f = <span class="built_in">open</span>(label_path)</span><br><span class="line">        label = f.readline()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">return</span> img,label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_name)</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;new_data/train&quot;</span></span><br><span class="line">ants_image_dir = <span class="string">&quot;ants_image&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants_label&quot;</span></span><br><span class="line">bees_image_dir = <span class="string">&quot;bees_image&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees_label&quot;</span></span><br><span class="line"></span><br><span class="line">ants_dataset = MyData(root_dir,ants_image_dir,ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir,bees_image_dir,bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br></pre></td></tr></table></figure>
<h3 id="4-tensorboard的使用"><a href="#4-tensorboard的使用" class="headerlink" title="4.tensorboard的使用"></a>4.tensorboard的使用</h3><h4 id="1）SummaryWriter的使用"><a href="#1）SummaryWriter的使用" class="headerlink" title="1）SummaryWriter的使用"></a>1）SummaryWriter的使用</h4><p>文件名不能是tensorboard.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>) <span class="comment">#存储tensorboard日志地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i) <span class="comment"># name y x</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>运行后代码相同文件夹下生成logs文件夹</p>
<p>控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensorboad --logdir=logs #logs可替换为其他存储日志文件的文件夹名称</span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240130162157354.png" alt="image-20240130162157354"></p>
<p>如果改变图片的名称，会重新画一幅图，如果不改变图片的名称，会在上一幅图上画</p>
<p>解决方法：删掉原有log文件</p>
<h4 id="2）add-image的使用"><a href="#2）add-image的使用" class="headerlink" title="2）add_image的使用"></a>2）add_image的使用</h4><p>add_image将图片在tensorboard中展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>) <span class="comment">#存储tensorboard日志地方</span></span><br><span class="line">image_path = <span class="string">&quot;hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">img_array = np.array(img_PIL)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_array))</span><br><span class="line"><span class="built_in">print</span>(img_array.shape)</span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>,img_array,<span class="number">2</span>,dataformats=<span class="string">&#x27;HWC&#x27;</span>) <span class="comment"># 标题 内容(限定格式) 第几幅 格式</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240130164118358.png" alt="image-20240130164118358"></p>
<h3 id="5-transform的使用"><a href="#5-transform的使用" class="headerlink" title="5.transform的使用"></a>5.transform的使用</h3><h4 id="1）流程"><a href="#1）流程" class="headerlink" title="1）流程"></a>1）流程</h4><p><img src="/2023/07/22/dive-into-deep-learning/image-20240131114410103.png" alt="image-20240131114410103"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="comment"># 获取图片</span></span><br><span class="line">img_path = <span class="string">&quot;hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="comment"># tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="comment"># transform</span></span><br><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br><span class="line"><span class="comment"># add_image</span></span><br><span class="line">writer.add_image(<span class="string">&quot;img&quot;</span>,tensor_img)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="2）常见的Transforms"><a href="#2）常见的Transforms" class="headerlink" title="2）常见的Transforms"></a>2）常见的Transforms</h4><p><img src="/2023/07/22/dive-into-deep-learning/image-20240131115743345.png" alt="image-20240131115743345"></p>
<blockquote>
<p>内置call （ctrl+p 提示参数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call__ &quot;</span>+name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello &quot;</span>+name)</span><br><span class="line"></span><br><span class="line">person = Person()</span><br><span class="line">person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">person.hello(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240131120421868.png" alt="image-20240131120421868"></p>
</blockquote>
<ol>
<li><p>transforms.Normalize</p>
</li>
<li><p>transforms.Resize</p>
</li>
<li><p>transforms.compose:组合多个操作</p>
</li>
<li>transforms.RandomCrop</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line">img_path = <span class="string">&quot;hymenoptera_data/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"><span class="comment"># 建立tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="comment"># 1. totensor</span></span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">img_tensor = trans_totensor(img)</span><br><span class="line"><span class="comment"># 添加原始图片</span></span><br><span class="line">writer.add_image(<span class="string">&quot;img&quot;</span>, img_tensor, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 获取normalize后的图片</span></span><br><span class="line"><span class="comment"># 2. normalize</span></span><br><span class="line">trans_nore = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">img_nore = trans_nore(img_tensor)</span><br><span class="line"><span class="comment"># 添加转换后的图片</span></span><br><span class="line">writer.add_image(<span class="string">&quot;img&quot;</span>, img_nore, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Resize</span></span><br><span class="line"><span class="built_in">print</span>(img.size)</span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>,<span class="number">512</span>))</span><br><span class="line"></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img_resize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. compose</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>)</span><br><span class="line">trans_compose = transforms.Compose([trans_totensor, trans_resize_2])</span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. RandomCrop</span></span><br><span class="line">trans_random = transforms.RandomCrop((<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line">trans_compose_2 = transforms.Compose([trans_random, trans_totensor])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img_crop = trans_compose_2(img)</span><br><span class="line">    writer.add_image(<span class="string">&quot;RandomCrop&quot;</span>, img_crop, i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>关注输入输出</li>
<li>查阅官方文档</li>
<li>关注方法参数</li>
</ul>
<h3 id="6-数据集的使用"><a href="#6-数据集的使用" class="headerlink" title="6.数据集的使用"></a>6.数据集的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="comment"># 数据集的变换</span></span><br><span class="line">dataset_transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 下载数据集</span></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=dataset_transform, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=dataset_transform, download=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在tensorboard上展示</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;p10&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img, target = test_set[i]</span><br><span class="line">    writer.add_image(<span class="string">&quot;test_set&quot;</span>,img,i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>如果下载不成功，通过迅雷等其他方式下载，建立dataset文件夹并将压缩文件直接放到dataset文件夹下，运行代码会自动解压</p>
<h3 id="7-Dataloader的使用"><a href="#7-Dataloader的使用" class="headerlink" title="7.Dataloader的使用"></a>7.Dataloader的使用</h3><p>dataloader从dataset中取数据打包，以便送入神经网络</p>
<p>torch.utils.data.DataLoader()</p>
<ul>
<li>batch_size 表示每次多少个batch_size打成一包</li>
<li>shuffle 表示是否打乱顺序（每次for data in loader时是否打乱顺序，而不是说打包是否随机取，默认就是随机取的）</li>
<li>drop_last 当data/batch_size除不尽要不要舍去剩下的data</li>
<li>numofworks 设置为0表示用主进程加载，Windows下设置为其他值可能出错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一张图片和target</span></span><br><span class="line">img, target =test_data[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(img.shape) <span class="comment">#torch.Size([3, 32, 32])</span></span><br><span class="line"><span class="built_in">print</span>(target) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试batchsize、drop_last、shuffle</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;dataloader&quot;</span>)</span><br><span class="line"><span class="comment"># 可以发现两轮结果不一样，因为shuffle的原因</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        imgs , targets = data</span><br><span class="line">        writer.add_images(<span class="string">&quot;epoch: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch), imgs, step)</span><br><span class="line">        step = step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240201171225665.png" alt="image-20240201171225665"></p>
<h3 id="8-torch-nn"><a href="#8-torch-nn" class="headerlink" title="8. torch.nn"></a>8. torch.nn</h3><p>nn.module：Base class for all neural network modules.</p>
<p>所有神经网络模型都要继承nn.module</p>
<p>神经网络运行于forward函数之中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">tudui =Tudui()</span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">output = tudui(x)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pycharm的断点调试</p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240201173022707.png" alt="image-20240201173022707"></p>
</blockquote>
<h3 id="9-卷积操作"><a href="#9-卷积操作" class="headerlink" title="9.卷积操作"></a>9.卷积操作</h3><p><img src="/2023/07/22/dive-into-deep-learning/image-20240202104746409.png" alt="image-20240202104746409"></p>
<blockquote>
<p>torch.nn.functional.conv2d(<em>input</em>, <em>weight</em>, <em>bias=None</em>, <em>stride=1</em>, <em>padding=0</em>, <em>dilation=1</em>, <em>groups=1</em>)</p>
</blockquote>
<ul>
<li>stride：卷积核移动的步长</li>
<li>padding：输入图像是否填充</li>
<li>weight：卷积核</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="comment"># 输入图像</span></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 卷积核</span></span><br><span class="line">kernel = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">kernel = torch.reshape(kernel, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"><span class="built_in">print</span>(kernel.shape)</span><br><span class="line"><span class="comment"># 卷积操作</span></span><br><span class="line">output = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line">output2 = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(output2)</span><br><span class="line"></span><br><span class="line">output3 = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(output3)</span><br></pre></td></tr></table></figure>
<h3 id="10-神经网络"><a href="#10-神经网络" class="headerlink" title="10.神经网络"></a>10.神经网络</h3><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><blockquote>
<p>torch.nn.Conv2d(<em>in_channels</em>, <em>out_channels</em>, <em>kernel_size</em>, <em>stride=1</em>, <em>padding=0</em>, <em>dilation=1</em>, <em>groups=1</em>, <em>bias=True</em>, <em>padding_mode=’zeros’</em>, <em>device=None</em>, <em>dtype=None</em>)</p>
</blockquote>
<ul>
<li>in_channels：输入通道数</li>
<li>out_channels：卷积层内部可通过增加卷积核数量来增加通道数</li>
<li>kernel_size：只需要设置kernel_size，参数训练中调整</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"><span class="comment"># 建立神经网络模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__() <span class="comment"># 初始化nn.module</span></span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">tudui = Tudui()</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 检测模型</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = tudui(imgs)</span><br><span class="line">    <span class="comment"># print(imgs.shape)</span></span><br><span class="line">    <span class="comment"># print(output.shape)</span></span><br><span class="line"></span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">	<span class="comment"># 为了能够用tensorboard展示进行reshape,但仅此而已</span></span><br><span class="line">    output = torch.reshape(output, (-<span class="number">1</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><blockquote>
<p>池化的作用是减少参数量，下采样</p>
</blockquote>
<p>池化层的stride默认是池化核的size</p>
<p>ceil_model为true表示当输入图片不足池化核时仍然进行池化，false表示不进行</p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240202171432750.png" alt="image-20240202171432750"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建神经网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.maxpool1 = nn.MaxPool2d(kernel_size=<span class="number">3</span>,ceil_mode=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.maxpool1(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"><span class="comment"># 数据集</span></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"><span class="comment"># 运行并展示</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;maxpool&quot;</span>)</span><br><span class="line">tudui = Tudui()</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;imgs&quot;</span>, imgs, step)</span><br><span class="line">    output = tudui(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h4><p>引入非线性特征。relu、sigmoid</p>
<p>参数 inplace：一般inplace为false不覆盖</p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240203110744742.png" alt="image-20240203110744742"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,<span class="built_in">input</span></span>):</span><br><span class="line">        output = self.relu(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset,batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">tudui = Tudui()</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;relu&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = tudui(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="线性层和其他层"><a href="#线性层和其他层" class="headerlink" title="线性层和其他层"></a>线性层和其他层</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">196608</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.linear(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">tudui = Tudui()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = torch.flatten(imgs)</span><br><span class="line">    output = tudui(output)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br></pre></td></tr></table></figure>
<h4 id="sequential的使用"><a href="#sequential的使用" class="headerlink" title="sequential的使用"></a>sequential的使用</h4><p><img src="/2023/07/22/dive-into-deep-learning/image-20240203114533994.png" alt="image-20240203114533994"></p>
<p><img src="/2023/07/22/dive-into-deep-learning/image-20240203120850526.png" alt="image-20240203120850526"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">tudui = Tudui()</span><br><span class="line"><span class="built_in">print</span>(tudui)</span><br><span class="line"><span class="built_in">input</span> = torch.ones((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">output = tudui(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;seq&quot;</span>)</span><br><span class="line">writer.add_graph(tudui, <span class="built_in">input</span>)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h4 id="损失函数与反向传播"><a href="#损失函数与反向传播" class="headerlink" title="损失函数与反向传播"></a>损失函数与反向传播</h4><p>loss计算output和target之间的差距，loss越小越好，loss作为反向传播的依据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">tudui = Tudui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = tudui(imgs)</span><br><span class="line">    result_loss = loss(output, targets)</span><br><span class="line">    <span class="built_in">print</span>(result_loss)</span><br><span class="line">    <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>lr：学习速率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tudui</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集</span></span><br><span class="line">dataset= torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                      download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss、模型、优化器</span></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">tudui = Tudui()</span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = tudui(imgs)</span><br><span class="line">        result_loss = loss(output, targets)</span><br><span class="line">        optim.zero_grad() <span class="comment"># 将梯度清零</span></span><br><span class="line">        result_loss.backward() <span class="comment"># 计算新的梯度</span></span><br><span class="line">        optim.step() <span class="comment"># 根据梯度更新参数</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss)</span><br></pre></td></tr></table></figure>
<h4 id="现有模型的修改与使用"><a href="#现有模型的修改与使用" class="headerlink" title="现有模型的修改与使用"></a>现有模型的修改与使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment"># train_data = torchvision.datasets.ImageNet(&quot;../data_image_net&quot;, split=&#x27;train&#x27;, download=True,</span></span><br><span class="line"><span class="comment">#                                            transform=torchvision.transforms.ToTensor())</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">vgg16_false = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16_true = torchvision.models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(vgg16_true)</span><br><span class="line"></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 在现有模型后添加一层网络</span></span><br><span class="line">vgg16_true.classifier.add_module(<span class="string">&#x27;add_linear&#x27;</span>, nn.Linear(<span class="number">1000</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(vgg16_true)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(vgg16_false)</span><br><span class="line"><span class="comment"># 修改现有模型某一层的参数值</span></span><br><span class="line">vgg16_false.classifier[<span class="number">6</span>] = nn.Linear(<span class="number">4096</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(vgg16_false)</span><br></pre></td></tr></table></figure>
<h3 id="11-完整训练套路"><a href="#11-完整训练套路" class="headerlink" title="11.完整训练套路"></a>11.完整训练套路</h3><p>CPU：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                        download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(train_data_size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_data_size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用DataLoader来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">tudui = Tudui()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_train&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始--------&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = tudui(imgs)</span><br><span class="line">        loss = loss_fn(output, targets) <span class="comment"># 计算loss</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment"># 调整参数</span></span><br><span class="line"></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试步骤</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs, targets = data</span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy / test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy / test_data_size, total_test_step)</span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    torch.save(tudui, <span class="string">&quot;tudui_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h3 id="12-利用GPU训练"><a href="#12-利用GPU训练" class="headerlink" title="12. 利用GPU训练"></a>12. 利用GPU训练</h3><p>方法一：调用 网络模型、数据（输入、标注）、损失函数的 cuda方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available(): <span class="comment"># 判断cuda是否可用</span></span><br><span class="line">	xxx</span><br></pre></td></tr></table></figure>
<p>GPU版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                        download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(train_data_size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_data_size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用DataLoader来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">tudui = Tudui()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    tudui = tudui.cuda()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    loss_fn = loss_fn.cuda()</span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_train&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始--------&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            targets = targets.cuda()</span><br><span class="line">            imgs = imgs.cuda()</span><br><span class="line">        output = tudui(imgs)</span><br><span class="line">        loss = loss_fn(output, targets) <span class="comment"># 计算loss</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment"># 调整参数</span></span><br><span class="line"></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试步骤</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs, targets = data</span><br><span class="line">            <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                targets = targets.cuda()</span><br><span class="line">                imgs = imgs.cuda()</span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy / test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy / test_data_size, total_test_step)</span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    torch.save(tudui, <span class="string">&quot;tudui_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<p>首先创建device，然后调用 网络模型、数据（输入、标注）、损失函数 的to方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>GPU版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                        download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(train_data_size))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_data_size))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用DataLoader来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">tudui = Tudui()</span><br><span class="line">tudui = tudui.to(device)</span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">loss_fn = loss_fn.to(device)</span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_train&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始--------&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        output = tudui(imgs)</span><br><span class="line">        loss = loss_fn(output, targets) <span class="comment"># 计算loss</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment"># 调整参数</span></span><br><span class="line"></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数: &#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试步骤</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs, targets = data</span><br><span class="line">            targets = targets.to(device)</span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy / test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy / test_data_size, total_test_step)</span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    torch.save(tudui, <span class="string">&quot;tudui_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h3 id="13-模型验证"><a href="#13-模型验证" class="headerlink" title="13.模型验证"></a>13.模型验证</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tudui = torch.load(<span class="string">&quot;tudui_9.pth&quot;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>)) </span><br><span class="line"><span class="comment"># 如果使用GPU训练的模型，使用map_location映射到cpu上</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 测试之前：</span></span><br><span class="line">tudui.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br></pre></td></tr></table></figure>
<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image_path = <span class="string">&quot;dataset/dog.jpg&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"><span class="built_in">print</span>(image)</span><br><span class="line">image = image.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">transform = torchvision.transforms.Compose([torchvision.transforms.Resize((<span class="number">32</span>,<span class="number">32</span>)),</span><br><span class="line">                                            torchvision.transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">image = transform(image)</span><br><span class="line"><span class="built_in">print</span>(image)</span><br><span class="line"></span><br><span class="line">tudui = torch.load(<span class="string">&quot;tudui_9.pth&quot;</span>, map_location=torch.device(<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(tudui)</span><br><span class="line"></span><br><span class="line">image = torch.reshape(image, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">tudui.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    output = tudui(image)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="built_in">print</span>(output.argmax(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>pytorch入门部分 完结撒花😊</p>
]]></content>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法题解</title>
    <url>/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>
<p>书写结构：解空间和解结构，剪枝策略，示例，代码，时间复杂度分析</p>
<h1 id="5-1子集和问题"><a href="#5-1子集和问题" class="headerlink" title="5-1子集和问题"></a>5-1子集和问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102174153224.png" alt="image-20230102174153224" style="zoom: 67%;"></p>
<h3 id="1-解空间和解结构"><a href="#1-解空间和解结构" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>类似于0-1背包问题，对于S大小为n的子集和问题，解空间是由长度为n的0-1向量组成，解的结构为子集树，如对于上述示例的解，解空间即为(1,1,1,0,0,0)</p>
<h3 id="2-剪枝策略"><a href="#2-剪枝策略" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>注意到题目说S是正整数的集合，c是正整数，故深搜的过程一定使得子集和增加或不变。</p>
<p>考虑在某节点处向下搜索的过程，设当前层数为k（即当前考虑是否加入数S[k]到子集中）</p>
<p>约束函数：维护变量cw表示当前子集和，若<code>cw+S[k]&gt;c</code>，则剪去左子树</p>
<p>限界函数：计算变量rw表示剩余的整数之和(S[k+1:n-1]之和)，若<code>cw+rw&lt;c</code>，即将之后所有整数加入子集也无法得到解，故减去右子树</p>
<p>对于本题而言，如果只要一个可行解的话，可以在搜索每个节点的时候，在考虑完是否加入数S[k]之后，判断S[k]是否等于c，若等于，则无需再搜索了</p>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>太多了不太好画，减少点数据量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 10</span><br><span class="line">2 2 6</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102221034796.png" alt="image-20230102221034796" style="zoom: 50%;"></p>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>这里就没弄文件读写了（可以直接粘贴下面的输入测试啦）</p>
<p>输入1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure>
<p>输入2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 11 12 5 4</span><br></pre></td></tr></table></figure>
<p>得到一个解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> S[N],res[N];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;<span class="comment">//解的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispsolution</span><span class="params">(<span class="type">int</span> res[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;num++&lt;&lt;<span class="string">&quot;个解&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cw,<span class="type">int</span> rw,<span class="type">int</span> res[],<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level&gt;n)<span class="comment">//到达叶节点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw==c)<span class="comment">//找到可行解</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">             <span class="keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//直接结束程序(会不会有点暴力)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cw+S[level]&lt;=c)<span class="comment">//考虑是否进入左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[level]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(cw+S[level],rw-S[level],res,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rw=rw-S[level];<span class="comment">//计算剩余整数之和(剩余整数不包括当前整数)</span></span><br><span class="line">        <span class="comment">//这里和博客不太一样(他rw算的是包括当前的整数的)</span></span><br><span class="line">        <span class="keyword">if</span>(cw+rw&gt;=c)<span class="comment">//考虑是否进入右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[level]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(cw,rw,res,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="type">int</span> rw=<span class="number">0</span>;<span class="comment">//为了方便计算rw,首先计算所有整数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//为了方便,从下标1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;S[i];</span><br><span class="line">        rw=rw+S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,rw,res,<span class="number">1</span>);<span class="comment">//cw=1,res存储解,从第一层开始</span></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214448956.png" alt="image-20230102214448956"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214508262.png" alt="image-20230102214508262"></p>
<p>得到所有解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> S[N],res[N];</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;<span class="comment">//解的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispsolution</span><span class="params">(<span class="type">int</span> res[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;num++&lt;&lt;<span class="string">&quot;个解&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cw,<span class="type">int</span> rw,<span class="type">int</span> res[],<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level&gt;n)<span class="comment">//到达叶节点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw==c)  <span class="built_in">dispsolution</span>(res);<span class="comment">//找到可行解</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cw+S[level]&lt;=c)<span class="comment">//考虑是否进入左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[level]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(cw+S[level],rw-S[level],res,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rw=rw-S[level];<span class="comment">//计算剩余整数之和(剩余整数不包括当前整数)</span></span><br><span class="line">        <span class="comment">//这里和博客不太一样(他rw算的是包括当前的整数的)</span></span><br><span class="line">        <span class="keyword">if</span>(cw+rw&gt;=c)<span class="comment">//考虑是否进入右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[level]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(cw,rw,res,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="type">int</span> rw=<span class="number">0</span>;<span class="comment">//为了方便计算rw,首先计算所有整数的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//为了方便,从下标1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;S[i];</span><br><span class="line">        rw=rw+S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,rw,res,<span class="number">1</span>);<span class="comment">//cw=1,res存储解,从第一层开始</span></span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214546946.png" alt="image-20230102214546946"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214609533.png" alt="image-20230102214609533"></p>
<h3 id="5-时间复杂度分析"><a href="#5-时间复杂度分析" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>考虑最坏情况下时间复杂度，每个节点都进行搜索，处理每个节点所需的时间均为$O(1)$，一共有1+2+4+8+…+2^n^</p>
<p>=$O(2^{n+1})$个节点，故时间复杂度为$O(2^{n+1})$</p>
<p>参考：<a href="https://blog.csdn.net/gl620321/article/details/108801724">https://blog.csdn.net/gl620321/article/details/108801724</a></p>
<h1 id="5-2-最小长度电路板排列问题"><a href="#5-2-最小长度电路板排列问题" class="headerlink" title="5-2 最小长度电路板排列问题"></a>5-2 最小长度电路板排列问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223036593.png" alt="image-20230102223036593" style="zoom:67%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223107634.png" alt="image-20230102223107634" style="zoom:67%;"></p>
<h3 id="1-解空间和解结构-1"><a href="#1-解空间和解结构-1" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>类似于旅行商问题，对于n个电路板的最小电路板排列问题，其解空间为n个数的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-1"><a href="#2-剪枝策略-1" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护变量bestd表示当前的最小长度，假设此时选择第i个位置上的电路板，考虑选择第j个电路板(j&gt;=i，因为i前面的已经选择好了)作为该位置上的排列，此时利用已经选择好的第1~第i个位置上的电路板（第i个位置刚刚选择好的）来计算连接块的最大长度，若该长度小于当前最优解，则继续进行下面位置的选择，否则第i个位置上不能选择第j个电路板，剪去该子树</p>
<h3 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>示例数据量太大，减少点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure>
<p>4个电路板，L1={1,2},L2={1,2,4},L3={1,4},L4={1,2,3}</p>
<p>类似于下面的画法（排列树太多了，只画了一个子树）：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103104730475.png" alt="image-20230103104730475"></p>
<p>最后的结果：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102814230.png" alt="image-20230103102814230"></p>
<h3 id="4-代码-1"><a href="#4-代码-1" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>输入文件 input.txt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">1 0 1 1 0</span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 1 0 1 0</span><br><span class="line">0 0 0 0 1</span><br><span class="line">0 1 0 0 1</span><br></pre></td></tr></table></figure>
<p>输入含义</p>
<p>L1={1,4,5,6},L2={1,2,3,6,8},L3={1,3,4,5},L4={1,2,3,4,6},L5={1,7,8}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> bestx[<span class="number">10</span>];<span class="comment">// 这是最终的最优解排列顺序</span></span><br><span class="line"><span class="type">int</span> B[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//电路板在连接块中的排列，是一个二维数组</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>], low[<span class="number">10</span>], high[<span class="number">10</span>];<span class="comment">// 分别是当前的排列、最左边电路板、最右边电路板</span></span><br><span class="line"><span class="type">int</span> bestd=<span class="number">0</span>;<span class="comment">// 最优解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123;<span class="comment">// 计算当前ii排列最小长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		high[i] = <span class="number">0</span>;</span><br><span class="line">		low[i] = n + <span class="number">1</span>;<span class="comment">// 先初始化最左边和最右边的值，</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ii; i++)<span class="comment">// 对于第i行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)<span class="comment">// k列</span></span><br><span class="line">			<span class="keyword">if</span> (B[x[i]][k] &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果第i个电路板在第k个连接块中，</span></span><br><span class="line">				<span class="keyword">if</span> (i &lt; low[k])<span class="comment">//low[k]代表第K个连接块的最左边的值，如果i比它小，则更新左值</span></span><br><span class="line">					low[k] = i;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; high[k])</span><br><span class="line">					high[k] = i;<span class="comment">//如果比初始的右值大，则更新右值</span></span><br><span class="line">			&#125;</span><br><span class="line">	<span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">		<span class="keyword">if</span> (low[k] &lt;= n &amp;&amp; high[k] &gt; <span class="number">0</span> &amp;&amp; tmp &lt; high[k] - low[k])</span><br><span class="line">            <span class="comment">//若连接块的长度无法得到（前面两个bool表达式不满足，不计算该连接块的长度）</span></span><br><span class="line">			tmp = high[k] - low[k];<span class="comment">//计算每个连接块的举例</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;<span class="comment">// 交换i和j位置的值</span></span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = x[i];</span><br><span class="line">	x[i] = x[j];</span><br><span class="line">	x[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == n) &#123;<span class="comment">// 如果到达末尾</span></span><br><span class="line">		<span class="type">int</span> tmp = <span class="built_in">len</span>(i);<span class="comment">// 计算当前排列最小长度</span></span><br><span class="line">		<span class="keyword">if</span> (tmp &lt; bestd) &#123;</span><br><span class="line">			bestd = tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				bestx[j] = x[j];</span><br><span class="line">		&#125; <span class="comment">// 如果比最优解还要好，则更新bestx[]排列；</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 若不是末尾；</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(x, i, j);</span><br><span class="line">			<span class="type">int</span> ld = <span class="built_in">len</span>(i);</span><br><span class="line">			<span class="keyword">if</span> (ld &lt; bestd)</span><br><span class="line">				<span class="built_in">backtrack</span>(i + <span class="number">1</span>);<span class="comment">// 则继续进入下一个数，</span></span><br><span class="line">			<span class="built_in">swap</span>(x, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arrangeBoards</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	bestd = n + <span class="number">1</span>;<span class="comment">// 先假设一个很大的值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		x[i] = i;<span class="comment">// 这里是最开始的排序；</span></span><br><span class="line">	<span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> bestd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;<span class="comment">//文件输入流</span></span><br><span class="line">	ifs&gt;&gt;n;</span><br><span class="line">	ifs&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			ifs&gt;&gt;B[i][j] ;<span class="comment">// 输入的电路板的二维数组排列</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> minLen = <span class="built_in">arrangeBoards</span>();</span><br><span class="line">	cout&lt;&lt;minLen&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102521881.png" alt="image-20230103102521881"></p>
<h3 id="5-时间复杂度分析-1"><a href="#5-时间复杂度分析-1" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>对于最坏情况，每个节点都需要计算一次len，即序号运行len函数，而第i层节点运行len函数时间复杂度为$O(im)$，故最坏情况下所需时间为$T=O(m)<em>(n-1)+O(2m)</em>(n-1)<em>(n-2)+…+O(n</em>m)<em>(n-1)!$，故最坏情况下时间复杂度为$O(m</em>n!)$</p>
<h1 id="5-3-最小重量机器设计问题"><a href="#5-3-最小重量机器设计问题" class="headerlink" title="5-3 最小重量机器设计问题"></a>5-3 最小重量机器设计问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103110515293.png" alt="image-20230103110515293" style="zoom:67%;"></p>
<p>题目两个要求，总价格不超过d，并且部件重量之和要最小</p>
<h3 id="1-解空间和解结构-2"><a href="#1-解空间和解结构-2" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个部件，m个供应商的最小重量机器设计问题，其解空间为长度为n的向量，向量的每一项为1~m的整数，对应的解结构为排列树（也不是那种TSP的排列树，不过也是排列啦，姑且称之为排列树）</p>
<h3 id="2-剪枝策略-2"><a href="#2-剪枝策略-2" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑第i个部件供应商的选择</p>
<p>约束函数：维护变量cp表示当前已经购得的部件的价格之和，假设考虑选择第j个供应商，若<code>cp+c[i][j]&gt;d</code>，则剪去以该节点为根节点的子树，无需再进行搜索</p>
<p>限界函数：维护变量cw表示当前已经购得的部件的重量之和，变量bestw表示当前最优解的重量之和，假设考虑选择第j个供应商，若<code>cw+w[i][j]&gt;=bestw</code>，则剪去该节点为根节点的子树，无需进行搜索</p>
<h3 id="3-示例-2"><a href="#3-示例-2" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>对于题中示例画树：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103210648180.png" alt="image-20230103210648180"></p>
<h3 id="4-代码-2"><a href="#4-代码-2" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 4</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line">2 2 2</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure>
<p>没实现文件读写了~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,d;<span class="comment">//n个部件，m个供应商，总价格不超过d</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">999</span>][<span class="number">999</span>];<span class="comment">//c[i][j]为从供应商j购买部件i所花费的价格；</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">999</span>][<span class="number">999</span>];<span class="comment">//w[i][j]为......重量</span></span><br><span class="line"><span class="type">int</span> cw=<span class="number">0</span>,cp=<span class="number">0</span>;<span class="comment">//当前部件的重量 价格</span></span><br><span class="line"><span class="type">int</span> bestw=<span class="number">999</span>,bestp=<span class="number">999</span>;<span class="comment">//最优方案的重量，价格</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">999</span>];<span class="comment">//当前部件i从供应商j购买</span></span><br><span class="line"><span class="type">int</span> bestx[<span class="number">999</span>];<span class="comment">//最优方案部件i从哪个供应商买</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;=n)&#123;<span class="comment">//到达最后一层 </span></span><br><span class="line">		<span class="keyword">if</span>(cp&lt;=d&amp;&amp;cw&lt;bestw)&#123;<span class="comment">//如果价格没超过d，并且重量小于之前方案的bestw </span></span><br><span class="line">			bestw=cw;<span class="comment">//重量更新 </span></span><br><span class="line">			bestp=cp;<span class="comment">//价格更新</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">				bestx[k]=x[k];<span class="comment">//部件的供应商进行更新 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//所有的方式都尝试了一遍，比较找到最优的重量</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">			x[i]=j;<span class="comment">//当前部件i的供应商为j</span></span><br><span class="line">			cw=cw+w[i][j];</span><br><span class="line">			cp=cp+c[i][j];</span><br><span class="line">			<span class="keyword">if</span>(cw&lt;bestw&amp;&amp;cp&lt;=d)<span class="comment">//如果这次的选择要比之前方案的更优 </span></span><br><span class="line">			<span class="built_in">backtrack</span>(i+<span class="number">1</span>); </span><br><span class="line">		<span class="comment">//回溯</span></span><br><span class="line">			cw-=w[i][j];</span><br><span class="line">			cp-=c[i][j]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;<span class="comment">//n个部件，m个供应商，总价格不超过d</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;c[i][j];<span class="comment">//c[i][j]为从供应商j购买部件i所花费的价格；</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;w[i][j];<span class="comment">//w[i][j]为......重量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">backtrack</span>(<span class="number">0</span>);<span class="comment">//第i个部件</span></span><br><span class="line">	cout&lt;&lt;bestw&lt;&lt;endl;<span class="comment">//最优方案的重量</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">	cout&lt;&lt;bestx[k]+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//因为j从0开始，所以输出的时候加一个1；</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103200657123.png" alt="image-20230103200657123"></p>
<h3 id="5-时间复杂度分析-2"><a href="#5-时间复杂度分析-2" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>考虑最坏情况，对于每个非叶子节点，搜索所需时间为$O(m)$，对于每个叶子节点，搜索所需的时间为$O(1)$，故最坏情况下所需时间为$T=m*(m+m^2+…+m^{n-1})+m^n=O(m^n)$</p>
<h1 id="5-4-运动员最佳配对问题"><a href="#5-4-运动员最佳配对问题" class="headerlink" title="5-4 运动员最佳配对问题"></a>5-4 运动员最佳配对问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103211224034.png" alt="image-20230103211224034" style="zoom:67%;"></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10 2 3</span><br><span class="line">2 3 4</span><br><span class="line">3 4 5</span><br><span class="line">2 2 2</span><br><span class="line">3 5 3</span><br><span class="line">4 5 1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52</span><br></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-3"><a href="#1-解空间和解结构-3" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>将问题转换为男运动员选女运动员的问题，故n个男、女运动员的运动员最佳匹配问题的解空间为n个数的全排列，对应的解结构为排列树</p>
<h3 id="2-剪枝策略-3"><a href="#2-剪枝策略-3" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑对第i个男运动员匹配女运动员的情况，其中变量Max存储当前最优解的竞赛优势，变量sum存储第1~i-1个已经匹配完成的男运动员的竞赛优势，计算第i~n个男运动员的最大可能的竞赛优势ctn，若<code>cnt+sum&lt;Max</code>，则剪去该节点及其子树</p>
<p>其中第j个男运动员的最大可能的竞赛优势为该男运动员与所有女运动员进行匹配所得竞赛优势中最大者，存储到maxsum数组中</p>
<h3 id="3-示例-3"><a href="#3-示例-3" class="headerlink" title="3.示例"></a>3.示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214009258.png" alt="image-20230103214009258"></p>
<h3 id="4-代码-3"><a href="#4-代码-3" class="headerlink" title="4.代码"></a>4.代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> boy[<span class="number">21</span>][<span class="number">21</span>],girl[<span class="number">21</span>][<span class="number">21</span>];   <span class="comment">//分别用于存放男、女运动员的竞赛优势</span></span><br><span class="line"><span class="type">int</span> Max=INT_MIN;   <span class="comment">//Max代表男女双方竞赛优势的总和的最大值</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;   <span class="comment">//sum为临时求和</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">21</span>][<span class="number">21</span>];   <span class="comment">//data[i][]用于存放男运动员 i 配对后的双方竞赛优势</span></span><br><span class="line"><span class="type">int</span> maxSum[<span class="number">21</span>];   <span class="comment">//记录每个男生匹配后可达到的最大双方竞赛优势</span></span><br><span class="line"><span class="type">int</span> book[<span class="number">21</span>];   <span class="comment">//用于标记女运动员是否已匹配：book[0]未匹配；book[1]匹配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=n)   <span class="comment">//t到达n之后，代表全部标记访问了,得到了最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        Max=<span class="built_in">max</span>(Max,sum);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ctn=<span class="number">0</span>;   </span><br><span class="line"><span class="comment">//剪枝函数:之前t个已匹配好的男女运动员的sum与之后的 t-&gt;n-1 个男匹配女的最大值加起来与已经得到的Max比较，若前者&lt;=Max，剪枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;n;i++)   <span class="comment">//求t及t之后男生匹配女生的最大值的和</span></span><br><span class="line">        ctn+=maxSum[i];</span><br><span class="line"><span class="comment">//若从第t组-&gt;第n组，当前搜索sum加上假设匹配后的最大值cxn，仍然小于Max ，就需要剪枝了，则Max为已经求得的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(sum+ctn&lt;Max)   </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//若cxn&gt;=Max，要探索子树。从第t个男生开始匹配，找未匹配的女生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i])   <span class="comment">//第 i 个女生未匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            book[i]=<span class="number">1</span>;   <span class="comment">//第 t 个男生匹配女生i</span></span><br><span class="line">            sum+=data[t][i];   <span class="comment">//加上男生t与女生i的男女双方竞赛优势</span></span><br><span class="line">            <span class="built_in">dfs</span>(t+<span class="number">1</span>);   <span class="comment">//为第i+1个男生匹配</span></span><br><span class="line">            book[i]=<span class="number">0</span>;   <span class="comment">//若第 t 个男生匹配女生i得到的sum不大于Max，则回溯</span></span><br><span class="line">            sum-=data[t][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//输入男运动员的竞赛优势</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            cin&gt;&gt;boy[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//输入女运动员的竞赛优势</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            cin&gt;&gt;girl[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//对每个男生都求男女双方竞赛优势，则能得到i*j种结果（涵盖了P[i][j]*Q[j][i]与Q[i][j]*P[j][i]）</span></span><br><span class="line">            data[i][j]=boy[i][j]*girl[j][i];   </span><br><span class="line">            maxSum[i]=<span class="built_in">max</span>(maxSum[i],data[i][j]);   <span class="comment">//记录每个男生匹配后可达到的最大双方竞赛优势，用于后面的剪枝</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;Max&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104104042126.png" alt="image-20230104104042126"></p>
<h3 id="5-时间复杂度分析-3"><a href="#5-时间复杂度分析-3" class="headerlink" title="5.时间复杂度分析"></a>5.时间复杂度分析</h3><p>考虑最坏情况，每个节点都需要搜索，对于非叶子节点，其需要时间为$O(n)$，对于叶子节点，其所需时间为$O(1)$，故所需时间为$T=n<em>(n+n</em>(n-1)+…+n!)+n!=O(n*n!)$</p>
<h1 id="5-5-无分隔符字典问题"><a href="#5-5-无分隔符字典问题" class="headerlink" title="5-5 无分隔符字典问题"></a>5-5 无分隔符字典问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214343137.png" alt="image-20230103214343137" style="zoom:67%;"></p>
<h3 id="1-解空间和解结构-4"><a href="#1-解空间和解结构-4" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>由S为$L_k$子集可知n个符号，长度为k的无分隔符字典问题的解空间为长度为$n^k$的向量，其中向量每一项为0或1，表示$L_k$中某一项是否在S中，解结构为子集树</p>
<h3 id="2-剪枝策略-4"><a href="#2-剪枝策略-4" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>首先将$L_k$中所有字字符串放入数组L中，考虑是否放入下标为i的字符串：</p>
<p>约束函数：若该字符串与当前S集合中的任意字符串按照题目所给方式进行拼接，结果均不在S集合中，且不为该字符串本身，则考虑将其放入，搜索其左子树，否则剪去该节点的左子树</p>
<p>限界函数：考虑不放入该字符串，若将i+1~$n^k$的字符串均放入，若n^k^-i+S.size&lt;best，则无需搜索其右子树，剪去该节点的右子树</p>
<h3 id="3-示例-4"><a href="#3-示例-4" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>假设$\sum=(a,b),L_k=\{aa,ab,ba,bb\}$,则$L_k$的一个最大无分隔符字典为$\{aa,bb\}$</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104102358652.png" alt="image-20230104102358652"></p>
<h3 id="4-代码-4"><a href="#4-代码-4" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ak;</span><br><span class="line"><span class="type">int</span> lk;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> best = <span class="number">0</span>; <span class="comment">//最大无分隔符字典元素个数</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; L;  <span class="comment">//将所有的长度为k的数字字符串存到集合L中</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; S;  <span class="comment">//当前字典中的字符串存储在集合s中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标为L[]中下标为i的字符串存入集合s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.<span class="built_in">insert</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标为L[]中下标为i的字符串存入集合s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.<span class="built_in">erase</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将ak[]中起点为i，长度为k数字串转换为十进制数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">digi</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        x *= <span class="number">10</span>;</span><br><span class="line">        x += ak[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串a和第b个字符串是否互不为前缀</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pref</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bb =b;<span class="comment">//这里用bb只是因为原代码不太对,我直接改了</span></span><br><span class="line">    <span class="type">int</span> x = a;</span><br><span class="line">    <span class="type">int</span> y = bb/<span class="number">10</span>;<span class="comment">//去掉最后一位，得到高k-1位(因为验证的时候这位是肯定要剔除的</span></span><br><span class="line">    <span class="comment">//按理说x也要剔除最高位，但是后面的循环不会碰到最高位，所以这里没剔除了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>; i++) <span class="comment">//ak[0, k-2]存放x的低k-1位，ak[k-1, k-1 + (k-2)]存放y</span></span><br><span class="line">    &#123;</span><br><span class="line">        ak[k-i<span class="number">-2</span>] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        ak[<span class="number">2</span>*k-i<span class="number">-3</span>] = y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>; i++) <span class="comment">//相当于依次判断a2a3..akb1, a3a4..b1b2, akb1..bk-1是否已存在于S中，本程序中下标从0开始</span></span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">count</span>(<span class="built_in">digi</span>(i)) &gt; <span class="number">0</span>||<span class="built_in">digi</span>(i)==bb)  <span class="comment">//如果已存在于S中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    x = bb;</span><br><span class="line">    y = a/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>; i++)<span class="comment">//先放b再放a</span></span><br><span class="line">    &#123;</span><br><span class="line">        ak[k-i<span class="number">-2</span>] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        ak[<span class="number">2</span>*k-i<span class="number">-3</span>] = y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">count</span>(<span class="built_in">digi</span>(i)) &gt; <span class="number">0</span>||<span class="built_in">digi</span>(i)==bb)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前下标为b的字符串是否可以加入字典</span></span><br><span class="line"><span class="comment">//将字符串a1a2..ak看作k位十进制数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">oka</span><span class="params">(<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bb = L[b];</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器</span></span><br><span class="line">    it = S.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != S.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = *it;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pref</span>(a, bb)) <span class="comment">//如果a,b其中一个是另一个的前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到总元素个数为n，长度为m的全排列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Perm</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> dep, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">            x = x*<span class="number">10</span> + list[i];   <span class="comment">//转换为十进制数字</span></span><br><span class="line">        L.<span class="built_in">push_back</span>(x);  <span class="comment">//将所有的数字字符串存到集合L中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(list[dep], list[j]);</span><br><span class="line">            <span class="built_in">Perm</span>(list, dep+<span class="number">1</span>, m,  n);</span><br><span class="line">            <span class="built_in">swap</span>(list[dep], list[j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep &gt;= lk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">size</span>() &gt; best)</span><br><span class="line">            best = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">oka</span>(dep))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(dep);</span><br><span class="line">        <span class="built_in">backtrack</span>(dep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">erase</span>(dep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lk-dep+S.<span class="built_in">size</span>()&gt;best)</span><br><span class="line">    <span class="built_in">backtrack</span>(dep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入正整数n：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; n; cout &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入正整数k：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; k; cout &lt;&lt; k;</span><br><span class="line">    ak = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*k];</span><br><span class="line">    lk = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;k; i++) <span class="comment">//k个字符中，每一个字符都有n种选择，n^k表示所有由k个字符组成的字符串种数</span></span><br><span class="line">        lk *= n;</span><br><span class="line">    lk--;</span><br><span class="line">    <span class="type">int</span> *x = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        x[i] = i;</span><br><span class="line">    <span class="built_in">Perm</span>(x, <span class="number">1</span>, k, n); <span class="comment">//将长度为k的全排列存入集合L中</span></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n最大无分隔符字典元素个数为：&quot;</span> &lt;&lt; best;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103946623.png" alt="image-20230104103946623"></p>
<h3 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于n个字符，长度为k的问题，对于每个非叶子节点的左子节点，搜索需要耗费时间为$O(n^k<em>k)$，对于右子节点搜索需要的时间为$O(1)$，对于叶节点需要时间$O(1)$，故耗费的时间$T=O(2^{n^k-1}</em>n^k*k)$</p>
<h1 id="5-6-无合集问题"><a href="#5-6-无合集问题" class="headerlink" title="5-6 无合集问题"></a>5-6 无合集问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103710037.png" alt="image-20230104103710037" style="zoom:67%;"></p>
<p>大概的思路是从1开始每个数都尝试放入n个子集的每个子集，然后用题目给的条件x+y不属于S进行剪枝</p>
<h3 id="1-解空间和解结构-5"><a href="#1-解空间和解结构-5" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>从1开始尝试放入每个子集中，对于子集为n的无合集问题，其解空间为长度为k的向量，向量的每一项为1~n，表示对应下标的数分配到的子集，其中k为本题所求，以n=3为例，解结构如下：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104111844462.png" alt="image-20230104111844462" style="zoom:50%;"></p>
<h3 id="2-剪枝策略-5"><a href="#2-剪枝策略-5" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>据题意，若数i无法分配到集合j(不满足和不在集合的条件)，则该节点的第j个分支无需遍历，剪去该分支</p>
<h3 id="3-示例-5"><a href="#3-示例-5" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104112758039.png" alt="image-20230104112758039" style="zoom:67%;"></p>
<h3 id="4-代码-5"><a href="#4-代码-5" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>定义存储当前解的数组a[N][N],其中a[n][0]表示第n个子集的元素个数a[n][1]到a[n][a[n][0]]为这个子集的所有元素。定义n。设置初始的结果ans为1(最后要减1，所以初始值其实是0)，定义最优值为best，定义最优解为e[N][N]，其中的结构和a[N][N]一样,以及定义判定数组h[N][N]，h[i][j]表示第i个子集中是否有j这个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], n, ans = <span class="number">1</span>, best, e[N][N];</span><br><span class="line"><span class="type">bool</span> h[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;                        <span class="comment">//判断当前ans中的数是否能插入第level个子集</span></span><br><span class="line">    <span class="keyword">if</span>(level == n)&#123;                         <span class="comment">//n个子集的下标是0到n-1,所以当level等于n时表示当前ans不能插入所有子集</span></span><br><span class="line">        <span class="keyword">if</span>(ans &lt;= best) <span class="keyword">return</span>;             <span class="comment">//如果当前ans不如当前最优值best，就返回</span></span><br><span class="line">        best = ans;                         <span class="comment">//如果比最优值好，更新最优值和最优解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= a[i][<span class="number">0</span>]; j ++)</span><br><span class="line">                e[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                                   <span class="comment">//判断ans能否插入第level个子集</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;           </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[level][<span class="number">0</span>]; i ++)&#123;<span class="comment">//遍历子集</span></span><br><span class="line">            <span class="comment">//如果ans减当前元素在子集中且这个元素不是它本身,flag就为false,表示ans不能插入这个子集</span></span><br><span class="line">            <span class="keyword">if</span>(h[level][ans - a[level][i]] &amp;&amp; ans - a[level][i] != a[level][i]) flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">dfs</span>(level + <span class="number">1</span>);           <span class="comment">//不能插入，判断ans能不能插入第level+1个子集  </span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               <span class="comment">//可以插入，分两种情况，一种是插入，一种是不插入此子集</span></span><br><span class="line">            <span class="comment">//插入的情况</span></span><br><span class="line">            a[level][++ a[level][<span class="number">0</span>]] = ans; <span class="comment">//第i个子集个数加一，把元素记入子集</span></span><br><span class="line">            h[level][ans ++] = <span class="literal">true</span>;        <span class="comment">//把此元素标记为在此子集中</span></span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>);                         <span class="comment">//判断下一个数是否能插入第0个子集</span></span><br><span class="line">            <span class="comment">//回溯到不插入的情况，把子集个数减1，再把当前元素标记为不在此子集中</span></span><br><span class="line">            -- a[level][<span class="number">0</span>];                 </span><br><span class="line">            h[level][-- ans] = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(level + <span class="number">1</span>);                 <span class="comment">//判断这个数是否能插入下一个子集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; --best &lt;&lt; endl;                 <span class="comment">//记录的是最优值加一，这里减去一并输出</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= e[i][<span class="number">0</span>]; j ++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i][j]);     <span class="comment">//输出最优解</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.acwing.com/blog/content/4777/">无和集问题 - AcWing</a></p>
<h3 id="5-时间复杂度-1"><a href="#5-时间复杂度-1" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，假设其位于第i层，则时间消耗为$O(i)$，对于非叶子节点，其时间消耗为$O(1)$,本题时间消耗还与树的层数有关，而层数又是要求的。。。，需要一些推导来得到一个上界吧~</p>
<h1 id="5-7-n色方柱问题"><a href="#5-7-n色方柱问题" class="headerlink" title="5-7 n色方柱问题"></a>5-7 n色方柱问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113608782.png" alt="image-20230104113608782" style="zoom:67%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113717884.png" alt="image-20230104113717884" style="zoom:67%;"></p>
<p>为了提高效率，用图论的知识简化了题目（我没怎么看懂为啥这样简化的），谢谢有被恶心到</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094031142.png" alt="image-20230108094031142"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094127364.png" alt="image-20230108094127364"></p>
<p>有点难懂，我觉得不会考。。。，理解一下代码吧</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>input.txt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">RGBY</span><br><span class="line">0 2 1 3 0 0</span><br><span class="line">3 0 2 1 0 1</span><br><span class="line">2 1 0 2 1 3</span><br><span class="line">1 3 3 0 2 2</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> board[MAX][<span class="number">6</span>];  <span class="comment">//存储n个立方体各面的颜色</span></span><br><span class="line"><span class="type">int</span> solu[MAX][<span class="number">6</span>];   <span class="comment">//存储解</span></span><br><span class="line"><span class="type">int</span> n;  <span class="comment">//立方体个数、颜色种数</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;  <span class="comment">//解的个数</span></span><br><span class="line"><span class="type">int</span> used[MAX];</span><br><span class="line"><span class="type">char</span> color[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到一个解后，输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> edge[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, a, b, c, d;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) <span class="comment">//2个子图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            used[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            d = c = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; used[j]&gt;<span class="number">0</span>) <span class="comment">//找下一条未用的边</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; n)</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    a = board[j][edge[i*n+j]*<span class="number">2</span>];</span><br><span class="line">                    b = board[j][edge[i*n+j]*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(b == d)  <span class="comment">//如果上一条边的终点与b相同，说明b为始点，交换，保证a为始点</span></span><br><span class="line">                        <span class="built_in">swap</span>(a, b);  <span class="comment">//保证有向边的始点对应于前面和左面，终点对应于背面和右面</span></span><br><span class="line">                    solu[j][i*<span class="number">2</span>] = a;</span><br><span class="line">                    solu[j][i*<span class="number">2</span>+<span class="number">1</span>] = b;</span><br><span class="line">                    used[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c&lt;<span class="number">0</span>)  <span class="comment">//开始顶点</span></span><br><span class="line">                        c = a;</span><br><span class="line">                    d = b;</span><br><span class="line">                    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;n; k++)  <span class="comment">//找下一个立方体</span></span><br><span class="line">                        <span class="keyword">if</span>(used[k]==<span class="number">0</span> &amp;&amp; (board[k][edge[i*n+k]*<span class="number">2</span>]==b || board[k][edge[i*n+k]*<span class="number">2</span>+<span class="number">1</span>]==b))</span><br><span class="line">                            j = k;</span><br><span class="line">                &#125;<span class="keyword">while</span>(b != c);  <span class="comment">//找了一圈，回到起点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(j&lt;n);  <span class="comment">//所有立方体都找遍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++) <span class="comment">//立方体的顶面和底面的颜色</span></span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="number">3</span> - edge[j] - edge[j+n];</span><br><span class="line">        a = board[j][k*<span class="number">2</span>];</span><br><span class="line">        b = board[j][k*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        solu[j][<span class="number">4</span>] = a;</span><br><span class="line">        solu[j][<span class="number">5</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">            cout &lt;&lt; color[solu[i][j]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, t, cube;</span><br><span class="line">    <span class="type">bool</span> ok, newg, over;</span><br><span class="line">    <span class="type">int</span> *vert = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">//记录子图中每个顶点的度，应均为2</span></span><br><span class="line">    <span class="type">int</span> *edge = <span class="keyword">new</span> <span class="type">int</span>[n*<span class="number">2</span>];  <span class="comment">//记录每个立方体中边被选用的条数，每个立方体只有3条边，有两个子图要选用</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        vert[i] = <span class="number">0</span>;</span><br><span class="line">    t = <span class="number">-1</span>;</span><br><span class="line">    newg = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(t &gt; <span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        cube = t % n;  <span class="comment">//每个立方体找2次，得到真实的立方体编号，也是子图中边的编号</span></span><br><span class="line">        <span class="keyword">if</span>(newg)  <span class="comment">//如果没有边被选入子图</span></span><br><span class="line">            edge[t] = <span class="number">-1</span>;</span><br><span class="line">        over = <span class="literal">false</span>;  <span class="comment">//是否结束，即两个子图构建完成</span></span><br><span class="line">        ok = <span class="literal">false</span>;    <span class="comment">//标记边是否已用过，两个子图不应有公共边</span></span><br><span class="line">        <span class="keyword">while</span>(!ok &amp;&amp; !over)</span><br><span class="line">        &#123;</span><br><span class="line">            edge[t]++;  <span class="comment">//边被选用加入子图，使用次数增加</span></span><br><span class="line">            <span class="keyword">if</span>(edge[t]&gt;<span class="number">2</span>)  <span class="comment">//在立方体每对相对面的顶点连一条边，每个立方体只有3条边</span></span><br><span class="line">                over = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ok = (t&lt;n || edge[t]!=edge[cube]);  <span class="comment">//是否已用过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!over)</span><br><span class="line">        &#123;          <span class="comment">//检测边的两个顶点的度</span></span><br><span class="line">            <span class="keyword">if</span>(++vert[board[cube][edge[t]*<span class="number">2</span>]] &gt; <span class="number">2</span>+t/<span class="number">2</span>*<span class="number">2</span>) <span class="comment">//如果是第一个子图，顶点度不能超过2</span></span><br><span class="line">                ok = <span class="literal">false</span>;              <span class="comment">//如果是第二个子图，加上第一个子图，顶点度不能超过4</span></span><br><span class="line">            <span class="keyword">if</span>(++vert[board[cube][edge[t]*<span class="number">2</span>+<span class="number">1</span>]] &gt; <span class="number">2</span>+t/<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t%n == n<span class="number">-1</span> &amp;&amp; ok)  <span class="comment">//如果一个或两个子图已构建完成</span></span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                    <span class="keyword">if</span>(vert[i] &gt; <span class="number">2</span>+t/n*<span class="number">2</span>)</span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t == n*<span class="number">2</span><span class="number">-1</span>) <span class="comment">//找到解</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="built_in">out</span>(edge);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    newg = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//取下一条边</span></span><br><span class="line">            &#123;</span><br><span class="line">                --vert[board[cube][edge[t]*<span class="number">2</span>]];  <span class="comment">//边的两个顶点</span></span><br><span class="line">                --vert[board[cube][edge[t]*<span class="number">2</span>+<span class="number">1</span>]];</span><br><span class="line">                t--;</span><br><span class="line">                newg = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//回溯</span></span><br><span class="line">        &#123;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cube = t % n;</span><br><span class="line">                --vert[board[cube][edge[t]*<span class="number">2</span>]];</span><br><span class="line">                --vert[board[cube][edge[t]*<span class="number">2</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            t--;</span><br><span class="line">            newg = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入立方体个数：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; n;  cout &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入颜色：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fin &gt;&gt; color[i];</span><br><span class="line">        cout &lt;&lt; color[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入立方体各面颜色：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            fin &gt;&gt; board[i][j];</span><br><span class="line">            cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n立方体叠置方案为：\n&quot;</span>;</span><br><span class="line">    <span class="built_in">search</span>();</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution！\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; end;</span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104115831309.png" alt="image-20230104115831309"></p>
<h1 id="5-8-整数变换问题"><a href="#5-8-整数变换问题" class="headerlink" title="5-8 整数变换问题"></a>5-8 整数变换问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105102915399.png" alt="image-20230105102915399" style="zoom:67%;"></p>
<p>这道题是一定能找到的，有点类似于3n+1?，要不然会要求输出<code>no solution</code>的，而且我们也不能简单地通过n和m的大小关系来得到此时需要做的操作。题目的思路大概就是DFS暴力搜索，左子树f变换，右子树g变换，主要问题在于需要限制搜索的层数，因为有些分支是得不到解的</p>
<h3 id="1-解空间和解结构-6"><a href="#1-解空间和解结构-6" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>解空间是一个长度为k的向量，向量的每一项是f或者g，k的大小与输入有关，解结构如下：左子树是进行f变换，右子树是进行g变换。</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105111327567.png" alt="image-20230105111327567" style="zoom:67%;"></p>
<h3 id="2-剪枝策略-6"><a href="#2-剪枝策略-6" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>虽然看到一些博客根据n和m的大小剪枝，但是实际上在代码中他们没有这样做，而且这种做法应该是不对的。。。</p>
<p>我觉得这里更加类似于DFS，代码也没体现出什么剪枝的策略，这里的搜索过程有点像是一层一层往下搜索，k控制着层数</p>
<h3 id="3-示例-6"><a href="#3-示例-6" class="headerlink" title="3. 示例"></a>3. 示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">gfg</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113429567.png" alt="image-20230105113429567" style="zoom:50%;"></p>
<h3 id="4-代码-6"><a href="#4-代码-6" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">//定义k来表示搜索树的深度</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//定义一个队列来存放各类操作</span></span><br><span class="line">queue&lt;<span class="type">char</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//防止死循环，保证最多只能访问到下一层</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//找到返回true</span></span><br><span class="line">    <span class="keyword">if</span>(n == m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里必须用一个temp做临时变量</span></span><br><span class="line">    <span class="comment">//若不用temp做临时变量，回溯的时候n的值发生变化</span></span><br><span class="line">    <span class="comment">//导致结果异常</span></span><br><span class="line">    <span class="type">int</span> temp = n;</span><br><span class="line">    <span class="comment">//左右都做一遍，看看能否到达目的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            temp = n * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x+<span class="number">1</span>, temp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">            <span class="comment">//这里必须要return true </span></span><br><span class="line">            <span class="comment">//因为只需要找到第一个满足条件的那条路径</span></span><br><span class="line">            <span class="comment">//回溯返回的时候把路径上的运算加入队列即可。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没找到返回false,k++</span></span><br><span class="line">    <span class="comment">//可往更深一层探索</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//找不到，往更深一层探索！</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">DFS</span>(<span class="number">0</span>, n))</span><br><span class="line">        k++;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-2"><a href="#5-时间复杂度-2" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>树的层数和输入的数关系比较大，不太好分析。。。，如果树的层数可以得到一个上界的话，可以推导一下最坏情况</p>
<p>参考：<a href="https://blog.csdn.net/Small___ming/article/details/103218990">https://blog.csdn.net/Small___ming/article/details/103218990</a></p>
<h1 id="5-9-拉丁矩阵问题"><a href="#5-9-拉丁矩阵问题" class="headerlink" title="5-9 拉丁矩阵问题"></a>5-9 拉丁矩阵问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113714306.png" alt="image-20230105113714306" style="zoom:67%;"></p>
<p>可以从左到右从上到下来填充矩阵的每个“格子”，即树的每一层就是考虑每个格子里放什么，这将得到一棵比较大的树，剪枝的策略就是题目所要求的，每行每列都没有相同的形状，若在该格子里放入第i种宝石能满足要求，则将其放入，否则剪去该条分支，对于检查每行每列是否有相同形状，可以采用两个矩阵来记录，这样时间效率会高点</p>
<h3 id="1-解空间和解结构-7"><a href="#1-解空间和解结构-7" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>本题是求可行解的个数，解空间是一个n行m列的矩阵，也可以理解为n*m长度的向量，其中向量的每个元素为1~n，对应的解结构为排列树</p>
<h3 id="2-剪枝策略-7"><a href="#2-剪枝策略-7" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护矩阵row[N][N]，其中row[i][j]=1表示第i行已经使用了形状j，矩阵col[N][N]，其中col[j][i]=1表示第i列使用了形状j，考虑在为矩阵(x,y)位置上元素选择宝石时，若选择宝石i，则需要保证<code>row[x][i]==0&amp;&amp;col[i][y]==0</code>，即不与x行和y列上已有的形状冲突，若不满足该条件，则可剪去该子树</p>
<h3 id="3-示例-7"><a href="#3-示例-7" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194002403.png" alt="image-20230105194002403"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194603562.png" alt="image-20230105194603562" style="zoom:67%;"></p>
<h3 id="4-代码-7"><a href="#4-代码-7" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> m,n;    <span class="comment">//分别为行、列</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> row[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//row[i][j]=1表示第i行已经使用了形状j</span></span><br><span class="line"><span class="type">int</span> col[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//col[j][i]=1表示第i列已经使用了形状j</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span></span><br><span class="line"><span class="function"><span class="comment">//如第一行就是0 1 2 3 4...</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> x,y;    <span class="comment">//分别为行、列（坐标）</span></span><br><span class="line">    <span class="keyword">if</span>(t==m*n)<span class="comment">//如果排完了,说明得到了一种可行解</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续排列</span></span><br><span class="line">    x=t/n;      <span class="comment">//行坐标</span></span><br><span class="line">    y=t%n;      <span class="comment">//列坐标</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//对每种形状都进行尝试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(row[x][i]==<span class="number">0</span>&amp;&amp;col[i][y]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           row[x][i]=<span class="number">1</span>;</span><br><span class="line">           col[i][y]=<span class="number">1</span>;</span><br><span class="line">           a[x][y]=i;</span><br><span class="line">           <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">           row[x][i]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">           col[i][y]=<span class="number">0</span>;</span><br><span class="line">           a[x][y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count=%d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-3"><a href="#5-时间复杂度-3" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于叶子节点，其时间消耗为$O(1)$，对于非叶子节点其时间消耗为$O(n)$，对于n种宝石，排成n行m列的拉丁矩阵问题，时间消耗为$T=O(n^{mn})$</p>
<h1 id="5-10-排列宝石问题"><a href="#5-10-排列宝石问题" class="headerlink" title="5-10 排列宝石问题"></a>5-10 排列宝石问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114234838.png" alt="image-20230105114234838" style="zoom:67%;"></p>
<p>这道题是类似于5-9的(直接在5-9上面改的几行)，说一下思路吧：类似于对待不同宝石类型要求每行每列都不重复，引入数组<code>color_row</code>和数组<code>color_col</code>，其大致结构和含义与<code>row</code>和<code>col</code>类似，用于记录该行或者该列是否已经使用过该种颜色的宝石，还引入<code>used</code>数组用于满足题中的每种宝石n颗且不同色（避免一种宝石的一种颜色使用了多次），其中<code>used[i][j]=1</code>表示类型i的宝石的第j种颜色已用。</p>
<p>与5-9对比，排列树可选的分支大大增加了，不过剪去的分支也比较多，时间复杂度往上蹭</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;    <span class="comment">//分别为行、列</span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> row[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//row[i][j]=1表示第i行已经使用了形状j</span></span><br><span class="line"><span class="type">int</span> col[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//col[j][i]=1表示第i列已经使用了形状j</span></span><br><span class="line"><span class="type">int</span> color_row[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> color_col[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> used[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//used[i][j]=1表示类型i的第j种颜色已用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span></span><br><span class="line"><span class="function"><span class="comment">//如第一行就是0 1 2 3 4...</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> x,y;    <span class="comment">//分别为行、列（坐标）</span></span><br><span class="line">    <span class="keyword">if</span>(t==n*n)<span class="comment">//如果排完了,说明得到了一种可行解</span></span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续排列</span></span><br><span class="line">    x=t/n;      <span class="comment">//行坐标</span></span><br><span class="line">    y=t%n;      <span class="comment">//列坐标</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//对每种形状都进行尝试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//j为颜色</span></span><br><span class="line">        <span class="keyword">if</span>(!row[x][i]&amp;&amp;!col[i][y]&amp;&amp;!color_row[x][j]&amp;&amp;!color_col[j][y]&amp;&amp;!used[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">           row[x][i]=<span class="number">1</span>;</span><br><span class="line">           col[i][y]=<span class="number">1</span>;</span><br><span class="line">           color_row[x][j]=<span class="number">1</span>;</span><br><span class="line">           color_col[j][y]=<span class="number">1</span>;</span><br><span class="line">           used[i][j]=<span class="number">1</span>;</span><br><span class="line">           <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">           row[x][i]=<span class="number">0</span>;</span><br><span class="line">           col[i][y]=<span class="number">0</span>;</span><br><span class="line">           color_row[x][j]=<span class="number">0</span>;</span><br><span class="line">           color_col[j][y]=<span class="number">0</span>;</span><br><span class="line">           used[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res=%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-11-重复拉丁矩阵问题"><a href="#5-11-重复拉丁矩阵问题" class="headerlink" title="5-11 重复拉丁矩阵问题"></a>5-11 重复拉丁矩阵问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114335314.png" alt="image-20230105114335314" style="zoom: 80%;"></p>
<p>这题是类似于5-9的，我的代码一直没AC，参考了下答案的，思路是：第一行按照题意，由于对每行每种宝石数量的限制，且要求第一行最小字典序，所以是固定的，无需回溯，故从第二行开始进行搜索。答案遵照教材的排列树的写法，先初始化矩阵，然后再做swap操作，矩阵初始化情况如虚线上矩阵(示例为例)，在搜索的时候，只需要考虑每列宝石要求即可（因为初始化的原因，不需要考虑每行了），但是很奇怪的是，代码没有考虑第一列的情况了，即认为第一列也是固定的，但是我觉得不太对，比如虚线下面的一种也是可以的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">省略第0行、第0列</span><br><span class="line">1 1 2 2 3 3 3</span><br><span class="line">1 &lt;1&gt; 2 2 3 3 3</span><br><span class="line">2 1 1 2 3 3 3</span><br><span class="line">2 1 2 1 3 3 3</span><br><span class="line">-------------</span><br><span class="line">1 1 2 2 3 3 3 </span><br><span class="line">3 3 3 2 2 1 1 </span><br><span class="line">3 3 3 1 2 2 1 </span><br><span class="line">3 3 2 1 3 1 2 </span><br></pre></td></tr></table></figure>
<p>input:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 7 3</span><br><span class="line">2 2 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> times[MAX];  <span class="comment">//每种宝石的重复次数</span></span><br><span class="line"><span class="type">int</span> id[MAX];  <span class="comment">//每个宝石的价值序号</span></span><br><span class="line"><span class="type">int</span> board[MAX][MAX];  <span class="comment">//宝石矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//考察当前列宝石数是否多于应出现的次数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = board[r][s];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; c)</span><br><span class="line">        <span class="keyword">for</span>(i=c; i&lt;s; i++)</span><br><span class="line">            <span class="keyword">if</span>(board[r][i] == k) <span class="comment">//如果已经试过相同类型的宝石，这次就不再试了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;r; i++)  <span class="comment">//考察当前列宝石数是否多于应出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][c] == k)</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= times[k]) <span class="comment">//times[k]表示种类为k的宝石应出现的次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> num = <span class="number">0</span>;  <span class="comment">//不同的宝石排列方案数</span></span><br><span class="line"><span class="comment">//从上到下，从左到右递归搜索，即先行后列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=c; i&lt;=n; i++)  <span class="comment">//列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ok</span>(r, c, i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(board[r][c], board[r][i]);</span><br><span class="line">            <span class="keyword">if</span>(c == n)  <span class="comment">//如果列考察完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(r == m) <span class="comment">//如果行考察完毕</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">backtrack</span>(r+<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//考察下一行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">backtrack</span>(r, c+<span class="number">1</span>); <span class="comment">//考察下一列</span></span><br><span class="line">            <span class="built_in">swap</span>(board[r][c], board[r][i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入行数m：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; m;  cout &lt;&lt; m;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入列数n：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; n;  cout &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n输入宝石价值种数：&quot;</span>;</span><br><span class="line">    fin &gt;&gt; k;  cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;种宝石在每行每列出现的最多次数：&quot;</span>;</span><br><span class="line">        fin &gt;&gt; times[i];</span><br><span class="line">        cout &lt;&lt; times[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        temp = times[i];</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            id[t++] = i;</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++)  <span class="comment">//初始化为单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            board[i][j] = id[j];</span><br><span class="line">    <span class="comment">//第一行已经排列好了,无需再改变了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    由于初始化后的单位矩阵的第一列都是1，为使矩阵的第一列同时满足一下两个条件： </span></span><br><span class="line"><span class="comment">    同一种宝石数都不超过规定的数量，第1列从上到下的宝石按宝石的价值最小字典序从小到大排列 </span></span><br><span class="line"><span class="comment">    将第i行的第一个宝石与它同行的第i个宝石交换位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">swap</span>(board[i][<span class="number">1</span>],board[i][i]);</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n不同的宝石排列方案数为：&quot;</span> &lt;&lt; num;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是我的代码，在5-9基础上改的，输出的文件out.txt是所有的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n,k;    <span class="comment">//分别为行、列</span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> row[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//row[i][j]=1表示第i行已经使用了形状j</span></span><br><span class="line"><span class="type">int</span> col[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//col[j][i]=1表示第i列已经使用了形状j</span></span><br><span class="line"><span class="type">int</span> maxtime[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t,ofstream&amp;out)</span></span></span><br><span class="line"><span class="function"><span class="comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span></span><br><span class="line"><span class="function"><span class="comment">//如第一行就是0 1 2 3 4...</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;    <span class="comment">//分别为行、列（坐标）</span></span><br><span class="line">    <span class="keyword">if</span>(t==m*n)<span class="comment">//如果排完了,说明得到了一种可行解</span></span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                out&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            out&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        out&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续排列</span></span><br><span class="line">    x=t/n;      <span class="comment">//行坐标</span></span><br><span class="line">    y=t%n;      <span class="comment">//列坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//对每种形状都进行尝试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;i&lt;a[x][y<span class="number">-1</span>]) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>&amp;&amp;x&gt;<span class="number">0</span>&amp;&amp;i&lt;a[x<span class="number">-1</span>][y]) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;row[x][i]&lt;maxtime[i]&amp;&amp;col[i][y]&lt;maxtime[i])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//cout&lt;&lt;maxtime[i]&lt;&lt;&quot;: &quot;&lt;&lt;row[x][i]&lt;&lt;&quot;,&quot;&lt;&lt;col[i][y]&lt;&lt;&quot;| &quot;&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">           row[x][i]++;</span><br><span class="line">           col[i][y]++;</span><br><span class="line">           a[x][y]=i;</span><br><span class="line">           <span class="built_in">backtrack</span>(t+<span class="number">1</span>,out);</span><br><span class="line">           row[x][i]--;<span class="comment">//回溯</span></span><br><span class="line">           col[i][y]--;</span><br><span class="line">           a[x][y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofstream out;</span><br><span class="line">    out.<span class="built_in">open</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;maxtime[i]);</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>,out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res=%d\n&quot;</span>,res);</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-12-罗密欧与朱丽叶的迷宫问题"><a href="#5-12-罗密欧与朱丽叶的迷宫问题" class="headerlink" title="5-12 罗密欧与朱丽叶的迷宫问题"></a>5-12 罗密欧与朱丽叶的迷宫问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115004711.png" alt="image-20230105115004711"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114937912.png" alt="image-20230105114937912" style="zoom:67%;"></p>
<p>从罗密欧的位置开始，每次都可以走八个方向，用数字记录方向，若下一次走的方向与直接的不同则记转向次数加一，在考虑进入八个方向的下一位置前，需要考虑该位置是否越界，是否是封闭位置，是否已经走过，且是否走入后当前转向次数大于当前最优解此时，以此作为剪枝策略，当遍历完所有的位置后，若到达了朱丽叶的位置，则考虑更新当前最优解或者是增加最优解的次数</p>
<h3 id="1-解空间和解结构-8"><a href="#1-解空间和解结构-8" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n行m列，封闭房间数为k的迷宫，迷宫问题的解空间为1~n*m-k的全排列，表示某个房间第几次到达，解结构为排列树</p>
<h3 id="2-剪枝策略-8"><a href="#2-剪枝策略-8" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>约束函数：在尝试走入下一位置前，检查该位置是否合法，即是否数组越界，是否为封闭房间，是否已经走过，若不合法，则剪去该子树</p>
<p>限界函数：维护变量curr_rotation表示当前转向次数，min_rotation表示当前最优解的转向次数，若在考虑下一位置时，到达该位置后的转向次数大于最优解的转向次数，则剪去该子树</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><p>input:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point luo;</span><br><span class="line">Point ye;</span><br><span class="line">Point pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	定义八个方向:右,</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;; <span class="comment">//八个方向</span></span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> board[MAX][MAX];</span><br><span class="line"><span class="type">int</span> best[MAX][MAX];</span><br><span class="line"><span class="type">int</span> curr_rotation = <span class="number">0</span>;  <span class="comment">//转弯次数</span></span><br><span class="line"><span class="type">int</span> min_rotation = <span class="number">100000</span>;   <span class="comment">//最少转弯次数</span></span><br><span class="line"><span class="type">int</span> min_count = <span class="number">0</span>;  <span class="comment">//不同的最少转弯道路数</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point_check</span><span class="params">(Point pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos.x &gt; <span class="number">0</span> &amp;&amp; pos.x &lt;= n &amp;&amp; pos.y &gt; <span class="number">0</span> &amp;&amp; pos.y &lt;= m &amp;&amp; board[pos.x][pos.y] == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	更新当前最少转弯情况下的路线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			best[i][j] = board[i][j];</span><br><span class="line">	flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	回溯算法---&gt;形式参数表示的是traceBack的层数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">traceBack</span><span class="params">(<span class="type">int</span> depth, Point pos, <span class="type">int</span> di)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		回溯法的终止条件，</span></span><br><span class="line"><span class="comment">		当把所有的空房间都遍历一遍</span></span><br><span class="line"><span class="comment">		且当前到达的位置是朱丽叶的位置</span></span><br><span class="line"><span class="comment">		且当前转弯的次数少于等于历史的次数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (depth == m * n - k &amp;&amp; pos.x == ye.x &amp;&amp; pos.y == ye.y &amp;&amp; curr_rotation &lt;= min_rotation) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			如果当前的curr_count小于min_rotation更新min_rotation、min_count以及路径图</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (curr_rotation &lt; min_rotation) &#123;<span class="comment">//有更少的转向</span></span><br><span class="line">			min_rotation = curr_rotation;</span><br><span class="line">			min_count = <span class="number">1</span>;<span class="comment">//重新计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//	更新路径图</span></span><br><span class="line">			<span class="built_in">upgrade</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			min_count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//	剪枝策略-----当到达这个位置的时候curr_rotation已经大于min_rotation那么进行剪枝</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//	通过走的方向，计算下一个位置</span></span><br><span class="line">			Point next_pos;</span><br><span class="line">			next_pos.x = pos.x + dx[i];</span><br><span class="line">			next_pos.y = pos.y + dy[i];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//	每次走一步需要判断你下一个地点的位置是否合法</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Point_check</span>(next_pos)) &#123;</span><br><span class="line">				board[next_pos.x][next_pos.y] = depth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (depth &gt; <span class="number">1</span> &amp;&amp; di != i)</span><br><span class="line">					curr_rotation++;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (curr_rotation &lt;= min_rotation)</span><br><span class="line">					<span class="built_in">traceBack</span>(depth + <span class="number">1</span>, next_pos, i);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//	进行回溯</span></span><br><span class="line">				board[next_pos.x][next_pos.y] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (depth &gt; <span class="number">1</span> &amp;&amp; di != i)</span><br><span class="line">					curr_rotation--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	迷宫的初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(board, <span class="number">0</span>, <span class="built_in">sizeof</span>(board));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(best,<span class="number">0</span>,<span class="built_in">sizeof</span>(board));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//	文件的输入</span></span><br><span class="line">	<span class="function">ifstream <span class="title">datain</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入迷宫的宽度：&quot;</span>; datain &gt;&gt; n; cout &lt;&lt; n&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n输入迷宫的长度：&quot;</span>; datain &gt;&gt; m; cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n输入封闭房间个数：&quot;</span>; datain &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	封闭房间数据的输入</span></span><br><span class="line">	Point forbidden_rooms;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		datain &gt;&gt; forbidden_rooms.x &gt;&gt; forbidden_rooms.y;</span><br><span class="line">		board[forbidden_rooms.x][forbidden_rooms.y] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	输入罗密欧和朱丽叶的位置信息</span></span><br><span class="line">	datain &gt;&gt; luo.x &gt;&gt; luo.y;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;罗密欧位置坐标：[&quot;</span> &lt;&lt; luo.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; luo.y &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	board[luo.x][luo.y] = <span class="number">1</span>;<span class="comment">//起始位置</span></span><br><span class="line"></span><br><span class="line">	datain &gt;&gt; ye.x &gt;&gt; ye.y;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;朱丽叶位置坐标：[&quot;</span> &lt;&lt; ye.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ye.y &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	回溯算法开始</span></span><br><span class="line">	<span class="built_in">traceBack</span>(<span class="number">1</span>, luo, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//	把结果输出到txt文件中</span></span><br><span class="line">	<span class="function">ofstream <span class="title">dataout</span><span class="params">(<span class="string">&quot;output_data1.txt&quot;</span>, ios::trunc)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n最小转弯次数：&quot;</span> &lt;&lt; min_rotation &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n最小转弯次数的转弯道路数：&quot;</span> &lt;&lt; min_count &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;行走的路线图：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				cout &lt;&lt; best[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt; <span class="string">&quot;\nNo Solution!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-13-工作分配问题"><a href="#5-13-工作分配问题" class="headerlink" title="5-13 工作分配问题"></a>5-13 工作分配问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114617529.png" alt="image-20230105114617529" style="zoom:67%;"></p>
<p>由于每个工作仅由一人完成，每个人仅做一个工作，对于示例的输入矩阵，所求即为在每一行取一个数，且保证所取数不在同一列，求他们的和最小值，易知如果用暴力解法，设矩阵的行数为n，则解为n个数的排列组合，其中第i个数表示第i个工作分配给第j个人，则对于上述输入矩阵，可以得到可行解（3,2,1），（2,1,3），……</p>
<h3 id="1-解空间和解结构-9"><a href="#1-解空间和解结构-9" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个工作的工作分配问题，其解空间即为1~n的全排列，解结构为排列树，具体而言树的第i层表示第i个工作的分配，每层的顶点表示该工作分配的人，如红色方框框出的节点即表示第1个工作分配给C1</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091616647.png" alt="image-20230106091616647" style="zoom: 67%;"></p>
<h3 id="2-剪枝策略-9"><a href="#2-剪枝策略-9" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>在搜索的过程中记录当前费用cv和最优费用bestv,若cv大于等于bestv，则无需再遍历该节点的子树（因为向下搜索的过程费用一定是单调递增的）</p>
<h3 id="3-示例-8"><a href="#3-示例-8" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>分成两幅图来画了，实际上是一幅图</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091745691.png" alt="image-20230106091745691" style="zoom:50%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091753460.png" alt="image-20230106091753460" style="zoom:50%;"></p>
<h3 id="4-代码-8"><a href="#4-代码-8" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> Min=INT_MAX;</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> state[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//从第t层开始搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;=num) <span class="comment">//已经到达叶子节点，继续判断是否找到了最小总费用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Min&gt;sum)<span class="comment">//若当前费用小于最优费用</span></span><br><span class="line">        &#123;</span><br><span class="line">            Min=sum;<span class="comment">//更新最优费用</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//搜索过程:将作业t进行分配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!state[i])<span class="comment">//若第i个人当前无作业</span></span><br><span class="line">        &#123;</span><br><span class="line">            state[i]=<span class="number">1</span>;<span class="comment">//将任务t分配给第i个人</span></span><br><span class="line">            sum+=arr[t][i];<span class="comment">//更新当前费用</span></span><br><span class="line">            <span class="keyword">if</span>(sum&lt;Min) <span class="built_in">dfs</span>(t+<span class="number">1</span>);<span class="comment">//若当前费用小于最优费用,则继续向下搜索</span></span><br><span class="line">            state[i]=<span class="number">0</span>;<span class="comment">//回溯,恢复原状态</span></span><br><span class="line">            sum-=arr[t][i];<span class="comment">//将当前费用恢复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream in;</span><br><span class="line">    ofstream out;</span><br><span class="line">    in.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    out.<span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    in&gt;&gt;num;</span><br><span class="line">    Min=INT_MAX;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            in&gt;&gt;arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        state[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;最小费用为：&quot;</span>&lt;&lt;Min&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;最小费用为：&quot;</span>&lt;&lt;Min&lt;&lt;endl;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-4"><a href="#5-时间复杂度-4" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，其搜索所需时间为$O(n)$，对于叶子节点，其搜索所需时间为$O(1)$，故对于n个工作的工作分配问题，其时间消耗$T=n<em>(n+n</em>n-1+…+n!)+n!=O(n!*n)$</p>
<h1 id="5-14-布线问题"><a href="#5-14-布线问题" class="headerlink" title="5-14 布线问题"></a>5-14 布线问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114815154.png" alt="image-20230105114815154" style="zoom:67%;"></p>
<p>经典排列树，然后剪枝策略可以维护一个当前最优解的成本，若当前成本大于等于该变量，则剪去该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-10"><a href="#1-解空间和解结构-10" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个元件的布线问题，其解空间为1~n的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-10"><a href="#2-剪枝策略-10" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护当前最优解的成本<code>bestv</code>和当前费用<code>cv</code>，在考虑线路板t位置上是否放置元件i时，若当前费用加上放置元件i所带来的成本小于当前最优解的成本，则可继续搜索，否则剪去该分支</p>
<h3 id="3-示例-9"><a href="#3-示例-9" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106111415596.png" alt="image-20230106111415596" style="zoom: 50%;"></p>
<h3 id="4-代码-9"><a href="#4-代码-9" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> conn[N][N];</span><br><span class="line"><span class="type">int</span> bestx[N];</span><br><span class="line"><span class="type">int</span> bestv=INT_MAX;</span><br><span class="line"><span class="type">int</span> cv;</span><br><span class="line"><span class="type">int</span> cx[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">currentvalue</span><span class="params">(<span class="type">int</span> cx[],<span class="type">int</span> t)</span><span class="comment">//计算cx第t位带来的成本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)<span class="comment">//t是从0开始的</span></span><br><span class="line">    &#123;</span><br><span class="line">        res=res+conn[cx[i]][cx[t]]*(t-i);<span class="comment">//cx从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)<span class="comment">//到达叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(cv&lt;bestv)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              bestx[i]=cx[i];</span><br><span class="line">          &#125;</span><br><span class="line">          bestv=cv;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;n;i++)<span class="comment">//cx从0开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(cx[t],cx[i]);</span><br><span class="line">        <span class="type">int</span> value=<span class="built_in">currentvalue</span>(cx,t);<span class="comment">//计算t这一位带来的成本</span></span><br><span class="line">        <span class="keyword">if</span>(value+cv&lt;bestv)<span class="comment">//满足限界条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            cv+=value;</span><br><span class="line">            <span class="built_in">traceback</span>(t+<span class="number">1</span>);</span><br><span class="line">            cv-=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(cx[t],cx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;conn[i][j];<span class="comment">//构造领接矩阵</span></span><br><span class="line">            conn[j][i]=conn[i][j];<span class="comment">//补全另一半</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cx[i]=i+<span class="number">1</span>;<span class="comment">//当前解,先初始化为123...</span></span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;bestv&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-5"><a href="#5-时间复杂度-5" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于n个元件的布线问题，对于非叶子节点，其消耗的时间与其层数t有关，为$O(n-t)$,对于叶子节点，其消耗的时间为$O(n)$，故该问题时间消耗为:$T=n<em>n+n</em>(n-1)<em>(n-1)+n</em>(n-1)<em>(n-2)</em>(n-2)+…+n!+n!<em>n=O(n!</em>n)$</p>
<h1 id="5-15-最佳调度问题"><a href="#5-15-最佳调度问题" class="headerlink" title="5-15 最佳调度问题"></a>5-15 最佳调度问题</h1><h3 id><a href="#" class="headerlink" title></a><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115631677.png" alt="image-20230105115631677" style="zoom:67%;"></h3><p>可以一一为每个任务分配工作，每个任务都可以尝试分配给每台机器，从而对排列树进行搜索。用一个数组存储每台机器已经分配的任务的总耗时，搜索到可行解后这个数组中的最大值即为当前解所需时间，在剪枝的过程中，将更新后该数组的值（即表示选择分配给该机器）与当前最优解的耗时比较，若小于则可继续搜索。</p>
<h3 id="1-解空间和解结构-11"><a href="#1-解空间和解结构-11" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个任务k台机器的最佳调度问题，其解空间为长度为n的向量，向量的每一项为1~k，解结构为排列树</p>
<h3 id="2-剪枝策略-11"><a href="#2-剪枝策略-11" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>按照题意，要求完成全部任务的时间最早，故维护变量<code>mintime</code>表示当前最优解的完成时间，数组<code>ans</code>存储每台机器完成当前任务后的时间，在任务分配过程中，尝试将任务i分配给机器j，若<code>t[i]+ans[j]&gt;=mintime</code>，则将该分支剪去，无需再搜索</p>
<h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 3</span><br><span class="line">2 14 4 16 6 5 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k,t[<span class="number">99</span>],ans[<span class="number">99</span>],min_time=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//ans[i]表示第i个机器运行完其上任务后的时间</span></span><br><span class="line"><span class="comment">//t[i]表示第i个任务需要的时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(level==n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp=*<span class="built_in">max_element</span>(ans,ans+n);<span class="comment">//max_element找数组的最大值</span></span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;min_time) min_time=tmp;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="comment">//尝试分配给第i台机器</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans[i]+=t[level];</span><br><span class="line">		<span class="keyword">if</span>(ans[i]&lt;min_time) <span class="built_in">dfs</span>(level+<span class="number">1</span>);</span><br><span class="line">		ans[i]-=t[level];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	cin&gt;&gt;t[i];</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;min_time&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，其时间消耗为$O(k)$，对于叶子节点，其时间消耗为$O(n)$，故对于n个任务k台机器的最佳调度问题，其时间消耗为$T=k<em>(k+k^2+…+k^{n-1})+n</em>k^n=O(n*k^n)$</p>
<h1 id="5-16-无优先级运算问题"><a href="#5-16-无优先级运算问题" class="headerlink" title="5-16 无优先级运算问题"></a>5-16 无优先级运算问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115723106.png" alt="image-20230105115723106" style="zoom:67%;"></p>
<p>有点类似于整数变换问题，这里也是不知道树的层数，可以从1个数，2个数，…,n个数逐步增加树的层数，在选择数的时候，只能使用未选过的数，以此作为剪枝策略（可以用过数组记录某个数是否选过），使用数组记录该数右侧的运算符，每种符号的选择均作为分支向下搜索，当到达叶子节点时，检查当前运算结果是否为m，若为m，则不继续搜索，程序结束</p>
<h3 id="1-解空间和解结构-12"><a href="#1-解空间和解结构-12" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个正整数的无优先级运算问题，其解空间为长度为2k-1(k从1到n)的向量，该向量的每一个奇数项为1~n的数且相互之间不重复，偶数项为1、2、3、4，分别表示<code>+,-,*,\</code>，解的结构为排列树，具体而言如下所示：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106212553925.png" alt="image-20230106212553925" style="zoom:50%;"></p>
<h3 id="2-剪枝策略-12"><a href="#2-剪枝策略-12" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护数组<code>flag</code>表示n个数是否使用，<code>flag[i]=1</code>表示第i个数已经使用，当给第dep位数选择数时，若该数已经使用过，则无法选择，剪去该分支</p>
<h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 25</span><br><span class="line">5 2 3 6 7</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];<span class="comment">//存储题目所给n个数</span></span><br><span class="line"><span class="type">int</span> num[N];<span class="comment">//存储当前解</span></span><br><span class="line"><span class="type">int</span> oper[N];<span class="comment">//num[i] oper[i] num[i+1]</span></span><br><span class="line"><span class="type">int</span> flag[N];<span class="comment">//存储i个数的状态，是否使用</span></span><br><span class="line"><span class="type">int</span> k;<span class="comment">//表示使用的数的个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">found</span><span class="params">()</span></span>&#123;<span class="comment">//判断是否找到解</span></span><br><span class="line">    <span class="type">int</span> x=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(oper[i])&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:x+=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:x-=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:x*=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:x/=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x==m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> dep)</span><span class="comment">//考虑第dep个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">found</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//第dep个数尝试选择数i</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num[dep]=a[i];</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)<span class="comment">//选择该数右边的符号</span></span><br><span class="line">            &#123;</span><br><span class="line">                oper[dep]=j;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traceback</span>(dep+<span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">()</span><span class="comment">//输出函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;num[i];</span><br><span class="line">        <span class="keyword">switch</span>(oper[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:cout&lt;&lt;<span class="string">&quot;+&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:cout&lt;&lt;<span class="string">&quot;-&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:cout&lt;&lt;<span class="string">&quot;*&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:cout&lt;&lt;<span class="string">&quot;/&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num[k];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        flag[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traceback</span>(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">out</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-时间复杂度-1"><a href="#4-时间复杂度-1" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，需要n个数，每个非叶子节点的时间消耗为$O(n)$，每个叶子节点的时间消耗为$O(n)$，此时时间消耗为$T=n(1+n+4<em>n+4</em>n^2+4^2<em>n^2+…+4^{n-1}</em>n^{n})=O(n^n<em>n</em>4^{n-1})$，真的很大。。。</p>
<h1 id="5-17-世界名画陈列馆问题"><a href="#5-17-世界名画陈列馆问题" class="headerlink" title="5-17 世界名画陈列馆问题"></a>5-17 世界名画陈列馆问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115824426.png" alt="image-20230105115824426" style="zoom:67%;"></p>
<p>input:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 </span><br><span class="line">0 0 1 0</span><br><span class="line">1 0 0 0</span><br><span class="line">0 0 0 1</span><br><span class="line">0 1 0 0</span><br></pre></td></tr></table></figure>
<p>这题的思路参考了书的答案，他的剪枝策略有点复杂</p>
<h3 id="1-解空间和解结构-13"><a href="#1-解空间和解结构-13" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>解空间为长度为n*m的向量，向量的每一项为0或者1，表示是否放置警卫，解结构为子集树</p>
<h3 id="2-剪枝策略-13"><a href="#2-剪枝策略-13" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><ol>
<li>可以证明,当前访问的格点(i,j)已被监视时,放置在(i,j)的情况一定不会比放置在(i+1,j+1)的情况好.当(i+1,j+1)不在网格中时,(i+1,j)和(i,j+1)同理.所以,如果(i,j)已被监视,则不需要在此处放置机器人,直接跳过即可.（update,证明：因为是从上到下从左到右使得格子进入监视状态，当前正在检查访问(i,j)。说明在这之前的(i-1,j)和(i,j-1)已被监视。此时如果放在(i,j)处，只会使得(i+1,j)和(i,j+1)进入访问状态。而如果放在(i+1,j+1)处，显然在完成上述目标的情况下可以使更多格子进入访问状态）</li>
<li>当(i,j)未被监视时,若(i,j+1)已被监视,则在(i,j)放置一定不会比在(i+1,j)放置的情况好.所以当且仅当(i,j)在网格右下角或者(I,j+1)未被监视时才考虑放置在(i,j)的情况.</li>
<li>当(i,j)未被监视时,若(i,j+1)和(i,j+2)均被监视,则在(i+1,j)放置一定不会比在(i+1,j)放置的情况好,所以当且仅当(i,j+1)或(i,j+2)未被监视时才考虑放置在(i,j+1)的情况.</li>
<li>当i=n时,不考虑放置在(i+1,j)的情况.</li>
<li>记录已经监视的格点数,(当前最优值减去当前已放置个数)*5如果小于未监视的格点数,则一定达不到比当前最优值更好的情况,剪去.</li>
<li>类似于(5),考虑更紧的情况,并非每个机器人都能独立监视5个格点,至少会有m/4+5的冗余,这个剪枝仅适用于i&lt;n-1的情况,因为最后两行由于最优值和已放置个数非常接近,总是达不到这个值.</li>
</ol>
<blockquote>
<p>大概就是分为下界剪枝法和控制剪枝法两种，下界剪枝法就是计算剩余需要的警卫数，然后加上当前警卫数和当前最优解警卫数比较，控制剪枝法就是一堆已经证明的放置策略，如2、3、4,</p>
</blockquote>
<h3 id="3-代码-3"><a href="#3-代码-3" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下</span></span><br><span class="line"><span class="type">int</span> x[N][N];<span class="comment">//当前的放置策略</span></span><br><span class="line"><span class="type">int</span> y[N][N];<span class="comment">//是否受监视</span></span><br><span class="line"><span class="type">int</span> bestx[N][N];<span class="comment">//最优放置策略</span></span><br><span class="line"><span class="type">int</span> n,m,best,k=<span class="number">0</span>,t=<span class="number">0</span>,t1,t2,more;</span><br><span class="line"><span class="comment">//k为当前警卫数量</span></span><br><span class="line"><span class="comment">//t为当前受监视的位置的个数</span></span><br><span class="line"><span class="type">bool</span> p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">place</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//在(i,j)处放置警卫,改变相邻位置的监视情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x[i][j]=<span class="number">1</span>;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">5</span>;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=i+d[s][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> q=j+d[s][<span class="number">2</span>];</span><br><span class="line">        y[p][q]++;</span><br><span class="line">        <span class="keyword">if</span>(y[p][q]==<span class="number">1</span>) t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noplace</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//用于撤销在(i,j)上放置的警卫</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x[i][j]=<span class="number">0</span>;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">5</span>;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=i+d[s][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> q=j+d[s][<span class="number">2</span>];</span><br><span class="line">        y[p][q]--;</span><br><span class="line">        <span class="keyword">if</span>(y[p][q]==<span class="number">0</span>) t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;m)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!(y[i][j]==<span class="number">0</span>||i&gt;n));</span><br><span class="line">    <span class="comment">//若当前坐标未受监视或全部坐标都受到监视跳出循环</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;best)&#123;</span><br><span class="line">            best=k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    bestx[i][j]=x[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k+(t1-t)/<span class="number">5</span>&gt;=best)<span class="comment">//利用k和t估计警卫下界,</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;n<span class="number">-1</span>)&amp;&amp;(k+(t2-t)/<span class="number">5</span>)&gt;=best)<span class="comment">//也是利用k和t估计下界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n)&#123;<span class="comment">//下侧放警卫</span></span><br><span class="line">        <span class="built_in">place</span>(i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="built_in">traceback</span>(i,j);</span><br><span class="line">        <span class="built_in">noplace</span>(i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;m&amp;&amp;(y[i][j+<span class="number">1</span>]==<span class="number">0</span>||y[i][j+<span class="number">2</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">place</span>(i,j+<span class="number">1</span>);<span class="comment">//在右侧放警卫</span></span><br><span class="line">        <span class="built_in">traceback</span>(i,j);</span><br><span class="line">        <span class="built_in">noplace</span>(i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((y[i+<span class="number">1</span>][j]==<span class="number">0</span>&amp;&amp;y[i][j+<span class="number">1</span>]==<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">place</span>(i,j);<span class="comment">//在本身放警卫</span></span><br><span class="line">        <span class="built_in">traceback</span>(i,j);</span><br><span class="line">        <span class="built_in">noplace</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;best&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;bestx[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下界剪枝法的辅助，主要是用来辅助通过t和k估计警卫人数的下界的</span></span><br><span class="line">    more=m/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m%<span class="number">4</span>==<span class="number">3</span>)</span><br><span class="line">        more++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m%<span class="number">4</span>==<span class="number">2</span>)</span><br><span class="line">        more+=<span class="number">2</span>;</span><br><span class="line">    t2=m*n+more+<span class="number">4</span>;</span><br><span class="line">    t1=m*n+<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//下面就很好看懂了</span></span><br><span class="line">    best=INT_MAX;</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        y[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        y[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-18-世界名画陈列馆问题（不重复监视）"><a href="#5-18-世界名画陈列馆问题（不重复监视）" class="headerlink" title="5-18 世界名画陈列馆问题（不重复监视）"></a>5-18 世界名画陈列馆问题（不重复监视）</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115900644.png" alt="image-20230105115900644" style="zoom: 80%;"></p>
<p>在5-17上改了下，框架没变，去掉了答案那些控制剪枝法的剪枝策略，加上了题目中要求的不重复监视的剪枝策略，且在叶子节点处加上了对整个矩阵检查是否全部监视了，主要加了check函数，checkall函数，改了traceback函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下</span></span><br><span class="line"><span class="type">int</span> x[N][N];<span class="comment">//当前的放置策略</span></span><br><span class="line"><span class="type">int</span> y[N][N];<span class="comment">//是否受监视</span></span><br><span class="line"><span class="type">int</span> bestx[N][N];<span class="comment">//最优放置策略</span></span><br><span class="line"><span class="type">int</span> n,m,best,k=<span class="number">0</span>,t=<span class="number">0</span>,t1,t2,more;</span><br><span class="line"><span class="comment">//k为当前警卫数量</span></span><br><span class="line"><span class="comment">//t为当前受监视的位置的个数</span></span><br><span class="line"><span class="type">bool</span> p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">place</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//在(i,j)处放置警卫,改变相邻位置的监视情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x[i][j]=<span class="number">1</span>;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">5</span>;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=i+d[s][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> q=j+d[s][<span class="number">2</span>];</span><br><span class="line">        y[p][q]++;</span><br><span class="line">        <span class="keyword">if</span>(y[p][q]==<span class="number">1</span>) t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//检查(i,j)是否能放置警卫</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">5</span>;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=i+d[s][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> q=j+d[s][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(y[p][q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkall</span><span class="params">()</span><span class="comment">//检查是否全部都有警卫</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!y[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noplace</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//用于撤销在(i,j)上放置的警卫</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x[i][j]=<span class="number">0</span>;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">5</span>;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=i+d[s][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> q=j+d[s][<span class="number">2</span>];</span><br><span class="line">        y[p][q]--;</span><br><span class="line">        <span class="keyword">if</span>(y[p][q]==<span class="number">0</span>) t--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;m)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!(y[i][j]==<span class="number">0</span>||i&gt;n));</span><br><span class="line">    <span class="comment">//若当前坐标未受监视或全部坐标都受到监视跳出循环</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;best&amp;&amp;<span class="built_in">checkall</span>())&#123;</span><br><span class="line">            best=k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    bestx[i][j]=x[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k+(t1-t)/<span class="number">5</span>&gt;=best)<span class="comment">//利用k和t估计警卫下界,</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>((i&lt;n<span class="number">-1</span>)&amp;&amp;(k+(t2-t)/<span class="number">5</span>)&gt;=best)<span class="comment">//也是利用k和t估计下界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">place</span>(i,j);</span><br><span class="line">       <span class="built_in">traceback</span>(i,j);</span><br><span class="line">       <span class="built_in">noplace</span>(i,j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">traceback</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;best&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;bestx[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    more=m/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m%<span class="number">4</span>==<span class="number">3</span>)</span><br><span class="line">        more++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m%<span class="number">4</span>==<span class="number">2</span>)</span><br><span class="line">        more+=<span class="number">2</span>;</span><br><span class="line">    t2=m*n+more+<span class="number">4</span>;</span><br><span class="line">    t1=m*n+<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//下面就很好看懂了</span></span><br><span class="line">    best=INT_MAX;</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>&amp;&amp;m==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-19-算m点问题"><a href="#5-19-算m点问题" class="headerlink" title="5-19 算m点问题"></a>5-19 算m点问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115926418.png" alt="image-20230105115926418" style="zoom: 80%;"></p>
<p>类似于5-16，但是这里一定用到了k个整数，所以只需要稍微改改(把k设置为n-1然后改输出)，而且这种计算方式可以看成是无优先级的</p>
<p>示例应该给错了，应该是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 125</span><br><span class="line">7 2 2 12 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];<span class="comment">//存储题目所给n个数</span></span><br><span class="line"><span class="type">int</span> num[N];<span class="comment">//存储当前解</span></span><br><span class="line"><span class="type">int</span> oper[N];<span class="comment">//num[i] oper[i] num[i+1]</span></span><br><span class="line"><span class="type">int</span> flag[N];<span class="comment">//存储i个数的状态，是否使用</span></span><br><span class="line"><span class="type">int</span> k;<span class="comment">//表示使用的数的个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">found</span><span class="params">()</span></span>&#123;<span class="comment">//判断是否找到解</span></span><br><span class="line">    <span class="type">int</span> x=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(oper[i])&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:x+=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:x-=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:x*=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:x/=num[i+<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x==m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> dep)</span><span class="comment">//考虑第dep个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">found</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//第dep个数尝试选择数i</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num[dep]=a[i];</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)<span class="comment">//选择该数右边的符号</span></span><br><span class="line">            &#123;</span><br><span class="line">                oper[dep]=j;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traceback</span>(dep+<span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">()</span><span class="comment">//输出函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">switch</span>(oper[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:cout&lt;&lt;<span class="string">&quot;+&quot;</span>;ans+=num[i+<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:cout&lt;&lt;<span class="string">&quot;-&quot;</span>;ans-=num[i+<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:cout&lt;&lt;<span class="string">&quot;*&quot;</span>;ans*=num[i+<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:cout&lt;&lt;<span class="string">&quot;/&quot;</span>;ans/=num[i+<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;num[i+<span class="number">1</span>]&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        flag[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traceback</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">out</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No Solution!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106220815943.png" alt="image-20230106220815943"></p>
<h1 id="5-20-部落卫队问题"><a href="#5-20-部落卫队问题" class="headerlink" title="5-20 部落卫队问题"></a>5-20 部落卫队问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120010640.png" alt="image-20230105120010640"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120024040.png" alt="image-20230105120024040"></p>
<p>类似于0-1背包问题，子集树，左子树为1，右子树为0,约束函数就是不能和当前卫队里已有的居民为仇敌，若为仇敌，则剪去左子树。限界函数是当前卫队里的人数加上除去当前考虑的居民的剩余的居民，若数量还是比best小，则剪去右子树</p>
<h3 id="1-解空间和解结构-14"><a href="#1-解空间和解结构-14" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个居民的部落卫队问题，其解空间为长度为n的向量，向量的每一项为0或者1，解结构为子集树</p>
<h3 id="2-剪枝策略-14"><a href="#2-剪枝策略-14" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑居民t是否加入卫队，加入卫队即进入左子树，否则进入右子树</p>
<p>约束函数：若居民t和1~t-1中已经加入卫队的居民直接有仇视关系，则t不能加入卫队，剪去左子树</p>
<p>限界函数：若居民t不加入卫队，维护变量cv为当前卫队中居民人数，则卫队未来可能的最多人数为<code>cv+n-t</code>，若该值大于n，才搜索右子树，否则剪去右子树</p>
<h3 id="3-代码-4"><a href="#3-代码-4" class="headerlink" title="3. 代码"></a>3. 代码</h3><p>input：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 10</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//n个居民,m个关系</span></span><br><span class="line"><span class="type">int</span> relation[N][N];<span class="comment">//居民关系,0表示正常，1表示仇视,从1开始的</span></span><br><span class="line"><span class="type">int</span> cbest=<span class="number">0</span>;<span class="comment">//最多的卫兵</span></span><br><span class="line"><span class="type">int</span> bestx[N];<span class="comment">//存储最优解</span></span><br><span class="line"><span class="type">int</span> cv=<span class="number">0</span>;<span class="comment">//当前卫兵人数</span></span><br><span class="line"><span class="type">int</span> x[N];<span class="comment">//当前解,x[i]=1表示第i个居民是卫兵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//第t个居民是否作为卫兵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)<span class="comment">//到达叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv&gt;cbest)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bestx[i]=x[i];</span><br><span class="line">                cbest=cv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;<span class="comment">//判断是否有冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]==<span class="number">1</span>&amp;&amp;relation[t+<span class="number">1</span>][i+<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="comment">//考虑是否进入左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=<span class="number">1</span>;</span><br><span class="line">        cv++;</span><br><span class="line">        <span class="built_in">traceback</span>(t+<span class="number">1</span>);</span><br><span class="line">        x[t]=<span class="number">0</span>;</span><br><span class="line">        cv--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cv+n-t&gt;cbest)<span class="comment">//考虑是否进入右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">traceback</span>(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> t1,t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//构造领接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">        relation[t1][t2]=<span class="number">1</span>;</span><br><span class="line">        relation[t2][t1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);<span class="comment">//从第0个居民开始考虑</span></span><br><span class="line">    cout&lt;&lt;cbest&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106230008395.png" alt="image-20230106230008395" style="zoom:67%;"></p>
<h3 id="4-时间复杂度-2"><a href="#4-时间复杂度-2" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，搜索所需时间为$O(t+1)$，其中t为当前的层数，对于叶子节点，其搜索所需时间为$O(n)$，故居民数量为n的部落卫队问题的时间复杂度为$O(n*2^n)$</p>
<h1 id="5-21、5-22"><a href="#5-21、5-22" class="headerlink" title="5-21、5-22"></a>5-21、5-22</h1><p>装载问题和0-1背包问题，见书上例题~</p>
<h1 id="5-23-圆排列问题"><a href="#5-23-圆排列问题" class="headerlink" title="5-23 圆排列问题"></a>5-23 圆排列问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106231319219.png" alt="image-20230106231319219" style="zoom: 80%;"></p>
<p>排列树，在选择一个圆的时候，就能计算他带来的长度（需要单独考虑第一个和最后一个的半径带来的长度），维护当前最优解，若当前解小于最优解才继续搜索，看看代码大概就能懂啦（突然发现书上有这道例题，也可以看看书上的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 2</span><br></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-15"><a href="#1-解空间和解结构-15" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>n个圆的圆排列问题的解空间为1~n的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-15"><a href="#2-剪枝策略-15" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护变量<code>minlen</code>表示当前最优解的长度，<code>clen</code>表示当前长度，当考虑放置第t个圆时，计算其带来的长度<code>l</code>，若<code>l+clen&gt;=minlen</code>，则剪去该子树</p>
<h3 id="3-代码-5"><a href="#3-代码-5" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> r[N];</span><br><span class="line"><span class="type">double</span> minlen=DBL_MAX;</span><br><span class="line"><span class="type">double</span> clen=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x[N];<span class="comment">//当前的排列</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bring</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">return</span> r[x[t]];<span class="comment">//第一个就是半径</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//加上t和t-1位置上圆心的x之间的距离</span></span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        res=<span class="built_in">sqrt</span>((r[x[t]]+r[x[t<span class="number">-1</span>]])*(r[x[t]]+r[x[t<span class="number">-1</span>]])-<span class="built_in">abs</span>(r[x[t]]-r[x[t<span class="number">-1</span>]])*<span class="built_in">abs</span>(r[x[t]]-r[x[t<span class="number">-1</span>]]));</span><br><span class="line">        <span class="keyword">if</span>(t==n<span class="number">-1</span>) res+=r[x[t]];<span class="comment">//最后一个还要加半径</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//考虑放置的第t个圆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==n)<span class="comment">//叶节点，更新min</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(clen&lt;minlen) minlen=clen;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;n;i++)<span class="comment">//考虑将未使用的圆放在t位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">        <span class="type">double</span> ctmp=clen;</span><br><span class="line">        <span class="keyword">if</span>(clen+<span class="built_in">bring</span>(t)&lt;minlen)<span class="comment">//当前长度小于最优解长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            clen=clen+<span class="built_in">bring</span>(t);</span><br><span class="line">            <span class="built_in">traceback</span>(t+<span class="number">1</span>);</span><br><span class="line">            clen=ctmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x[t],x[i]);t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">        x[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;minlen;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-时间复杂度-3"><a href="#4-时间复杂度-3" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，搜索所需时间为$O(n-t)$，t为叶子节点的层数，对于叶子节点，搜索所需时间为$O(1)$，故n个圆的圆排列问题的最坏情况下时间复杂度为$O(n!)$</p>
<h1 id="5-24"><a href="#5-24" class="headerlink" title="5-24"></a>5-24</h1><p>图着色问题，见书上例题~</p>
<h1 id="5-25-最短加法链问题"><a href="#5-25-最短加法链问题" class="headerlink" title="5-25 最短加法链问题"></a>5-25 最短加法链问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120329010.png" alt="image-20230105120329010" style="zoom: 80%;"></p>
<p>类似于整数变换那题，也是树的层数未知，所以可以用变量控制层数慢慢加大，可以采用无优先级运算问题的类似框架去解这道题，不同的是这题随着层数的加大分支数也加大了，剪枝策略是当前考虑的项不能大于23，看看代码就差不多~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//需要得到的数</span></span><br><span class="line"><span class="type">int</span> x[N];<span class="comment">//加法链数组</span></span><br><span class="line"><span class="type">int</span> k;<span class="comment">//控制层数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//考虑加法链的第t项</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[k<span class="number">-1</span>]==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择加法链中的两个相加得到第t项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i]+x[j]&lt;=n)<span class="comment">//剪枝，该项要小于等于n</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[t]=x[i]+x[j];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traceback</span>(t+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)<span class="comment">//最多n层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traceback</span>(<span class="number">1</span>))<span class="comment">//这里得是1,因为如果是0会直接返回false</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;k<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒花🎉~</p>
]]></content>
  </entry>
</search>
